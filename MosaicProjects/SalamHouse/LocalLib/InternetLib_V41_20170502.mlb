(*` {CSY}Knihovna v˝vojovÈho systÈmu Mosaic{ENU}Mosaic IDE library *)
(*` {CSY}JmÈno souboru{ENU}File name{} : D:\TecoUserLibs\InternetLib_V41_20170502.mlb *)
(*` {CSY}Knihovna : InternetLib{ENU}Library : InternetLib{} 4.1 *)
(*` {CSY}Autor{ENU}Author{} : Teco a.s. *)
(*` {CSY}Autorsk· pr·va{ENU}Copyright{} : (c) 2010 - 2017 *)
(*` {CSY}Verze IEC p¯ekladaËe{ENU}IEC compiler version{} : 3.12.13.1 *)
(*` {CSY}Verze assembleru{ENU}Assembler version{} : 4.3.00 *)

//{Knihovna : InternetLib 4.1  }
(*` {CSY}Historie{ENU}History{}: *)
(*`
{CSY}
v4.1 02.05.2017 Byd
  fbSmtp : P¯id·na moûnost urËit typ p¯Ìlohy a generovat Message-ID pro blok 
  fbSmtp : Opravena definice hranice, kter· byla delöÌ neû doporuËen˝ch 80 znak˘ v fbSmtp
  fbSmtp : ÿ·dky p¯Ìlohy kÛdovanÈ Base64 zkr·ceny na 76 znak˘, aby vyhovovaly bÏûn˝m zvyklostem
v4.0 16.02.2017 Byd
  Upraven blok fbSmtp pro z·pornÈ posunutÌ ËasovÈho p·sma
v3.9 09.12.2016 Byd
  P¯id·n blok pro zÌsk·nÌ souboru z FTP serveru fbRetriveFromFtp  
v3.8 19.10.2016 Nem
  P¯id·ny bloky fbPingIP a fbPing - nutn˝ Foxtrot FW v9.9 nebo vyööÌ
v3.7 23.09.2016 Byd
  KÛdov·nÌ do Base64 vyuûÌv· EncryptLib - nutn˝ firmware firmware v8.8
  P¯id·n blok fbRetriveFromFtp pro zÌsk·nÌ souboru z FTP serveru
  Upraven blok fbSplitUrlAddress, aby dok·zal pracovat s adresou vËetnÏ jmÈna a hesla pro z·kladnÌ autentifikaci
  P¯id·na moûnost aktivnÏ uzav¯Ìt spojenÌ pro bloky fbHttpRequest, fbHttpRequestL a fbHttpRequestL2
  U bloku fbSmtp je moûnÈ zadat znakovou sadu, kter· se uplatnÌ pro p¯edmÏt a tÏlo zpr·vy
v3.6 16.05.2016 Byd
  Blok fbSmtp rozöÌ¯en o moûnost skrytÈ kopie (adresa p¯ed kterou je uvedena teËka nenÌ p¯Ìjemci zobrazen
v3.5 20.11.2015 Byd
  Bloky HttpRequest nastavujÌ v˝stup Busy ve stejnÈm cyklu, kdy opouötÌ stav Idle
v3.4 26.10.2015 Byd
  P¯Ìd·n blok fbSplitUrlAddress
v3.3 18. 9.2015 Byd
  ⁄prava bloku fbSMTP - pouûitÌ EHLO mÌsto HELO
v3.2  4. 9.2015 Byd
  Vynech·n KeyID a Message Authentication Code ze SNTP
v3.1 22. 4.2014 Byd
  Blok fbStoreToFtp kontroluje p¯eplnÏnÌ odesÌlacÌho TCP bufferu (vyûaduje ComLib 
1.4)
v3.0  2. 4.2014 Byd
  V˝stup Done bloku fbSmtp byl nastaven i v p¯ÌpadÏ, kdy se nepovedlo zpr·vu ˙spÏönÏ 
odeslat.
  RychlejöÌ kÛdovanÌ Base64
  OdstranÏn˝ hazard p¯i odesÌl·nÌ dlouh˝ch p¯Ìloh z verze 2.8
v2.9 22.10.2013 Byd
  P¯id·n funkËnÌ blok fbHttpRequestL2 s moûnostÌ zadat typ obsahu (Content-Type)
v2.8  6.6.2013 Byd
  Blok fbStoreToFtp udrûuje ¯ÌdÌcÌ spojenÌ bÏhem vysÌl·nÌ dat (vyûaduje firmware 
7.7)
  Blok fbSmtp podporuje vÌce¯·dkovÈ odpovÏdi serveru
v2.7 29.5.2013 Byd
  Blok fbStoreToFtp akceptuje p¯i p¯Ìstupu na neexistujÌcÌ soubor vöechny negativnÌ 
odpovÏdi s kÛdem 5xx
  Blokov·nÌ timeoutu u fbStoreToFtp p¯i p¯enosu velk˝ch soubor˘
v2.6 27.2.2013 Byd
  ⁄prava bloku fbSntp pro z·pornÈ ofsety Ëasu od UTC
  ProdlouûenÌ timeoutu pro HTTP protokol
v2.5 16.1.2013 Byd
  Oprava chyby bloku fbHttpRequestL zanesen· ve verzi 2.4 (blok odesÌlal jen 
hlaviËku)
V2.4 5.10.2012 Byd
  P¯id·na podpora z·kladnÌ autentifikace p¯edan· v URI jmeno:heslo@domain
V2.3 21.8.2012 Byd
  Vytvo¯enÌ cesty na FTP serveru
  Moûnost nahr·vat celÈ adres·¯e na FTP
V2.2 6.3.2012 Byd
  VypuötÏn pr·zdn˝ p¯Ìkaz v komunikaci se SMTP serverem (nÏkterÈ servry vracely 
negativnÌ odpovÏÔ)
V2.1 13.2.2012 Byd
  DoplÚen blok NsLookUpEx pro p¯eklad domÈnov˝ch jmen s podporou firmware
  (vyûaduje firmware 7.1 nebo vyööÌ)
  Opraveno chov·nÌ v˝stup˘ Done a Err v fbStoreToFtp 
V2.0  1.12.2011 Byd
  Funkce GetDateAndTime_RFC2822 p¯esunuta do knihovny TimeLib  
V1.9  8.4.2011 Byd
  DoplnÏno hlÌd·nÌ dÈlky p¯i odesÌl·nÌ dat p¯es HTTP
  DoplnÏn blok fbHttpRequestL pro odesÌl·nÌ dlouh˝ch dat metodou POST
  DoplnÏn blok fbStringStream pro naplnÏnÌ pracovnÌho buferu z promÏnn˝ch typu 
STRING
V1.8 17.3.2010 Byd
  DoplnÏna Ëasov· znaËka p¯i odesÌl·nÌ p¯es SMTP
V1.7 8.12.2010 Byd
V1.6 1.12.2010 Byd
  DoplnÏn kÛd odpovÏdi 125 pokud je spojenÌ s FTP serverem jiû nav·z·no.
V1.5 2.9.2010 Byd
  DoplnÏny z·vislosti na knihovn·ch.
V1.4 Byd 
  fbStoreToFtp - p¯id·no chybÏjÌcÌ zav¯enÌ souboru v p¯ÌpadÏ chyby p¯enosu. Mohlo 
zp˘sobit aû blokov·nÌ file systÈmu.
V1.3 Byd
  fbStoreToFtp - blok pro p¯enos souboru na FTP server 
V1.2 Byd
  NsLookUp - rozöÌ¯enÈ p¯Ìznaky chyb 2 aû 16 odpovÌdajÌ ResponseCode dle RFC1035 + 1
V1.1 Byd
  Smtp blok kontroluje p¯eplnÏnÌ odesÌlacÌho TCP bufferu (vyûaduje ComLib 1.4)
{ENG}
v4.1 2017-05-02 Byd
  fbSmtp: Added option to assign attachement type and generate Message-ID
  fbSmtp: Fixed boundary definition that was longer than recommended 80 characters
  fbSmtp: Base64-encoded attachment lines are truncated to 76 characters to comply with common standard
v4.0 2017-02-16 Byd
  Modified block fbSmtp for negative UTC offsets
v3.9 2016-12-09 Byd
  Added block for retrieving file from FTP server fbRetriveFromFtp
v3.8 2016-10-19 Nem
  Added blocks fbPingIP and fbPing (requires Foxtrot FW v9.9 or more)
v3.7 2016-09-23 Byd
  Encoding to Base64 is using EncryptLib - firmware v8.8 is mandatory
  Added block fbRetriveFromFtp for obtaining file from FTP server
  Modified block fbSplitUrlAddress to be able to work with address including name and password for basic authentication
  Added possibility to actively close connection for blocks fbHttpRequest, fbHttpRequestL and fbHttpRequestL2
  For block fbSmtp it's now possible to specify charset, which is used for subject and body of mail
v3.6 2016-05-16 Byd
  Block fbSmtp expanded to allow blind copy (address, in front of which is put a full 
stop, won't be displayed to recipient)
v3.5 2015-11-20 Byd
  Blocks HttpRequest set output Busy in the same cycle, when they are leaving Idle 
state
v3.4 2015-10-2 Byd
  Added block fbSplitUrlAddress
v3.3 2015-09-18
  Modification of fbSMTP block - use of EHLO instead of HELO
v3.2 2015-09-04 Byd
  Ommited KeyID and Message Authentication Code from SNTP
v3.1 2014-04-22 Byd
  fbStoreToFtp blok checks overflow of TCP sending buffer (requires ComLib 1.4)
v3.0 2014-04-02 Byd
  Output Done of block fbSmtp was set even if message was not sucessfully sent.
  Faster coding to Base64
  Fixed hazard when sending long attachments from version 2.8
v2.9 2013-10-22 Byd
  Added function blok fbHttpRequestL2 with option to add content type (Content-Type)
v2.8 2013-06-06 Byd
  Block fbStoreToFtp maintains control connections during data transmission 
(requires firmware 7.7)
  Block fbSmtp supports multi-line server responses
v2.7 2013-05-29 Byd
  During access to non-existent file block fbStoreToFtp accepts all negative reply 
codes 5xx
  Blocking timeout for transfer of large files 
v2.6 2013-02-27 Byd
  Modifacation of fbSntp for negative offset from UTC
  Longer timeout for HTTP protocol
v2.5 2013-01-16 Byd
  Fixed error in fbHttpRequestL from version 2.4 (block sent only header)
V2.4 2012-10-05 Byd
  Added support for basic authentication passed in URI name:password@domain 
V2.3 2012-08-21 Byd
  Creating path at FTP server
  Posibility to upload whole directories to FTP
V2.2 2012-03-06 Byd
  Empty command leaved out of communication with SMTP server (some servers returned 
negative reply)
V2.1 2012-02-13 Byd
  Block NsLookUpEx added for translation of domain names with firmware support
  (require firmware 7.1 or higher)
  Corrected behaviour of outputs Done and Err in fbStoreToFtp  
V2.0 2011-12-01 Byd
  Function GetDateAndTime_RFC2822 moved to library TimeLib  
V1.9 2011-04-08 Byd
  Lenght checking added for sending via HTTP
  Block fbHttpRequestL for sending long data via method POST added.
  Block fbStringStream for filling work buffer from STRING variables added.
V1.8 2010-03-17 Byd
  Time stamp added for sending via SMTP 
V1.7 2010-12-8 Byd
V1.6 2010-12-1 Byd
  Added reply code 125 if connection to FTP server is already established. 
V1.5 2010-09-02 Byd
  Dependency on the libraries added.
V1.4 Byd
  fbStoreToFtp - missing closing of file in case of transmission error added. It 
could lead to blocked file system.
V1.3 Byd
  fbStoreToFtp - block for transfering file to FTP server 
V1.2 Byd
  NsLookUp - expanded error numbers from 2 to 16 equal ResponseCode RFC1035 + 1
V1.1 Byd
  Smtp blok checks overflow of TCP sending buffer (requires ComLib 1.4)
*)

(*----------------------------------------------------------------------------*)
{LIBRARY="LOCALLIB\STDLIB_V21_20140514.MLB"}
{LIBRARY="LOCALLIB\SYSLIB_V38_20170104.MLB"}
{LIBRARY="LOCALLIB\TOSTRINGLIB_V13_20110203.MLB"}
{LIBRARY="LOCALLIB\TIMELIB_V15_20170216.MLB"}
{LIBRARY="LOCALLIB\COMLIB_V24_20161019.MLB"}
{LIBRARY="LOCALLIB\FILELIB_V22_20160316.MLB"}
{LIBRARY="LOCALLIB\ENCRYPTLIB_V12_20160923.MLB"}

VAR_GLOBAL CONSTANT
 INTERNETLIB_END_OF_LINE_ {HIDDEN} : string [2] :=  '$r$l';
 INTERNETLIB_EMPTY_STRING_ {HIDDEN} : string [1] :=  '';

END_VAR

__DECL FUNCTION _FindNextPathSeparator {HIDDEN} : bool
  VAR_IN_OUT
    In               : string [80];  (*`string with path*)
    Pos              : udint;  (*`start with zero*)
  END_VAR
END_FUNCTION

TYPE TDnsReplyHeader :
  STRUCT
    TransactionID    : uint;
    Recursion_des    : bool;
    Truncated        : bool;
    Authoritative    : bool;
    OpCode_0         : bool;
    OpCode_1         : bool;
    OpCode_2         : bool;
    OpCode_3         : bool;
    Response         : bool;
    ReplyCode_0      : bool;
    ReplyCode_1      : bool;
    ReplyCode_2      : bool;
    ReplyCode_3      : bool;
    Empty            : bool;
    Autheticated     : bool;
    Reseved          : bool;
    Recursion_ava    : bool;
    Question         : uint;
    AnswerRRs        : uint;
    AuthorityRRs     : uint;
    AdditionalRRs    : uint;
  END_STRUCT;
END_TYPE

TYPE TDnsReply :
  STRUCT
    Header           : TDnsReplyHeader;
    Data             : ARRAY [0..511] OF usint;
  END_STRUCT;
END_TYPE

TYPE TDnsQueryHeader :
  STRUCT
    TransactionID    : uint;
    Recursion_des    : bool;
    Truncated        : bool;
    Empty_6          : bool;
    OpCode_0         : bool;
    OpCode_1         : bool;
    OpCode_2         : bool;
    OpCode_3         : bool;
    Query            : bool;
    Empty_0          : bool;
    Empty_1          : bool;
    Empty_2          : bool;
    Empty_3          : bool;
    NonAutheticated  : bool;
    Empty_4          : bool;
    Reseved          : bool;
    Empty_5          : bool;
    Question         : uint;
    AnswerRRs        : uint;
    AuthorityRRs     : uint;
    AdditionalRRs    : uint;
  END_STRUCT;
END_TYPE

TYPE TDnsQuery :
  STRUCT
    Header           : TDnsQueryHeader;
    QueryString      : string [80];
  END_STRUCT;
END_TYPE

__DECL FUNCTION _internetlib_DnsLenOfDomainName {HIDDEN} : udint
  VAR_INPUT
    IN               : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _internetlib_DnsCodeDomainName {HIDDEN} : string
(*`{CSY}KÛduje jmÈno domÈny
  {ENU}Code name of domain*)
  VAR_INPUT
    IN               : string [80];
  END_VAR
  VAR
    I                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION _internetlib_DnsDecodeDomainName {HIDDEN} : string
(*`{CSY}DekÛduje jmÈno domÈny
  {ENU}Decode name of domain*)
  VAR_INPUT
    IN               : PTR_TO usint;
    BG               : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbNsLookUp
(*`{CSY} ZÌsk· IP adresu zadanÈho domÈnovÈho jmÈna
  {ENU} Gets IP address of the provided domain name*)
  VAR_INPUT
    getIP            : bool R_EDGE;  (*`{ENG}Get IP address by Name {CSY}ZÌskat IP adresu dle jmÈna*)
    chanCode         : uint;  (*`{ENG}UNI channel {CSY}p¯enosov˝ kan·l {} UDP, lport: 0, rport: 53, in: 524, out: 93*)
    DnsIP            : TIPadr;  (*`{ENG}DNS server IP address {CSY}IP adresa DNS serveru*)
  END_VAR
  VAR_IN_OUT
    Name             : string [80];  (*`{ENG}Domain name {CSY}DomÈnove jmÈno*)
    IP               : TIPadr;  (*`{ENG}Obtained IP address {CSY}ZÌskan· IP adresa*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}IP address successfully obtained {CSY}IP adresa obdrûena ˙spÏsnÏ*)
    Busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌha*)
    Err              : bool;  (*`{ENG}Error occured {CSY}Nastala chyba*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
  END_VAR
  VAR
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    timeout          : TON;
    timeout2         : TON;
    netDnsQuery      : TDnsQuery;
    netDnsReply      : TDnsReply;
    TransID          : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbNsLookUpEx
(*`{CSY} ZÌsk· IP adresu zadanÈho domÈnovÈho jmÈna
  {ENU} Gets IP address of the provided domain name*)
  VAR_INPUT
    getIP            : bool R_EDGE;  (*`{ENG}Get IP address by Name {CSY}ZÌskat IP adresu dle jmÈna*)
    dnsIP            : TIPadr;  (*`{ENG}DNS server IP address {CSY}IP adresa DNS serveru*)
    Name             : string [80];  (*`{ENG}Domain name {CSY}DomÈnove jmÈno*)
  END_VAR
  VAR_IN_OUT
    IP               : TIPadr;  (*`{ENG}Obtained IP address {CSY}ZÌskan· IP adresa*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}IP address successfully obtained {CSY}IP adresa obdrûena ˙spÏsnÏ*)
    Busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌha*)
    Err              : bool;  (*`{ENG}Error occured {CSY}Nastala chyba*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
  END_VAR
  VAR
    CurrName         : string [80];  (*`current domain name*)
  END_VAR
END_FUNCTION_BLOCK

TYPE  THttpBuffer : ARRAY [0..511] OF usint;
END_TYPE

TYPE THttpState : 
  (hs_HttpIdle,
   hs_HttpSetIP,
   hs_HttpConnect,
   hs_HttpSend,
   hs_HttpReceivingData,
   hs_HttpSendPost 
  );
END_TYPE

__DECL FUNCTION_BLOCK fbHttpRequest
(*`{ENU}Sends POST and GET metods via HTTP
{CSY}VysÌl· metody GET a POST p¯es HTTP protokol*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*`{ENG}Send data via method POST {CSY}vyslat data metodou POST*)
    Get              : bool R_EDGE;  (*`{ENG}Get data via method GET {CSY}zÌskat data metodu GET*)
    Cancel           : bool R_EDGE;  (*`{ENG}Cancel pending operation {CSY}zruöit probÌhajÌcÌ operaci*)
    chanCode         : uint;  (*`{ENG}UNI channel {CSY}p¯enosov˝ kan·l {}TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*`{ENG}IP address of remote server {CSY}IP adresa vzd·leneho serveru*)
    port             : uint :=  80;  (*`{ENG}Port of remote server {CSY}»Ìslo portu vzd·lenÈho serveru*)
    Close            : bool;  (*`{ENG}If set, block don't wait for server to close connection and close it actively after receiving all data{CSY}Pokud je nastaveno, blok neËek· na server aû zav¯e spojenÌ a zav¯e jej aktivnÏ jakmile zÌsk· vöechny data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*`{ENG}Path to a data on the server (always starts with character '/') {CSY}Cesta k dat˘m na serveru (vûdy zaËÌn· znakem '/')*)
    Host             : string [80];  (*`{ENG}Host name {CSY}JmÈno hostitele*)
    Data             : string [80];  (*`{ENG}POST data {CSY}Data pro metodu POST*)
    RecvData         : THttpBuffer;  (*`{ENG}Data buffer 512 bytes {CSY}Bufer dat 512 byt˘*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}Operation done {CSY}Operace ukonËena*)
    Busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌha*)
    Err              : bool;  (*`{ENG}Communication error {CSY}Chyba komunikace*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
    DataReady        : bool;  (*`{ENG}New data received {CSY}P¯ijata nov· data*)
    DataLen          : uint;  (*`{ENG}Data length {CSY}DÈlka dat*)
    State            : THttpState;  (*`{ENG}State of communication {CSY}Stav komunikace*)
    Result           : int;  (*`{ENG}HTTP Code {CSY}HTTP kod*)
    Progress         : sint;  (*`{ENG}Progress of data downloading {CSY}Pr˘bÏh stahov·nÌ dat*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    WasEOL           : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lHost            : string [80];
  END_VAR
END_FUNCTION_BLOCK

TYPE TSmtpState : 
  (ss_SmtpInit,
   ss_SmtpIdle,
   ss_SmtpSetIP,
   ss_SmtpTxConnect,
   ss_SmtpRxConnect,
   ss_SmtpTxHelo,
   ss_SmtpRxHelo,
   ss_SmtpTxAuthlogin,
   ss_SmtpRxAuthlogin,
   ss_SmtpTxUserName,
   ss_SmtpRxUserName,
   ss_SmtpTxPassword,
   ss_SmtpRxPassword,
   ss_SmtpTxMailFrom,
   ss_SmtpRxMailFrom,
   ss_SmtpTxRcptTo,
   ss_SmtpRxRcptTo,
   ss_SmtpTxData,
   ss_SmtpRxData,
   ss_SmtpTxDataFrom,
   ss_SmtpTxDataTo,
   ss_SmtpTxDataSubject,
   ss_SmtpTxMultipart,
   ss_SmtpTxDataText,
   ss_SmtpTxAttachement,
   ss_SmtpTxAttachementBody,
   ss_SmtpTxEndOfMail,
   ss_SmtpRxAck,
   ss_SmtpTxQuit,
   ss_SmtpRxClose,
   ss_SmtpRxTimeout,
   ss_SmtpRxError,
   ss_SmtpTxDate,
   ss_SmtpTxContentType,
   ss_SmtpTxMessageId 
  );
END_TYPE

VAR_GLOBAL CONSTANT
 SMTP_END_OF_LINE_2_ {HIDDEN} : string [3] :=  '>$r$l';

END_VAR

__DECL FUNCTION_BLOCK fbSmtp
(*`{ENU}Sends email messages via SMTP
  {CSY}OdesÌl· emailovÈ zpr·vy p¯es SMTP*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*`{ENG} starts sending of email {CSY}spustÌ odesl·nÌ zpr·vy*)
    Auth             : bool;  (*`{ENG} authetification requiered? {CSY}vyûaduje server authetifikaci?*)
    Cancel           : bool R_EDGE;  (*`{ENG} cancel action {CSY}stornovat odesÌl·nÌ*)
    chanCode         : uint;  (*`{ENG} channel code {CSY}p¯enosov˝ kan·l {} TCP Master, in: 255, out: 255*)
    IPadr            : TIPadr;  (*`{ENG} IP address of SMTP server {CSY}IP adresa SMTP serveru*)
    port             : uint :=  25;  (*`{ENG} Port of SMTP server {CSY}Port SMTP serveru*)
    Lines            : usint;  (*`{ENG} number of lines {CSY}poËet ¯·dk˘ tÏla zpr·vy*)
    UtcOff           : int;  (*`{ENG} offset from UTC in minutes{CSY}posun ËasovÈho p·sma v minut·ch*)
    charset          : string [16];  (*`{ENG} charset of Email body {CSY}znakov· sada tÏla zpr·vy {}('windows-1250', 'UTF-8',...)*)
    attachementType  : string [32];  (*`{ENG} user defined MINE type of attachement. If not specified, 'application/octet-stream' is used (other possible values are {CSY}uûivatelsky definovan˝ MINE typ p¯Ìlohy. NenÌ-li specifikov·n, je pouûit 'application/octet-stream' (dalöÌ moûnÈ hodnoty jsou {}'image/jpeg', 'image/png', 'text/plain; charset=windows-1250',...)*)
    genMessageID     : bool;  (*`{ENG} generate unique Message-ID{CSY}vygeneruje unik·tnÌ Message-ID*)
  END_VAR
  VAR_IN_OUT
    Sender           : string [80];  (*`{ENG} sender address {CSY}adresa odesÌlatele*)
    SendName         : string [80];  (*`{ENG} sender name {CSY}jmÈno odesÌlatele*)
    Rcpt             : string [80];  (*`{ENG} recipient address {CSY}adresa p¯Ìjemce*)
    Subject          : string [80];  (*`{ENG} subject {CSY}p¯edmÏt zpr·vy*)
    Text             : string [80];  (*`{ENG} first line of email body {CSY}prvnÌ ¯·dek tÏla zpr·vy*)
    Attach           : string [80];  (*`{ENG} file name of attachement {CSY}jmÈno souboru s p¯ilohou*)
    Username         : string [80];  (*`{ENG} user name for SMTP server {CSY}uûivatelskÈ jmÈno pro SMTP server*)
    Password         : string [80];  (*`{ENG} password  for SMTP server {CSY}heslo pro SMTP server*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`true{ENG} after email was sent successfully {CSY}pokud se poda¯ilo zpr·vu odeslat*)
    Busy             : bool;  (*`true{ENG} when sending is in progress {CSY}pokud se pr·vÏ odesÌl· zpr·va*)
    Err              : bool;  (*`true{ENG} when sending failed {CSY}pokud nastala p¯i odesÌl·nÌ chyba*)
    ErrId            : usint;  (*`{ENG} number of error {CSY}ËÌslo chyby*)
    ReplyCode        : uint;  (*`{ENG} server reply code {CSY}kÛd odpovÏdi serveru*)
    State            : TSmtpState;  (*`{ENG} communication state {CSY}stav komunikace*)
  END_VAR
  VAR CONSTANT
    SMTP_BASE64_LEN_ : udint :=  57;  (*`60*)
    SMTP_BASE64_LEN2_ : udint :=  SMTP_BASE64_LEN_*2;  (*`120*)
    SMTP_MAXIMUM_FILE_LINE_LENGTH_ : udint :=  SMTP_BASE64_LEN_*3;  (*`180;*)
  END_VAR
  VAR
    timeout_cntr     : TON;  (*`detekce timeoutu pri komunikaci*)
    cmd              : string [255];
    buff             : ARRAY [0..511] OF usint;
    copy_rcpt        : string [255];
    temp_rcpt        : string [180];
    body_rcpt        : string [80];
    ptrText          : PTR_TO string [80];
    body_lines       : sint;
    Recv_from        : fbRecvTxt;  (*`FB pro prijem*)
    Send_to          : fbSendTo;  (*`FB pro vysilani*)
    h                : HANDLE;
    TRO              : bool;  (*`buffer overflow*)
    lAuth            : bool;  (*`byla pozadovana autorizace*)
    mesRec           : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE TNtpMessage {HIDDEN} :
  STRUCT
    Flags            : byte :=  2#00_011_011;  (*`|  LI1 | LI0 | VN2 | VN1 | VN0 |Mode2|Mode1|Mode0|*)
    Stratum          : usint :=  15;
    Polling          : sint :=  8;
    Precision        : sint :=  -8;
    RootDelay        : udint;
    RootDispersion   : udint;
    RefIdentifier    : udint;
    ReferenceTS      : udint;
    ReferenceTSFrac  : udint;
    OriginateTS      : udint;
    OriginateTSFrac  : udint;
    ReceiveTS        : udint;
    ReceiveTSFrac    : udint;
    TransmitTS       : udint;
    TransmitTSFrac   : udint;
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbSntp
(*`{ENU}Gets time offset from remote time server
Names of time servers groups
  {CSY}ZÌsk·v· Ëasov˝ ofset se vzd·lenÈho ËasovÈho serveru
JmÈna skupin Ëasov˝ch server˘:
  {}
  pool.ntp.org
  europe.pool.ntp.org
  cz.pool.ntp.org*)
  VAR_INPUT
    Get              : bool R_EDGE;  (*`{ENG}Get new time offset from time server {CSY}ZÌskat nov˝ Ëasov˝ ofset ze serveru*)
    Accept           : bool R_EDGE;  (*`{ENG}Accept new time from server {CSY}P¯ijmout Ëasov˝ ofset ze serveru*)
    chanCode         : uint;  (*`{ENG}UNI UDP chanel (60 bytes IN/OUT){CSY}UNI UDP kan·l (60 bytes IN/OUT)*)
    IPadr            : TIPadr;  (*`{ENG}IP address of NTP server {CSY}IP adresa NTP serveru*)
    port             : uint :=  123;  (*`{ENG}Port of NTP server {CSY}Port NTP serveru*)
    UtcOff           : int;  (*`{ENG}Offset from UTC in minutes{CSY}Posun ËasovÈho p·sma v minut·ch*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}Time offset successfully acquired {CSY}»asov˝ ofset ˙spÏönÏ zÌsk·n*)
    Busy             : bool;  (*`{ENG}Communication in progress {CSY}ProbÌha komunikace*)
    TimeSet          : bool;  (*`{ENG}New time set to RTC {CSY}Nov˝ Ëas nastaven do RTC*)
    Err              : bool;  (*`{ENG}Error during communication {CSY}Chyba bÏhem komunikace*)
    ErrId            : usint;  (*`{ENG}Number of error {CSY}»Ìslo chyby*)
    Offset           : lreal;  (*`{ENG}Acquried offset [s]{CSY}ZÌskan˝ ofset [s]*)
    Error            : lreal;  (*`{ENG}Maximum error of acquired offset [s]{CSY}MaximalnÌ chyba zÌskanÈho ofsetu [s]*)
  END_VAR
  VAR
    Recv             : bool;
    SettingTime      : bool;
    Now              : dt;
    NowLocal         : dt;
    NowTeco          : ARRAY [0..6] OF usint;
    NowMili          : uint;
    NtpPacket        : TNtpMessage;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    Attemps          : udint;
    Success          : udint;
    ShortTimeout     : TON;
    Timeout          : TON;
    maxSW22          : uint;
  END_VAR
  VAR CONSTANT
    _fbSntp_EMPTY_NTP_MESSAGE_ : TNtpMessage :=  (RootDispersion:= 0);
  END_VAR
END_FUNCTION_BLOCK

TYPE TNsLookUpItem :
  STRUCT
    Request          : bool;
    Set              : bool;
    Done             : bool;
    Err              : bool;
    IP               : TIPadr;
    Name             : string [80];
  END_STRUCT;
END_TYPE

TYPE  TNsLookUpTable : ARRAY [0..15] OF TNsLookUpItem;
END_TYPE

__DECL FUNCTION_BLOCK fbNsLookUpByTable
(*`{CSY} ZÌsk· IP adresu domÈnov˝ch jmÈn v tabulce
  {ENU} Gets IP address of the domain names in the table*)
  VAR_INPUT
    chanCode         : uint;  (*`{ENG}UNI channel {CSY}p¯enosov˝ kan·l {}UDP, lport: 0, rport: 53, in: 524, out: 93*)
    DnsIP            : TIPadr;  (*`{ENG}DNS server IP address {CSY}Adresa DNS serveru*)
  END_VAR
  VAR_IN_OUT
    NsLookUpTable    : TNsLookUpTable;  (*`{ENG}Table of domain names {CSY}Tabulka domenov˝ch jmen*)
  END_VAR
  VAR_OUTPUT
    Busy             : bool;  (*`{ENG}Communication in progress {CSY}ProbÌha komunikace*)
    Err              : bool;  (*`{ENG}Communication error {CSY}Chyba komunikace*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
  END_VAR
  VAR
    i                : uint;
    j                : uint;
    NsLookUp         : fbNsLookUp;
    NsLookUpItem     : TNsLookUpItem;
  END_VAR
END_FUNCTION_BLOCK

TYPE TFtpStoreState : 
  (fss_Init,
   fss_Idle,
   fss_OpenFile,
   fss_IpCom,
   fss_Connect,
   fss_Rx220,
   fss_TxUser,
   fss_RxUser,
   fss_TxPass,
   fss_RxPass,
   fss_TxType,
   fss_RxType,
   fss_TxPasv,
   fss_RxPasv,
   fss_TxStor,
   fss_IpDat,
   fss_WaitForOpen,
   fss_TxData,
   fss_RxComplete,
   fss_TxQuit,
   fss_RxQuit,
   fss_Close,
   fss_Error,
   fss_UnexpectedReply,
   fss_TxCreateDir,
   fss_RxCreateDir,
   fss_ReadDir,
   fss_TxRetr,
   fss_RxData,
   fss_TxSize,
   fss_RxSize 
  );
END_TYPE

VAR_GLOBAL CONSTANT
 FTP_DIR_STACK_ {HIDDEN} : usint :=  4;

END_VAR

TYPE TFtpDirStack {HIDDEN} :
  STRUCT
    hDir             : HANDLE;
    sDir             : string [12];
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbStoreToFtp
(*`{ENU}Stores files from memory card to FTP server
  {CSY}Uklad· soubory z pamÏùovÈ karty na FTP server*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*`{ENG}Sends file/directory to FTP{CSY}Odeöle soubor/adres·¯ na FTP*)
    IPadr            : TIPadr;  (*`{ENG}IP address of FTP server {CSY}IP adresa FTP serveru*)
    port             : uint :=  21;  (*`{ENG}Port of FTP server {CSY}Port FTP serveru*)
    chanCodeCom      : uint;  (*`{ENG}Channel code {CSY}P¯enosov˝ kan·l TCP Master, in: 255, out: 255*)
    chanCodeDat      : uint;  (*`{ENG}Channel code {CSY}P¯enosov˝ kan·l TCP Master, in: 1, out: 255*)
  END_VAR
  VAR_IN_OUT
    User             : string [80];  (*`{ENG}User name {CSY}UûivatelskÈ jmÈno*)
    Pass             : string [80];  (*`{ENG}Password {CSY}Heslo*)
    LocalName        : string [80];  (*`{ENG}Name of file or directory at the memory card {CSY}JmÈno souboru nebo sloûky na pamÏùovÈ kartÏ*)
    RemotName        : string [80];  (*`{ENG}Name of file or directory at FTP server {CSY}JmÈno souboru nebo sloûky na FTP serveru*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}File was stored to FTP server {CSY}Soubor byl uloûen na FTP server*)
    Busy             : bool;  (*`{ENG}File is storing to FTP server {CSY}Soubor se ukl·d· na FTP server*)
    Err              : bool;  (*`{ENG}Error occured {CSY}Nastala chyba*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
    ReplyCode        : uint;  (*`{ENG}Reply code {CSY}KÛd odpovÏdi serveru*)
    State            : TFtpStoreState;  (*`{ENG}State of communication {CSY}Stav komunikace*)
    CurrFile         : string [80];  (*`{ENG}Name of currently uploaded file{CSY}JmÈno aktu·lnÏ nahr·vanÈho souboru*)
    Progress         : usint;  (*`{ENG}Progress of file uploading in percent {CSY}Pr˘bÏh nahr·v·nÌ souboru v procentech*)
  END_VAR
  VAR
    Send_To_Com      : fbSendTo;
    Recv_From_Com    : fbRecvFrom;
    KeepAliveTCP     : fbKeepAliveTCP;
    rea              : TRemoteEthAdr;
    cmdCom           : string [255];
    lRemotName       : string [80];
    lLocalFileInfo   : TFileInfo;
    idPos            : udint;
    lSize            : udint;
    lTrans           : udint;
    dirStack         : ARRAY [0..4] OF TFtpDirStack;
    dirStackLev      : usint;
    i                : usint;
    eErrId           : usint;
    Send_To_Dat      : fbSendTo;
    cmdDat           : ARRAY [0..254] OF usint;
    timeoutCom       : TON;
    data             : udint;
    h                : HANDLE :=  INVALID_HANDLE_VALUE;
    pasvDat          : ARRAY [0..5] OF usint;
    TRO              : bool;
    mesRec           : bool;
    iniDir           : bool;
    endDir           : bool;
    TRO_com          : bool;
    TRO_dat          : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE  THttpPostData : ARRAY [0..1535] OF usint;
END_TYPE

__DECL FUNCTION_BLOCK fbHttpRequestL
(*`{ENU}Sends POST and GET metods via HTTP
{CSY}VysÌl· metody GET a POST p¯es HTTP protokol*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*`{ENG}Send data via method POST {CSY}vyslat data metodou POST*)
    Get              : bool R_EDGE;  (*`{ENG}Get data via method GET {CSY}zÌskat data metodu GET*)
    Cancel           : bool R_EDGE;  (*`{ENG}Cancel pending operation {CSY}zruöit probÌhajÌcÌ operaci*)
    chanCode         : uint;  (*`{ENG}UNI channel {CSY}p¯enosov˝ kan·l {}TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*`{ENG}IP address of remote server {CSY}IP adresa vzd·leneho serveru*)
    port             : uint :=  80;  (*`{ENG}Port of remote server {CSY}»Ìslo portu vzd·lenÈho serveru*)
    postLen          : uint;  (*`{ENG}Lenght of data to POST{CSY}DÈlka dat pro metodu POST*)
    Close            : bool;  (*`{ENG}If set, block don't wait for server to close connection and close it actively after receiving all data{CSY}Pokud je nastaveno, blok neËek· na server aû zav¯e spojenÌ a zav¯e jej aktivnÏ jakmile zÌsk· vöechny data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*`{ENG}Path to the data on the server (always starts with character '/') {CSY}Cesta k dat˘m na serveru (vûdy zaËÌn· znakem '/')*)
    Host             : string [80];  (*`{ENG}Host name {CSY}JmÈno hostitele*)
    Data             : THttpPostData;  (*`{ENG}First byte of data to POST {CSY}PrvnÌ byte dat pro metodu POST*)
    RecvData         : THttpBuffer;  (*`{ENG}Data buffer 512 bytes {CSY}Bufer dat 512 byt˘*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}Operation done {CSY}Operace ukonËena*)
    Busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌha*)
    Err              : bool;  (*`{ENG}Communication error {CSY}Chyba komunikace*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
    DataReady        : bool;  (*`{ENG}New data received {CSY}P¯ijata nov· data*)
    DataLen          : uint;  (*`{ENG}Data length {CSY}DÈlka dat*)
    State            : THttpState;  (*`{ENG}State of communication {CSY}Stav komunikace*)
    Result           : int;  (*`{ENG}HTTP Code {CSY}HTTP kod*)
    Progress         : sint;  (*`{ENG}Progress of data downloading {CSY}Pr˘bÏh stahov·nÌ dat*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    WasEOL           : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lPostLen         : uint;
    lHost            : string [80];
    BodyLen          : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbHttpRequestL2
(*`{ENU}Sends POST and GET metods via HTTP with option to set content type (Content-Type)
{CSY}VysÌl· metody GET a POST p¯es HTTP protokol s moûnostÌ definice typu obsahu (Content-Type)*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*`{ENG}Send data via method POST {CSY}vyslat data metodou POST*)
    Get              : bool R_EDGE;  (*`{ENG}Get data via method GET {CSY}zÌskat data metodu GET*)
    Cancel           : bool R_EDGE;  (*`{ENG}Cancel pending operation {CSY}zruöit probÌhajÌcÌ operaci*)
    chanCode         : uint;  (*`{ENG}UNI channel {CSY}p¯enosov˝ kan·l {}TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*`{ENG}IP address of remote server {CSY}IP adresa vzd·leneho serveru*)
    port             : uint :=  80;  (*`{ENG}Port of remote server {CSY}»Ìslo portu vzd·lenÈho serveru*)
    postLen          : uint;  (*`{ENG}Lenght of data to POST{CSY}DÈlka dat pro metodu POST*)
    Close            : bool;  (*`{ENG}If set, block don't wait for server to close connection and close it actively after receiving all data{CSY}Pokud je nastaveno, blok neËek· na server aû zav¯e spojenÌ a zav¯e jej aktivnÏ jakmile zÌsk· vöechny data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*`{ENG}Path to the data on the server (always starts with character '/') {CSY}Cesta k dat˘m na serveru (vûdy zaËÌn· znakem '/')*)
    Host             : string [80];  (*`{ENG}Host name {CSY}JmÈno hostitele*)
    Data             : THttpPostData;  (*`{ENG}First byte of data to POST {CSY}PrvnÌ byte dat pro metodu POST*)
    ContentType      : string [80];  (*`{ENG}Content-Type {CSY}Typ obsahu (Content-Type)*)
    RecvData         : THttpBuffer;  (*`{ENG}Data buffer 512 bytes {CSY}Bufer dat 512 byt˘*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}Operation done {CSY}Operace ukonËena*)
    Busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌha*)
    Err              : bool;  (*`{ENG}Communication error {CSY}Chyba komunikace*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
    DataReady        : bool;  (*`{ENG}New data received {CSY}P¯ijata nov· data*)
    DataLen          : uint;  (*`{ENG}Data length {CSY}DÈlka dat*)
    State            : THttpState;  (*`{ENG}State of communication {CSY}Stav komunikace*)
    Result           : int;  (*`{ENG}HTTP Code {CSY}HTTP kod*)
    Progress         : sint;  (*`{ENG}Progress of data downloading {CSY}Pr˘bÏh stahov·nÌ dat*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    WasEOL           : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lPostLen         : uint;
    lHost            : string [80];
    BodyLen          : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSplitUrlAddress
(*`{CSY}FunkËnÌ blok fbSplitUrlAddress rozebÌr· zadanou URL adresu na jednotlivÈ poloûky vyûadovanÈ bloky fbHttpRequest, fbHttpRequestL a fbHttpRequestL2.
  Vstupem bloku je promÏnn· p¯edan· p¯es urlAddress, kter· nese URL adresu tak jak je uvedena ve webovÈm prohlÌûeËi.
  {ENG}
  Function block fbSplitUrlAddress splits specified URL address to items required by blocks fbHttpRequest, fbHttpRequestL and fbHttpRequestL2.
  Input of the block is a variable, that carries a URL as it appears in the web browser, passed through urlAddress.*)
  VAR_INPUT
    split            : bool R_EDGE;  (*`{ENU}Split URL address{CSY} RozdÏlenÌ URL adresy*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{ENG}URL address splitted and IP address successfully obtained {CSY}URL adresa rozdÏlena a IP adresa ˙spÏönÏ zÌsk·na*)
    busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌh·*)
    err              : bool;  (*`{ENG}Error occured {CSY}Nastala chyba*)
    errId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
  END_VAR
  VAR_IN_OUT
    urlAddress       : string [255];  (*`{ENG}URL as it appears in a web browser{CSY}URL adresa tak jak je uvedena ve webovÈm prohlÌûeËi*)
    host             : string [80];  (*`{ENG}Host name {CSY}JmÈno hostitele*)
    action           : string [80];  (*`{ENG}Path to the data on the server (always starts with character '/') {CSY}Cesta k dat˘m na serveru (vûdy zaËÌn· znakem '/')*)
    ipAdr            : TIPadr;  (*`{ENG}IP address of remote server {CSY}IP adresa vzd·lenÈho serveru*)
    port             : uint;  (*`{ENG}Port of remote server {CSY}»Ìslo portu vzd·lenÈho serveru*)
  END_VAR
  VAR
    NsLookUp         : fbNsLookUpEx;
  END_VAR
  VAR CONSTANT
    HTTP_IP_NULL     : TIPadr :=  [0,0,0,0];
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRetriveFromFtp
(*`{ENU}Retrive file from FTP server and saves it to memory card
  {CSY}ZÌsk·v· soubor z FTP serveru a ukl·d· na pamÏùovou kartu*)
  VAR_INPUT
    Retrieve         : bool R_EDGE;  (*`{ENG}Retrieves file from FTP{CSY}P¯Ìjmout soubor z FTP*)
    IPadr            : TIPadr;  (*`{ENG}IP address of FTP server {CSY}IP adresa FTP serveru*)
    port             : uint :=  21;  (*`{ENG}Port of FTP server {CSY}Port FTP serveru*)
    chanCodeCom      : uint;  (*`{ENG}Channel code {CSY}P¯enosov˝ kan·l TCP Master, in: 255, out: 255*)
    chanCodeDat      : uint;  (*`{ENG}Channel code {CSY}P¯enosov˝ kan·l TCP Master, in: 255, out: 1*)
  END_VAR
  VAR_IN_OUT
    User             : string [80];  (*`{ENG}User name {CSY}UûivatelskÈ jmÈno*)
    Pass             : string [80];  (*`{ENG}Password {CSY}Heslo*)
    LocalName        : string [80];  (*`{ENG}Name of file at the memory card {CSY}JmÈno souboru na pamÏùovÈ kartÏ*)
    RemotName        : string [80];  (*`{ENG}Name of file at FTP server {CSY}JmÈno souboru na FTP serveru*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}File was stored to memory card {CSY}Soubor byl uloûen na pamÏùovou kartu*)
    Busy             : bool;  (*`{ENG}File is being stored to memory card {CSY}Soubor se ukl·d· na pamÏùovou kartu*)
    Err              : bool;  (*`{ENG}Error occured {CSY}Nastala chyba*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
    ReplyCode        : uint;  (*`{ENG}Reply code {CSY}KÛd odpovÏdi serveru*)
    State            : TFtpStoreState;  (*`{ENG}State of communication {CSY}Stav komunikace*)
    Progress         : usint;  (*`{ENG}Progress of file uploading in percent {CSY}Pr˘bÏh nahr·v·nÌ souboru v procentech*)
  END_VAR
  VAR
    Send_To_Com      : fbSendTo;
    Recv_From_Com    : fbRecvTxt;  (*`fbRecvFrom;*)
    KeepAliveTCP     : fbKeepAliveTCP;
    rea              : TRemoteEthAdr;
    cmdCom           : string [255];
    lRemotName       : string [80];
    lLocalFileInfo   : TFileInfo;
    idPos            : udint;
    lSize            : udint;
    lTrans           : udint;
    i                : usint;
    eErrId           : usint;
    Recv_From_Dat    : fbRecvFrom;
    WTFS             : WriteToFileSeq;
    cmdBuffer        : ARRAY [0..254] OF usint;
    cmdDat           : ARRAY [0..254] OF usint;
    timeoutCom       : TON;
    data             : udint;
    h                : HANDLE :=  INVALID_HANDLE_VALUE;
    pasvDat          : ARRAY [0..5] OF usint;
    TRO              : bool;
    mesRec           : bool;
    TRO_com          : bool;
    TRO_dat          : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE T_PING_INFO :
  STRUCT
    result           : dint;  (*`{ENG}result 0=busy, 1=done without errors, -1=error {CSY}0=probÌh·, 1=dokonËeno bez chyb, -1=chyba*)
    hostIP           : TIPadr;  (*`{ENG}host IP                     {CSY}IP adresa hostitele*)
    responseTime     : time;  (*`{ENG}response time               {CSY}Ëas odezvy*)
    pingNumber       : udint;  (*`{ENG}ping number                 {CSY}ËÌslo pingu*)
    dataLen          : udint;  (*`{ENG}length of data              {CSY}dÈlka dat*)
    ttl              : usint;  (*`{ENG}response TTL                {CSY}TTL odpovÏdi*)
    errMsg           : string [80];  (*`{ENG}error message               {CSY}chybov· zpr·va*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbPingIP
(*`{CSY} OvÏ¯Ì spojenÌ mezi PLC a sÌùov˝m rozhranÌm s danou IP adresou
  {ENU} Check the connection between the PLC and the network interface with given IP address*)
  VAR_INPUT
    rqPing           : bool R_EDGE;  (*`{ENG} Ping request   {CSY} é·dost o odesl·nÌ Ping*)
    hostIP           : TIPadr;  (*`{ENG} Host IP        {CSY} IP adresa hostitele*)
    ttl              : usint;  (*`{ENG} Time to live - TTL{CSY} éivotnost paketu TTL*)
    timeLimit        : time;  (*`{ENG} Time limit for reply{CSY} »asov˝ limit pro odpovÏÔ*)
    dataLen          : uint;  (*`{ENG} Length of data {CSY} DÈlka dat*)
  END_VAR
  VAR_IN_OUT
    pingInfo         : T_PING_INFO;  (*`{ENG} Ping information       {CSY} Informace o Pingu*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{ENG} Operation successfully completed {CSY} Operace byla ˙spÏönÏ dokonËena*)
    busy             : bool;  (*`{ENG} Operation pending      {CSY} Operace probÌh·*)
    err              : bool;  (*`{ENG} Error occured          {CSY} Nastala chyba*)
  END_VAR
  VAR
    timeout          : TON;
    waitArp          : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbPing
(*`{CSY} OvÏ¯Ì spojenÌ mezi PLC a hostitelem danÈho jmÈna
  {ENU} Check the connection between the PLC and the host of given name*)
  VAR_INPUT
    rqPing           : bool R_EDGE;  (*`{ENG} Ping request  {CSY} é·dost o odesl·nÌ Ping*)
    hostName         : string [80];  (*`{ENG} Host name     {CSY} JmÈno hostitele*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{ENG} Operation successfully completed {CSY} Operace byla ˙spÏönÏ dokonËena*)
    busy             : bool;  (*`{ENG} Operation pending                {CSY} Operace probÌh·*)
    err              : bool;  (*`{ENG} Error occured                    {CSY} Nastala chyba*)
    pingInfo         : T_PING_INFO;  (*`{ENG} Ping information                 {CSY} Informace o Pingu*)
  END_VAR
  VAR
    rqSplit          : bool;
    SplitUrlAdr      : fbSplitUrlAddress;
    PingIP           : fbPingIP;
    host             : string [80];  (*`JmÈno hostitele*)
    action           : string [80];  (*`Poûadovan· str·nka nap¯Ìklad "/index.xml"*)
    ipAdr            : TIPadr;  (*`IP adresa vzd·leneho serveru*)
    port             : uint;  (*`»Ìslo portu vzd·lenÈho serveru*)
  END_VAR
END_FUNCTION_BLOCK



{USES=fbNsLookUp:GetChanDesc,SetRemoteIPaddress,_internetlib_DnsCodeDomainName,_internetlib_DnsLenOfDomainName}
{USES=fbHttpRequest:GetChanDesc,CloseTCPconnection,MemcpyPtr,Base64_encode_string,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection}
{USES=fbSmtp:GetChanDesc,FileClose,CloseTCPconnection,SetRemoteIPaddress,EstabTCPconnection,Base64_encode_string,GetDateAndTime_RFC2822,GetMACaddress,GetRTC,DT_TO_STRINGF,FileOpen,FileRead,Base64_encode_ptr_string,IsEstabTCPconnection}
{USES=fbSntp:GetChanDesc,SetRemoteIPaddress}
{USES=fbStoreToFtp:GetChanDesc,CloseTCPconnection,FileClose,DirClose,_FindNextPathSeparator,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection,FileOpen,FileSize,DirOpen,DirRead,FileRead}
{USES=fbHttpRequestL:GetChanDesc,CloseTCPconnection,MemcpyPtr,Base64_encode_string,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection}
{USES=fbHttpRequestL2:GetChanDesc,CloseTCPconnection,MemcpyPtr,Base64_encode_string,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection}
{USES=fbSplitUrlAddress:STRING_TO_IPADR,GetDNS_IP}
{USES=fbRetriveFromFtp:GetChanDesc,CloseTCPconnection,FileClose,_FindNextPathSeparator,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection}
{USES=fbPingIP:CheckGatewayIP}
{USES=fbPing:Memset,CheckGatewayIP}
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\GLOBAL.ST'


 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\_FINDNEXTPATHSEPARATOR.ST'
#pou _FindNextPathSeparator
#srcline 1 ;FUNCTION _FindNextPathSeparator {$IFNDEF _DEBUG} {HIDDEN} {$END_IF} : BOOL

#struct _FindNextPathSeparator__temp__
  pointer p
P     61
_FindNextPathSeparator_L0:
 LINK __SizeOf(_FindNextPathSeparator__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc___FindNextPathSeparator
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  p
; End initialize - dynamic variables
#srcline 14 ;  Pos := Pos + 1;
 LDX  Pos
 LDIL 
#debug udint Pos
 LD   udint 1
 ADD
 LDX  Pos
 WRIL 
#debug_left udint Pos
#srcline 16 ;  p := ADR(In) + Pos - 1;
 LDX  In
#debug pointer In
 LDX  Pos
 LDIL 
#debug udint Pos
 ADD
 LD   udint 1
 SUB
 LEAY p
 WRIL 
#debug_left pointer p
#srcline 17 ;  
#srcline 18 ;  WHILE p^ <> 47 AND p^ <> 0 DO
_FindNextPathSeparator_L1:
 LEAY p
 LDIL    ; dereference 
 LDI  
#debug usint p^
 LD   usint 47
 EQ
 NEG
 LEAY p
 LDIL    ; dereference 
 LDI  
#debug usint p^
 LD   usint 0
 EQ
 NEG
 AND
 JMC  _FindNextPathSeparator_L2
 DBG 
#srcline 19 ;    Pos := Pos + 1;
 LDX  Pos
 LDIL 
#debug udint Pos
 LD   udint 1
 ADD
 LDX  Pos
 WRIL 
#debug_left udint Pos
#srcline 20 ;    p   := p + 1;
 LEAY p
 LDIL 
#debug pointer p
 LD   udint 1
 ADD
 LEAY p
 WRIL 
#debug_left pointer p
#srcline 21 ;  END_WHILE;
 JMP  _FindNextPathSeparator_L1
_FindNextPathSeparator_L2:
 NOP  -1
#srcline 22 ;  
#srcline 23 ;  IF p^ <> 0 THEN
 LEAY p
 LDIL    ; dereference 
 LDI  
#debug usint p^
 LD   usint 0
 EQ
 NEG
 JMC  _FindNextPathSeparator_L3
#srcline 24 ;    _FindNextPathSeparator := true;
 LD   bool -1       ; true
 WRX  __fc___FindNextPathSeparator
#debug_left bool _FindNextPathSeparator
#srcline 25 ;  ELSE
 JMP  _FindNextPathSeparator_L4
_FindNextPathSeparator_L3:
#srcline 26 ;    _FindNextPathSeparator := false;
 LD   bool 0       ; false
 WRX  __fc___FindNextPathSeparator
#debug_left bool _FindNextPathSeparator
#srcline 27 ;    Pos := 0;
 LD   udint 0
 LDX  Pos
 WRIL 
#debug_left udint Pos
#srcline 28 ;  END_IF;
_FindNextPathSeparator_L4:
#srcline 29 ;  
#srcline 30 ;END_FUNCTION
 PRV  
 LDX  __fc___FindNextPathSeparator
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBNSLOOKUP.ST'
#pou _internetlib_DnsLenOfDomainName
#srcline 72 ;FUNCTION _internetlib_DnsLenOfDomainName {HIDDEN} : UDINT

#struct _internetlib_DnsLenOfDomainName__temp__
  pointer BG,
  udint VAL
P     61
_internetlib_DnsLenOfDomainName_L0:
 LINK __SizeOf(_internetlib_DnsLenOfDomainName__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc___internetlib_DnsLenOfDomainName
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  BG
; End initialize - dynamic variables
#srcline 83 ;  IF IN^ = 16#C0 THEN //pointer
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   usint $C0
 EQ
 JMC  _internetlib_DnsLenOfDomainName_L1
#srcline 84 ;    _internetlib_dnsLenOfDomainName := 2;
 LD   udint 2
 WRX  __fc___internetlib_dnsLenOfDomainName
#debug_left udint _internetlib_dnsLenOfDomainName
#srcline 85 ;  ELSE
 JMP  _internetlib_DnsLenOfDomainName_L2
_internetlib_DnsLenOfDomainName_L1:
#srcline 86 ;    BG := IN;
 LEAX IN
 LDIL 
#debug pointer IN
 LEAY BG
 WRIL 
#debug_left pointer BG
#srcline 88 ;    WHILE IN^ > 0 DO
_internetlib_DnsLenOfDomainName_L3:
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   usint 0
 GT
 JMC  _internetlib_DnsLenOfDomainName_L4
 DBG 
#srcline 89 ;      VAL := USINT_TO_UDINT(IN^)+1;
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   udint 1
 ADD
 WRY  VAL
#debug_left udint VAL
#srcline 90 ;      IN := IN + VAL;
 LEAX IN
 LDIL 
#debug pointer IN
 LDY  VAL
#debug udint VAL
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 91 ;    END_WHILE;
 JMP  _internetlib_DnsLenOfDomainName_L3
_internetlib_DnsLenOfDomainName_L4:
 NOP  -1
#srcline 93 ;    _internetlib_dnsLenOfDomainName := PTR_TO_UDINT(IN) - PTR_TO_UDINT(BG) + 1;
 LEAX IN
 LDIL 
#debug pointer IN
 LEAY BG
 LDIL 
#debug pointer BG
 SUB
 LD   udint 1
 ADD
 WRX  __fc___internetlib_dnsLenOfDomainName
#debug_left udint _internetlib_dnsLenOfDomainName
#srcline 94 ;  END_IF;
_internetlib_DnsLenOfDomainName_L2:
#srcline 95 ;END_FUNCTION
 PRV  
 LDX  __fc___internetlib_DnsLenOfDomainName
 ULNK
RET
E     61
#endpou 

#pou _internetlib_DnsCodeDomainName
#srcline 98 ;FUNCTION _internetlib_DnsCodeDomainName {HIDDEN} : STRING[80]

#struct _internetlib_DnsCodeDomainName__temp__
  pointer pUsint1,
  pointer pString,
  string[82] PS0__st__
#data byte _str__internetlib_DnsCodeDomainName_0 = 
  '.',0
#data byte _str__internetlib_DnsCodeDomainName_1 = 
  '.',0
P     61
_internetlib_DnsCodeDomainName_L0:
 LINK __SizeOf(_internetlib_DnsCodeDomainName__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc___internetlib_DnsCodeDomainName
 WRX  I
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint1
 LD   udint $FFFFFFFF    ; nil
 WRY  pString
; End initialize - dynamic variables
#srcline 114 ;  _internetlib_dnsCodeDomainName := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX __fc___internetlib_dnsCodeDomainName
 WRI  
 LEAX __fc___internetlib_dnsCodeDomainName
 LD   80
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string _internetlib_dnsCodeDomainName
 PDST   ; Level 1
#srcline 116 ;  pUsint1  := ADR(IN)-81;
 LEAX IN
#debug pointer IN
 LD   udint 81
 SUB
 LEAY pUsint1
 WRIL 
#debug_left pointer pUsint1
#srcline 117 ;  pString  := pUsint1 + 1;
 LEAY pUsint1
 LDIL 
#debug pointer pUsint1
 LD   udint 1
 ADD
 LEAY pString
 WRIL 
#debug_left pointer pString
#srcline 118 ;  pString^ := IN + '.';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX IN
#debug string IN
 SCON 
 LEA  _str__internetlib_DnsCodeDomainName_0
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY pString
 LDIL    ; dereference 
 WRI  
 LEAY pString
 LDIL    ; dereference 
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string pString^
 PDST   ; Level 1
#srcline 120 ;  REPEAT
_internetlib_DnsCodeDomainName_L1:
 DBG
#srcline 121 ;   I := FIND(pString^, '.');
 LEAY pString
 LDIL    ; dereference 
#debug string pString^
 LEA  _str__internetlib_DnsCodeDomainName_1
 SFND 
 WRX  I
#debug_left int I
#srcline 122 ;   pUsint1^ := MAX(1,INT_TO_USINT(I))-1;
 LD   usint 1
 LDX  I
#debug int I
 EXTW 
 AND  $FF
 MAX
 LD   usint 1
 SUB
 AND  $FF
 LEAY pUsint1
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint1^
#srcline 123 ;   pUsint1  := pUsint1 + INT_TO_UDINT(I);
 LEAY pUsint1
 LDIL 
#debug pointer pUsint1
 LDX  I
#debug int I
 EXTW 
 ADD
 LEAY pUsint1
 WRIL 
#debug_left pointer pUsint1
#srcline 124 ;   pString  := pUsint1 + 1;
 LEAY pUsint1
 LDIL 
#debug pointer pUsint1
 LD   udint 1
 ADD
 LEAY pString
 WRIL 
#debug_left pointer pString
#srcline 125 ;  UNTIL I = 0 END_REPEAT;
 LDX  I
#debug int I
 EXTW 
 LD   int 0
 EQ
 JMC  _internetlib_DnsCodeDomainName_L1
_internetlib_DnsCodeDomainName_L2:
 NOP  -1
#srcline 127 ;END_FUNCTION
 PRV  
 LEAX  __fc___internetlib_DnsCodeDomainName
 ULNK
RET
E     61
#endpou 

#pou _internetlib_DnsDecodeDomainName
#srcline 129 ;FUNCTION _internetlib_DnsDecodeDomainName {HIDDEN} : STRING[80]

#struct _internetlib_DnsDecodeDomainName__temp__
  bool FIRST,
  udint VAL,
  pointer pUsint1,
  string[82] PS0__st__
P     61
_internetlib_DnsDecodeDomainName_L0:
 LINK __SizeOf(_internetlib_DnsDecodeDomainName__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc___internetlib_DnsDecodeDomainName
; End initialize - variables
; Initialize - dynamic variables
 LD   bool -1   ; true
 WRY  FIRST
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint1
; End initialize - dynamic variables
#srcline 146 ;  _internetlib_dnsDecodeDomainName := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX __fc___internetlib_dnsDecodeDomainName
 WRI  
 LEAX __fc___internetlib_dnsDecodeDomainName
 LD   80
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string _internetlib_dnsDecodeDomainName
 PDST   ; Level 1
#srcline 148 ;  pUsint1 := ADR(IN)-81;
 LEAX IN
#debug pointer IN
 LD   udint 81
 SUB
 LEAY pUsint1
 WRIL 
#debug_left pointer pUsint1
#srcline 150 ;  WHILE IN^ > 0 DO
_internetlib_DnsDecodeDomainName_L1:
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   usint 0
 GT
 JMC  _internetlib_DnsDecodeDomainName_L2
 DBG 
#srcline 151 ;    IF IN^ = 16#C0 THEN //pointer
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   usint $C0
 EQ
 JMC  _internetlib_DnsDecodeDomainName_L3
#srcline 152 ;      IN := IN + 1;
 LEAX IN
 LDIL 
#debug pointer IN
 LD   udint 1
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 153 ;      VAL := USINT_TO_UDINT(IN^);
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 WRY  VAL
#debug_left udint VAL
#srcline 154 ;      IN := BG + VAL;
 LEAX BG
 LDIL 
#debug pointer BG
 LDY  VAL
#debug udint VAL
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 155 ;    ELSE
 JMP  _internetlib_DnsDecodeDomainName_L4
_internetlib_DnsDecodeDomainName_L3:
#srcline 156 ;      VAL := USINT_TO_UDINT(IN^)+1;
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   udint 1
 ADD
 WRY  VAL
#debug_left udint VAL
#srcline 157 ;      pUsint1^ := 16#2E;
 LD   usint $2E
 LEAY pUsint1
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint1^
#srcline 158 ;      IF FIRST THEN
 LDY  FIRST
#debug bool FIRST
 JMC  _internetlib_DnsDecodeDomainName_L5
#srcline 159 ;        pUsint1 := pUsint1-1;
 LEAY pUsint1
 LDIL 
#debug pointer pUsint1
 LD   udint 1
 SUB
 LEAY pUsint1
 WRIL 
#debug_left pointer pUsint1
#srcline 160 ;        FIRST := false;
 LD   bool 0       ; false
 WRY  FIRST
#debug_left bool FIRST
#srcline 161 ;      END_IF;
_internetlib_DnsDecodeDomainName_L5:
#srcline 162 ;      WHILE VAL > 0 DO
_internetlib_DnsDecodeDomainName_L7:
 LDY  VAL
#debug udint VAL
 LD   udint 0
 GT
 JMC  _internetlib_DnsDecodeDomainName_L8
 DBG 
#srcline 163 ;        IN := IN + 1;
 LEAX IN
 LDIL 
#debug pointer IN
 LD   udint 1
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 164 ;        pUsint1 := pUsint1+1;
 LEAY pUsint1
 LDIL 
#debug pointer pUsint1
 LD   udint 1
 ADD
 LEAY pUsint1
 WRIL 
#debug_left pointer pUsint1
#srcline 165 ;        pUsint1^ := IN^;
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LEAY pUsint1
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint1^
#srcline 166 ;        VAL := VAL - 1;
 LDY  VAL
#debug udint VAL
 LD   udint 1
 SUB
 WRY  VAL
#debug_left udint VAL
#srcline 167 ;      END_WHILE;
 JMP  _internetlib_DnsDecodeDomainName_L7
_internetlib_DnsDecodeDomainName_L8:
 NOP  -1
#srcline 168 ;    END_IF;
_internetlib_DnsDecodeDomainName_L4:
#srcline 169 ;  END_WHILE;
 JMP  _internetlib_DnsDecodeDomainName_L1
_internetlib_DnsDecodeDomainName_L2:
 NOP  -1
#srcline 170 ;  pUsint1^ := 0;
 LD   usint 0
 LEAY pUsint1
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint1^
#srcline 171 ;END_FUNCTION
 PRV  
 LEAX  __fc___internetlib_DnsDecodeDomainName
 ULNK
RET
E     61
#endpou 

#pou fbNsLookUp
#srcline 173 ;FUNCTION_BLOCK fbNsLookUp

#struct fbNsLookUp__temp__
  bool b,
  udint l,
  uint offset,
  pointer pWord,
  uint Answers,
  uint val,
  usint replycode,
  TRemoteEthAdr dnsEthAdr,
  TUniDesc UniDesc,
  string[82] PS0__st__,
  string[82] PS1__st__
P     61
fbNsLookUp_L0:
 LINK __SizeOf(fbNsLookUp__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pWord
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  getIP
 LETX __EDGE_R__getIP
 WRX  getIP
#srcline 216 ;  Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 218 ;  UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 220 ;  IF (UniDesc.modeChan <> 5) OR UniDesc.lenUniIn < SIZEOF(TDnsReply)+4 OR UniDesc.lenUniOut < SIZEOF(TDnsQuery)+4 THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   524  ; SizeOf()
 LD   uint 4
 ADD
 AND  $FFFF
 LT
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   93  ; SizeOf()
 LD   uint 4
 ADD
 AND  $FFFF
 LT
 OR  
 JMC  fbNsLookUp_L1
#srcline 221 ;    Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 222 ;    ErrId  := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 223 ;    RETURN;
 JMP  fbNsLookUp_RET
#srcline 224 ;  END_IF;
fbNsLookUp_L1:
#srcline 227 ;  IF getIP & NOT Busy OR timeout2.Q THEN
 LDX  getIP
#debug bool getIP
 LDX  Busy
#debug bool Busy
 NEG
 AND
 LDX  timeout2~Q
#debug bool timeout2.Q
 OR  
 JMC  fbNsLookUp_L3
#srcline 228 ;    IF DnsIP = Any_IP THEN
 LEAX DnsIP
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbNsLookUp_L5
#srcline 229 ;      Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 230 ;      ErrId := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 231 ;      RETURN;
 JMP  fbNsLookUp_RET
#srcline 232 ;    END_IF;
fbNsLookUp_L5:
#srcline 233 ;    timeout2.IN := getIP;
 LDX  getIP
#debug bool getIP
 WRX  timeout2~IN
#debug_left bool timeout2.IN
#srcline 234 ;    ErrId := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 235 ;    Busy   := true;
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 236 ;    Err    := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 237 ;    //set socket
#srcline 238 ;    dnsEthAdr.remoteIP   := DnsIP;
 LEAX DnsIP
#debug pointer DnsIP
 SRC  %IB0
 LEAY dnsEthAdr~remoteIP
#debug_left pointer dnsEthAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 239 ;    dnsEthAdr.remotePort := 53;
 LD   uint 53
 WRY  dnsEthAdr~remotePort
#debug_left uint dnsEthAdr.remotePort
#srcline 240 ;    dnsEthAdr.localPort  := 0;
 LD   uint 0
 WRY  dnsEthAdr~localPort
#debug_left uint dnsEthAdr.localPort
#srcline 241 ;    b := SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := dnsEthAdr);
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY dnsEthAdr
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 WRY  b
#debug_left bool b
#srcline 242 ;    //prepare query
#srcline 243 ;    TransID := TransID + 1;
 LDX  TransID
#debug uint TransID
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  TransID
#debug_left uint TransID
#srcline 244 ;    netDnsQuery.Header.TransactionID := WORD_TO_UINT(SHL(UINT_TO_WORD(TransID),8) OR SHR(UINT_TO_WORD(TransID),8));
 LDX  TransID
#debug uint TransID
 LD   uint 8
 SHL
 AND  $FFFF
 LDX  TransID
#debug uint TransID
 LD   uint 8
 SHR
 AND  $FFFF
 OR  
 WRX  netDnsQuery~Header~TransactionID
#debug_left uint netDnsQuery.Header.TransactionID
#srcline 245 ;    netDnsQuery.Header.Question      := 16#0100;
 LD   uint $0100
 WRX  netDnsQuery~Header~Question
#debug_left uint netDnsQuery.Header.Question
#srcline 246 ;    netDnsQuery.Header.NonAutheticated := 1;
 LD   bool -1      ; true
 WRX  netDnsQuery~Header~NonAutheticated
#debug_left bool netDnsQuery.Header.NonAutheticated
#srcline 247 ;    netDnsQuery.Header.Recursion_des := 1;
 LD   bool -1      ; true
 WRX  netDnsQuery~Header~Recursion_des
#debug_left bool netDnsQuery.Header.Recursion_des
#srcline 248 ;    netDnsQuery.QueryString := _internetlib_dnsCodeDomainName(Name);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance___internetlib_DnsCodeDomainName~IN
 WRI 
 LEA  __Instance___internetlib_DnsCodeDomainName~IN
 LD   80
 DST    ; Level 2
 LDX  Name
#debug string Name
 SCON 
#debug_left string __Instance___internetlib_DnsCodeDomainName~IN
 PDST   ; Level 2
 PRV
 LEA  __Instance___internetlib_DnsCodeDomainName
 CAL  _internetlib_DnsCodeDomainName_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX netDnsQuery
 ADD  12  ; + offset 
 WRI  
 LEAX netDnsQuery
 ADD  12  ; + offset 
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string netDnsQuery.QueryString
 PDST   ; Level 1
#srcline 249 ;    l := _internetlib_dnsLenOfDomainName(IN := ADR(netDnsQuery.QueryString));
 NXT
 LEAX netDnsQuery
 ADD  12  ; + offset 
#debug pointer netDnsQuery.QueryString
 LEA  __Instance___internetlib_DnsLenOfDomainName~IN
 WRIL 
#debug_left udint __Instance___internetlib_DnsLenOfDomainName~IN
 PRV
 LEA  __Instance___internetlib_DnsLenOfDomainName
 CAL  _internetlib_DnsLenOfDomainName_L0
 WRY  l
#debug_left udint l
#srcline 250 ;    pWord := ADR(netDnsQuery.QueryString) + l;
 LEAX netDnsQuery
 ADD  12  ; + offset 
#debug pointer netDnsQuery.QueryString
 LDY  l
#debug udint l
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 251 ;    pWord^ := 16#0100;
 LD   uint $0100
 LEAY pWord
 LDIL    ; dereference 
 WRIW 
#debug_left uint pWord^
#srcline 252 ;    pWord := pWord + 2;
 LEAY pWord
 LDIL 
#debug pointer pWord
 LD   udint 2
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 253 ;    pWord^ := 16#0100;
 LD   uint $0100
 LEAY pWord
 LDIL    ; dereference 
 WRIW 
#debug_left uint pWord^
#srcline 254 ;    
#srcline 255 ;    //send query
#srcline 256 ;    SendTo(rq := 1, chanCode := chanCode,
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
#srcline 257 ;           lenTx := UDINT_TO_UINT(SIZEOF(TDnsQueryHeader)+4+l),
 LD   12  ; SizeOf()
 LD   udint 4
 ADD
 LDY  l
#debug udint l
 ADD
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
#srcline 258 ;           data := void(netDnsQuery));
 LEAX netDnsQuery
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 259 ;  END_IF;
fbNsLookUp_L3:
#srcline 261 ;  timeout(IN := Busy, PT := T#15s);
 LDX  Busy
#debug bool Busy
 WRX  timeout~IN
#debug_left bool timeout~IN
 LD   time 15000
 WRX  timeout~PT
#debug_left time timeout~PT
 LEAX timeout
 CAL  TON_L0
#srcline 262 ;  timeout2(PT := T#3s);
 LD   time 3000
 WRX  timeout2~PT
#debug_left time timeout2~PT
 LEAX timeout2
 CAL  TON_L0
#srcline 264 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbNsLookUp_L7
#srcline 265 ;    RecvFrom(rq := 1, chanCode := chanCode, lenRx := SIZEOF(netDnsReply),
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   524  ; SizeOf()
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
#srcline 266 ;             data := void(netDnsReply));
 LEAX netDnsReply
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 267 ;    IF RecvFrom.mesRec & RecvFrom.error = 0 THEN
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 AND
 JMC  fbNsLookUp_L9
#srcline 268 ;      IF RecvFrom.lenRx > SIZEOF(TDnsQueryHeader) THEN
 LDX  RecvFrom~lenRx
#debug uint RecvFrom.lenRx
 LD   12  ; SizeOf()
 GT
 JMC  fbNsLookUp_L11
#srcline 269 ;        IF netDnsReply.Header.TransactionID = netDnsQuery.Header.TransactionID THEN
 LDX  netDnsReply~Header~TransactionID
#debug uint netDnsReply.Header.TransactionID
 LDX  netDnsQuery~Header~TransactionID
#debug uint netDnsQuery.Header.TransactionID
 EQ
 JMC  fbNsLookUp_L13
#srcline 270 ;          replycode.0 := netDnsReply.Header.ReplyCode_0;
 LDX  netDnsReply~Header~ReplyCode_0
#debug bool netDnsReply.Header.ReplyCode_0
 WRY  replycode.0
#debug_left bool replycode.0
#srcline 271 ;          replycode.1 := netDnsReply.Header.ReplyCode_1;
 LDX  netDnsReply~Header~ReplyCode_1
#debug bool netDnsReply.Header.ReplyCode_1
 WRY  replycode.1
#debug_left bool replycode.1
#srcline 272 ;          replycode.2 := netDnsReply.Header.ReplyCode_2;
 LDX  netDnsReply~Header~ReplyCode_2
#debug bool netDnsReply.Header.ReplyCode_2
 WRY  replycode.2
#debug_left bool replycode.2
#srcline 273 ;          replycode.3 := netDnsReply.Header.ReplyCode_3;
 LDX  netDnsReply~Header~ReplyCode_3
#debug bool netDnsReply.Header.ReplyCode_3
 WRY  replycode.3
#debug_left bool replycode.3
#srcline 274 ;          IF replycode > 0 THEN
 LDY  replycode
#debug usint replycode
 LD   usint 0
 GT
 JMC  fbNsLookUp_L15
#srcline 275 ;            IP     := Any_IP;
 LEA  Any_IP
#debug pointer Any_IP
 SRC  %IB0
 LDX  IP
#debug_left pointer IP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 276 ;            Busy   := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 277 ;            Err    := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 278 ;            ErrId  := 1+replycode;
 LD   usint 1
 LDY  replycode
#debug usint replycode
 ADD
 AND  $FF
 WRX  ErrId
#debug_left usint ErrId
#srcline 279 ;          ELSE
 JMP  fbNsLookUp_L16
fbNsLookUp_L15:
#srcline 280 ;            Answers := WORD_TO_UINT(SHL(UINT_TO_WORD(netDnsReply.Header.AnswerRRs),8) OR SHR(UINT_TO_WORD(netDnsReply.Header.AnswerRRs),8));
 LDX  netDnsReply~Header~AnswerRRs
#debug uint netDnsReply.Header.AnswerRRs
 LD   uint 8
 SHL
 AND  $FFFF
 LDX  netDnsReply~Header~AnswerRRs
#debug uint netDnsReply.Header.AnswerRRs
 LD   uint 8
 SHR
 AND  $FFFF
 OR  
 WRY  Answers
#debug_left uint Answers
#srcline 281 ;            pWord := ADR(netDnsReply.Data);
 LEAX netDnsReply
 ADD  12  ; + offset 
#debug pointer netDnsReply.Data
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 282 ;            pWord := pWord + _internetlib_dnsLenOfDomainName(pWord) + 4; //step over query
 LEAY pWord
 LDIL 
#debug pointer pWord
 NXT
 LEAY pWord
 LDIL 
#debug pointer pWord
 LEA  __Instance___internetlib_DnsLenOfDomainName~IN
 WRIL 
#debug_left udint __Instance___internetlib_DnsLenOfDomainName~IN
 PRV
 LEA  __Instance___internetlib_DnsLenOfDomainName
 CAL  _internetlib_DnsLenOfDomainName_L0
 ADD
 LD   udint 4
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 283 ;            pWord := pWord + _internetlib_dnsLenOfDomainName(pWord);     //step to type
 LEAY pWord
 LDIL 
#debug pointer pWord
 NXT
 LEAY pWord
 LDIL 
#debug pointer pWord
 LEA  __Instance___internetlib_DnsLenOfDomainName~IN
 WRIL 
#debug_left udint __Instance___internetlib_DnsLenOfDomainName~IN
 PRV
 LEA  __Instance___internetlib_DnsLenOfDomainName
 CAL  _internetlib_DnsLenOfDomainName_L0
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 284 ;            WHILE pWord^ <> 16#0100 DO                      //wait for type A (host address)
fbNsLookUp_L17:
 LEAY pWord
 LDIL    ; dereference 
 LDIW 
#debug uint pWord^
 LD   uint $0100
 EQ
 NEG
 JMC  fbNsLookUp_L18
 DBG 
#srcline 285 ;              IF Answers = 0 THEN RETURN; END_IF;           //if there is no other answers exit
 LDY  Answers
#debug uint Answers
 LD   uint 0
 EQ
 JMC  fbNsLookUp_L19
 JMP  fbNsLookUp_RET
fbNsLookUp_L19:
#srcline 286 ;              Answers := Answers - 1;                       //decrease answers number
 LDY  Answers
#debug uint Answers
 LD   uint 1
 SUB
 AND  $FFFF
 WRY  Answers
#debug_left uint Answers
#srcline 287 ;              pWord := pWord + 8;                           //step over type, class and ttl
 LEAY pWord
 LDIL 
#debug pointer pWord
 LD   udint 8
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 288 ;              val := WORD_TO_UINT(SHL(UINT_TO_WORD(pWord^),8) OR SHR(UINT_TO_WORD(pWord^),8)); //read size of data
 LEAY pWord
 LDIL    ; dereference 
 LDIW 
#debug uint pWord^
 LD   uint 8
 SHL
 AND  $FFFF
 LEAY pWord
 LDIL    ; dereference 
 LDIW 
#debug uint pWord^
 LD   uint 8
 SHR
 AND  $FFFF
 OR  
 WRY  val
#debug_left uint val
#srcline 289 ;              pWord := pWord + UINT_TO_UDINT(val) + 2;      //step over data
 LEAY pWord
 LDIL 
#debug pointer pWord
 LDY  val
#debug uint val
 ADD
 LD   udint 2
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 290 ;//              cName  := dnsDecodeDomainName(IN := pWord, BG := ADR(netDnsReply));
#srcline 291 ;              pWord := pWord + _internetlib_dnsLenOfDomainName(pWord);   //step over name
 LEAY pWord
 LDIL 
#debug pointer pWord
 NXT
 LEAY pWord
 LDIL 
#debug pointer pWord
 LEA  __Instance___internetlib_DnsLenOfDomainName~IN
 WRIL 
#debug_left udint __Instance___internetlib_DnsLenOfDomainName~IN
 PRV
 LEA  __Instance___internetlib_DnsLenOfDomainName
 CAL  _internetlib_DnsLenOfDomainName_L0
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 292 ;            END_WHILE;
 JMP  fbNsLookUp_L17
fbNsLookUp_L18:
 NOP  -1
#srcline 293 ;            pWord := pWord + 8;                             //step over type, class and ttl
 LEAY pWord
 LDIL 
#debug pointer pWord
 LD   udint 8
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 294 ;            IF pWord^ = 16#0400 THEN                        //it should be 4 bytes of host address
 LEAY pWord
 LDIL    ; dereference 
 LDIW 
#debug uint pWord^
 LD   uint $0400
 EQ
 JMC  fbNsLookUp_L21
#srcline 295 ;              pWord := pWord + 2;                           //step over size
 LEAY pWord
 LDIL 
#debug pointer pWord
 LD   udint 2
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 296 ;              offset := UDINT_TO_UINT(PTR_TO_UDINT(pWord) - PTR_TO_UDINT(ADR(netDnsReply.Data[0]))); //offset of ip
 LEAY pWord
 LDIL 
#debug pointer pWord
 LEAX netDnsReply
 ADD  12  ; + offset 
#debug pointer netDnsReply.Data[0]
 SUB
 AND  $FFFF
 WRY  offset
#debug_left uint offset
#srcline 297 ;              IP[0] := netDnsReply.Data[offset];            //read IP
 LEAX netDnsReply
 ADD  12  ; + offset 
 LDY  offset
#debug uint offset
 RCHK 511   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint netDnsReply.Data[offset]
 LDX  IP
 WRI 
#debug_left usint IP[0]
#srcline 298 ;              IP[1] := netDnsReply.Data[offset+1];
 LEAX netDnsReply
 ADD  12  ; + offset 
 LDY  offset
#debug uint offset
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 511   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint netDnsReply.Data[offset+1]
 LDX  IP
 ADD  1  ; + offset 
 WRI 
#debug_left usint IP[1]
#srcline 299 ;              IP[2] := netDnsReply.Data[offset+2];
 LEAX netDnsReply
 ADD  12  ; + offset 
 LDY  offset
#debug uint offset
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 511   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint netDnsReply.Data[offset+2]
 LDX  IP
 ADD  2  ; + offset 
 WRI 
#debug_left usint IP[2]
#srcline 300 ;              IP[3] := netDnsReply.Data[offset+3];
 LEAX netDnsReply
 ADD  12  ; + offset 
 LDY  offset
#debug uint offset
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 511   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint netDnsReply.Data[offset+3]
 LDX  IP
 ADD  3  ; + offset 
 WRI 
#debug_left usint IP[3]
#srcline 301 ;              Done  := true;
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 302 ;              Busy  := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 303 ;            END_IF;
fbNsLookUp_L21:
#srcline 304 ;          END_IF;
fbNsLookUp_L16:
#srcline 305 ;        END_IF;
fbNsLookUp_L13:
#srcline 306 ;      END_IF;
fbNsLookUp_L11:
#srcline 307 ;    END_IF;
fbNsLookUp_L9:
#srcline 308 ;  END_IF;
fbNsLookUp_L7:
#srcline 310 ;  IF timeout.Q THEN
 LDX  timeout~Q
#debug bool timeout.Q
 JMC  fbNsLookUp_L23
#srcline 311 ;    IP     := Any_IP;
 LEA  Any_IP
#debug pointer Any_IP
 SRC  %IB0
 LDX  IP
#debug_left pointer IP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 312 ;    Busy   := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 313 ;    Err    := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 314 ;    ErrId  := 1;
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
#srcline 315 ;  END_IF;
fbNsLookUp_L23:
#srcline 316 ;  
#srcline 317 ;  timeout2.IN := timeout2.IN & Busy;
 LDX  timeout2~IN
#debug bool timeout2.IN
 LDX  Busy
#debug bool Busy
 AND
 WRX  timeout2~IN
#debug_left bool timeout2.IN
#srcline 319 ;END_FUNCTION_BLOCK
fbNsLookUp_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbNsLookUp__InstanceInit__:
 LINK 0
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBNSLOOKUPEX.ST'
#pou fbNsLookUpEx
#srcline 1 ;FUNCTION_BLOCK fbNsLookUpEx

#struct fbNsLookUpEx__temp__
  dint tmp,
  string[82] PS0__st__
P     61
fbNsLookUpEx_L0:
 LINK __SizeOf(fbNsLookUpEx__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  getIP
 LETX __EDGE_R__getIP
 WRX  getIP
#srcline 28 ;  Done := 0;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 29 ;  IF getIP AND NOT busy THEN
 LDX  getIP
#debug bool getIP
 LDX  busy
#debug bool busy
 NEG
 AND
 JMC  fbNsLookUpEx_L1
#srcline 30 ;    busy := 1;
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
#srcline 31 ;    Err := 0;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 32 ;    ErrId := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 33 ;    CurrName := Name;
 LD   0   ; null string
 LEAX CurrName
 WRI  
 LEAX CurrName
 LD   80
 DST    ; Level 1
 LEAX Name
#debug string Name
 SCON 
#debug_left string CurrName
 PDST   ; Level 1
#srcline 34 ;  END_IF;
fbNsLookUpEx_L1:
#srcline 35 ;  IF busy THEN
 LDX  busy
#debug bool busy
 JMC  fbNsLookUpEx_L3
#srcline 36 ;    {asm}
#srcline 37
      LDX    long dnsIP ; IP address of DNS server
#srcline 38
      LEAX   CurrName   ; ptr to domain name
#srcline 39
      LDX    IP         ; ptr to result IP
#srcline 40
      SYS    80         ; dns_register()
#srcline 41
      WRY    tmp
#srcline 42 ;    {end_asm}
#srcline 43 ;    IF tmp = 1 THEN
 LDY  tmp
#debug dint tmp
 LD   dint 1
 EQ
 JMC  fbNsLookUpEx_L5
#srcline 44 ;      Done := 1; Busy := 0;    // OK
 LD   bool -1      ; true
 WRX  Done
#debug_left bool Done
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 45 ;    ELSE
 JMP  fbNsLookUpEx_L6
fbNsLookUpEx_L5:
#srcline 46 ;      IF tmp <> 0 THEN
 LDY  tmp
#debug dint tmp
 LD   dint 0
 EQ
 NEG
 JMC  fbNsLookUpEx_L7
#srcline 47 ;        Busy := 0; Err := 1; ErrId := DINT_TO_USINT(-1 * tmp);  // error
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
 LD   dint -1
 LDY  tmp
#debug dint tmp
 MULS
 AND  $FF
 WRX  ErrId
#debug_left usint ErrId
#srcline 48 ;      END_IF;
fbNsLookUpEx_L7:
#srcline 49 ;    END_IF;
fbNsLookUpEx_L6:
#srcline 50 ;  END_IF;
fbNsLookUpEx_L3:
#srcline 51 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\GETDATEANDTIME_RFC2822.ST'


 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBHTTP.ST'
#pou fbHttpRequest
#srcline 6 ;FUNCTION_BLOCK fbHttpRequest

#struct fbHttpRequest__temp__
  string[81] lNamePass,
  usint r,
  uint i,
  uint BodyLen,
  pointer pHelpString,
  pointer pUint,
  pointer pUsint,
  TUniDesc UniDesc,
  TRemoteEthAdr rea,
  udint l,
  uint authPos,
  usint P0__st__,
  string[257] PS0__st__,
  string[62] PS1__st__,
  string[257] PSC__st__
#data byte _str_fbHttpRequest_0 = 
  '@',0
#data byte _str_fbHttpRequest_1 = 
  'G','E','T',' ',0
#data byte _str_fbHttpRequest_2 = 
  'P','O','S','T',' ',0
#data byte _str_fbHttpRequest_3 = 
  ' ','H','T','T','P','/','1','.','0',$0D,$0A,'U','s','e','r','-','A','g','e','n',
  't',':',' ','F','o','x','t','r','o','t','/',0
#data byte _str_fbHttpRequest_4 = 
  '.',0
#data byte _str_fbHttpRequest_5 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',
  ':',' ','a','p','p','l','i','c','a','t','i','o','n','/','x','-','w','w','w','-',
  'f','o','r','m','-','u','r','l','e','n','c','o','d','e','d',$0D,$0A,'A','c','c',
  'e','p','t',':',' ','t','e','x','t','/','*',';','q','=','0','.','9',',',' ','*',
  '/','*',';','q','=','0','.','1',$0D,$0A,'H','o','s','t',':',' ',0
#data byte _str_fbHttpRequest_6 = 
  $0D,$0A,'A','u','t','h','o','r','i','z','a','t','i','o','n',':',' ','B','a','s',
  'i','c',' ',0
#data byte _str_fbHttpRequest_7 = 
  $0D,$0A,'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',' ',0
#data byte _str_fbHttpRequest_8 = 
  $0D,$0A,'C','o','n','n','e','c','t','i','o','n',':',' ','C','l','o','s','e',$0D,
  $0A,$0D,$0A,0
#data byte _str_fbHttpRequest_9 = 
  'H','T','T','P',0
#data byte _str_fbHttpRequest_10 = 
  'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',0
#data byte _str_fbHttpRequest_11 = 
  $0D,$0A,$0D,$0A,0
P     61
fbHttpRequest_L0:
 LINK __SizeOf(fbHttpRequest__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pHelpString
 LD   udint $FFFFFFFF    ; nil
 WRY  pUint
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Post
 LETX __EDGE_R__Post
 WRX  Post
 LDX  Get
 LETX __EDGE_R__Get
 WRX  Get
 LDX  Cancel
 LETX __EDGE_R__Cancel
 WRX  Cancel
#srcline 70 ;  UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 71 ;  IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 516) OR (UniDesc.lenUniOut < 516) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 516
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 516
 LT
 OR  
 JMC  fbHttpRequest_L1
#srcline 72 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 73 ;    ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 74 ;    RETURN;
 JMP  fbHttpRequest_RET
#srcline 75 ;  END_IF;
fbHttpRequest_L1:
#srcline 76 ;  
#srcline 77 ;  Busy := State <> hs_HttpIdle;
 LDX  State
#debug usint State
 LD   udint 0  ; THttpState#hs_HttpIdle
 EQ
 NEG
 WRX  Busy
#debug_left bool Busy
#srcline 79 ;  TimeOutTon(IN := Busy & NOT DataReady, PT := T#2m);
 LDX  Busy
#debug bool Busy
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 WRX  TimeOutTon~IN
#debug_left bool TimeOutTon~IN
 LD   time 120000
 WRX  TimeOutTon~PT
#debug_left time TimeOutTon~PT
 LEAX TimeOutTon
 CAL  TON_L0
#srcline 81 ;  DataReady := false;
 LD   bool 0       ; false
 WRX  DataReady
#debug_left bool DataReady
#srcline 83 ;  IF TimeOutTon.Q THEN
 LDX  TimeOutTon~Q
#debug bool TimeOutTon.Q
 JMC  fbHttpRequest_L3
#srcline 84 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 85 ;    ErrId := 1;
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
#srcline 86 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 87 ;  END_IF;
fbHttpRequest_L3:
#srcline 89 ;  IF Cancel THEN
 LDX  Cancel
#debug bool Cancel
 JMC  fbHttpRequest_L5
#srcline 90 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 91 ;    Err   := ContLen > 0;
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 92 ;  END_IF;
fbHttpRequest_L5:
#srcline 94 ;  CASE State OF
 LDX  State
#debug usint State
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequest_L8
#srcline 95 ;    hs_HttpIdle   :
#srcline 96 ;      r := CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 97 ;      Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 98 ;      IF Post OR Get THEN
 LDX  Post
#debug bool Post
 LDX  Get
#debug bool Get
 OR  
 JMC  fbHttpRequest_L9
#srcline 99 ;        WholeLen := 0;
 LD   dint 0
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 100 ;        Err     := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 101 ;        ErrId   := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 102 ;        Result  := 0;
 LD   int 0
 WRX  Result
#debug_left int Result
#srcline 103 ;        authPos := FIND(IN1 := Host, IN2 := '@');
 LDX  Host
#debug string Host
 LEA  _str_fbHttpRequest_0
 SFND 
 WRY  authPos
#debug_left uint authPos
#srcline 104 ;        IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequest_L11
#srcline 105 ;          lHost := MID(IN := Host, L := 80, P := authPos+1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LD   80
 LDY  authPos
#debug uint authPos
 LD   uint 1
 ADD
 AND  $FFFF
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 106 ;          lNamePass := LEFT(IN := Host, L := authPos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LDY  authPos
#debug uint authPos
 LD   uint 1
 SUB
 AND  $FFFF
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY lNamePass
 WRI  
 LEAY lNamePass
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lNamePass
 PDST   ; Level 1
#srcline 107 ;        ELSE
 JMP  fbHttpRequest_L12
fbHttpRequest_L11:
#srcline 108 ;          lHost := Host;
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 109 ;        END_IF;
fbHttpRequest_L12:
#srcline 110 ;        
#srcline 111 ;        (*
#srcline 112 ;        pUint := ADR(RecvData);
#srcline 113 ;        pHelpString := pUint;
#srcline 114 ;        *)
#srcline 115 ;        IF Get THEN
 LDX  Get
#debug bool Get
 JMC  fbHttpRequest_L13
#srcline 116 ;          BodyLen := 0;
 LD   uint 0
 WRY  BodyLen
#debug_left uint BodyLen
#srcline 117 ;          HelpString := 'GET ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_1
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 118 ;        ELSE
 JMP  fbHttpRequest_L14
fbHttpRequest_L13:
#srcline 119 ;          BodyLen := LEN(Data);
 LDX  Data
#debug string Data
 SLEN 
 WRY  BodyLen
#debug_left uint BodyLen
#srcline 120 ;          HelpString := 'POST ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_2
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 121 ;        END_IF;
fbHttpRequest_L14:
#srcline 122 ;        //TODO: Dodelat kontrolu delky vstupnich dat
#srcline 123 ;        pUint := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pUint
 WRIL 
#debug_left pointer pUint
#srcline 124 ;        pUsint := pUint  + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUint);
 LEAY pUint
 LDIL 
#debug pointer pUint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUint
 LDIL 
#debug pointer pUint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 125 ;        //max len 5+255 = 300
#srcline 126 ;        helpstring := ' HTTP/1.0$r$nUser-Agent: Foxtrot/' + USINT_TO_STRING(%S40) + '.' + USINT_TO_STRING(%S41);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_3
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S40
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequest_4
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S41
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 127 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 128 ;        //max len 300+33+1+1+1 = 336
#srcline 129 ;        helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nContent-Type: application/x-www-form-urlencoded$r$nAccept: text/*;q=0.9, */*;q=0.1$r$nHost: ';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_5
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 130 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 131 ;        //max len 336+140 = 476
#srcline 132 ;        Err := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 133 ;        REPEAT
fbHttpRequest_L15:
 DBG
#srcline 134 ;          l := LEN(lHost);
 LEAX lHost
#debug string lHost
 SLEN 
 WRY  l
#debug_left udint l
#srcline 135 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequest_L17
 JMP  fbHttpRequest_L16
fbHttpRequest_L17:
#srcline 136 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(lHost), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX lHost
#debug pointer lHost
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 137 ;          
#srcline 138 ;          IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequest_L19
#srcline 139 ;            //Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
#srcline 140 ;            helpstring := '$r$nAuthorization: Basic ' + Base64_encode_string(lNamePass);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_6
 SCON 
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LEAY lNamePass
#debug string lNamePass
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 141 ;            l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 142 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequest_L21
 JMP  fbHttpRequest_L16
fbHttpRequest_L21:
#srcline 143 ;            pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 144 ;          END_IF;
fbHttpRequest_L19:
#srcline 145 ;          
#srcline 146 ;          //max len 476+80 = 556!!!
#srcline 147 ;          helpstring := '$r$nContent-Length: ' + UINT_TO_STRING(BodyLen) + '$r$nConnection: Close$r$n$r$n';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_7
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LDY  BodyLen
#debug uint BodyLen
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequest_8
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 148 ;          l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 149 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequest_L23
 JMP  fbHttpRequest_L16
fbHttpRequest_L23:
#srcline 150 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 152 ;          //max len 556+44=600!!!
#srcline 153 ;          IF POST THEN //copy data to post
 LDX  POST
#debug bool POST
 JMC  fbHttpRequest_L25
#srcline 154 ;            l := LEN(data);
 LDX  data
#debug string data
 SLEN 
 WRY  l
#debug_left udint l
#srcline 155 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequest_L27
 JMP  fbHttpRequest_L16
fbHttpRequest_L27:
#srcline 156 ;            pUsint := pUsint + MemcpyPtr(length := LEN(data), source := ADR(data), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDX  data
#debug string data
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LDX  data
#debug pointer data
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 157 ;            //max len 600+80=680!!!
#srcline 158 ;          END_IF;
fbHttpRequest_L25:
#srcline 159 ;          Err := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 160 ;        UNTIL true END_REPEAT;
 LD   bool -1       ; true
 JMC  fbHttpRequest_L15
fbHttpRequest_L16:
 NOP  -1
#srcline 161 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequest_L29
#srcline 162 ;          ErrId := 3; //prilis mnoho dat k odeslani
 LD   usint 3
 WRX  ErrId
#debug_left usint ErrId
#srcline 163 ;        ELSE
 JMP  fbHttpRequest_L30
fbHttpRequest_L29:
#srcline 164 ;          SendTo.lenTx := UDINT_TO_UINT(PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint));
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 165 ;          State := hs_HttpSetIP;
 LD   udint 1  ; THttpState#hs_HttpSetIP
 WRX  State
#debug_left usint State
#srcline 166 ;          Busy  := true; //Busy is set in the same cycle when we left idle state!!!
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 167 ;        END_IF;
fbHttpRequest_L30:
#srcline 168 ;      END_IF;
fbHttpRequest_L9:
 JMP  fbHttpRequest_L7
fbHttpRequest_L8:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequest_L31
#srcline 169 ;    hs_HttpSetIP:
#srcline 170 ;      IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbHttpRequest_L32
#srcline 171 ;          Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 172 ;          ErrId := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 173 ;          State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 174 ;      ELSE
 JMP  fbHttpRequest_L33
fbHttpRequest_L32:
#srcline 175 ;        rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 176 ;        rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 177 ;        IF SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbHttpRequest_L34
#srcline 178 ;          State := hs_HttpConnect;
 LD   udint 2  ; THttpState#hs_HttpConnect
 WRX  State
#debug_left usint State
#srcline 179 ;        END_IF;
fbHttpRequest_L34:
#srcline 180 ;      END_IF;
fbHttpRequest_L33:
 JMP  fbHttpRequest_L7
fbHttpRequest_L31:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequest_L36
#srcline 181 ;    hs_HttpConnect:
#srcline 182 ;      r := EstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 183 ;      IF IsEstabTCPconnection(chanCode := chanCode) THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbHttpRequest_L37
#srcline 184 ;        State := hs_HttpSend;
 LD   udint 3  ; THttpState#hs_HttpSend
 WRX  State
#debug_left usint State
#srcline 185 ;      END_IF;
fbHttpRequest_L37:
 JMP  fbHttpRequest_L7
fbHttpRequest_L36:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequest_L39
#srcline 186 ;    hs_HttpSend   :
#srcline 187 ;      SendTo(rq := 1, chanCode := chanCode, data := void(RecvData));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  RecvData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 188 ;      ResRecv    := false;
 LD   bool 0       ; false
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 189 ;      LenRecv    := false;
 LD   bool 0       ; false
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 190 ;      HeaderRecv := false;
 LD   bool 0       ; false
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 191 ;      WasEOL     := false;
 LD   bool 0       ; false
 WRX  WasEOL
#debug_left bool WasEOL
#srcline 192 ;      ContLen    := -1;
 LD   dint -1
 WRX  ContLen
#debug_left dint ContLen
#srcline 193 ;      State      := hs_HttpReceivingData;
 LD   udint 4  ; THttpState#hs_HttpReceivingData
 WRX  State
#debug_left usint State
 JMP  fbHttpRequest_L7
fbHttpRequest_L39:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequest_L40
#srcline 194 ;    hs_HttpReceivingData  :
#srcline 195 ;      RecvFrom(rq := 1, chanCode := chanCode, lenRx := 512, data := void(RecvData));
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 512
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LDX  RecvData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 196 ;      IF RecvFrom.mesRec THEN                                                   //byla prijata data
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbHttpRequest_L41
#srcline 197 ;        IF HeaderRecv THEN                                                      //uz byla prijata hlavicka
 LDX  HeaderRecv
#debug bool HeaderRecv
 JMC  fbHttpRequest_L43
#srcline 198 ;          DataLen := RecvFrom.lenData;                                          //delka dat je rovna delce prijateho paketu
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 WRX  DataLen
#debug_left uint DataLen
#srcline 199 ;          ContLen := ContLen - UINT_TO_DINT(DataLen);                           //snizit contlen o prijatou delku
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 200 ;          pUsint  := ADR(RecvData);                                             //nastavit pointer na zacatek dat
 LDX  RecvData
#debug pointer RecvData
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 201 ;        ELSE                                                                    //jeste nebyla prijata hlavicka
 JMP  fbHttpRequest_L44
fbHttpRequest_L43:
#srcline 202 ;          IF RecvFrom.lenData < 511 THEN                                        //pokud jsou data kratsi jak max STRING pridat koncovou nulu !!HAZARD!!
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 511
 LT
 JMC  fbHttpRequest_L45
#srcline 203 ;            RecvData[RecvFrom.lenData] := 0;                                    //koncova nula
 LD   usint 0
 LDX  RecvData
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 RCHK 511   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint RecvData[RecvFrom.lenData]
#srcline 204 ;          END_IF;
fbHttpRequest_L45:
#srcline 205 ;          pHelpString := ADR(RecvData);                                         //pointer na data
 LDX  RecvData
#debug pointer RecvData
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 206 ;          IF NOT ResRecv & FIND(IN1 := pHelpString^, IN2 := 'HTTP') = 1 THEN    //vyhledani zda je to HTTP hlavicka
 LDX  ResRecv
#debug bool ResRecv
 NEG
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 LEA  _str_fbHttpRequest_9
 SFND 
 LD   int 1
 EQ
 AND
 JMC  fbHttpRequest_L47
#srcline 207 ;            ResRecv := true;                                                    //prijat zacatek hlavicky
 LD   bool -1       ; true
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 208 ;            pHelpString := pHelpString + 9;                                     //posunout pointer
 LEAY pHelpString
 LDIL 
#debug pointer pHelpString
 LD   udint 9
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 209 ;            Result := STRING_TO_INT(pHelpString^);                              //rozkodovat navratovy kod
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300B;  IEC_STRING _TO_ IEC_INT
 WRX  Result
#debug_left int Result
#srcline 210 ;//            Debug1       := pHelpString^;
#srcline 211 ;          END_IF;
fbHttpRequest_L47:
#srcline 212 ;          IF NOT LenRecv THEN                                                   //hledat delku jen kdyz se jeste nenasla 121108
 LDX  LenRecv
#debug bool LenRecv
 NEG
 JMC  fbHttpRequest_L49
#srcline 213 ;                                                 //012345678901234
#srcline 214 ;            i := FIND(IN1 := pHelpString^, IN2 := 'Content-Length:');           //hledat delku tela
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 LEA  _str_fbHttpRequest_10
 SFND 
 WRY  i
#debug_left uint i
#srcline 215 ;            IF i > 0 THEN                                                       //nasla se delka
 LDY  i
#debug uint i
 LD   uint 0
 GT
 JMC  fbHttpRequest_L51
#srcline 216 ;              LenRecv := true;                                                  //nastavit priznak ze byla nalezena
 LD   bool -1       ; true
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 217 ;              pHelpString := pHelpString + UINT_TO_UDINT(i+15);                 //posunout pointer
 LEAY pHelpString
 LDIL 
#debug pointer pHelpString
 LDY  i
#debug uint i
 LD   uint 15
 ADD
 AND  $FFFF
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 218 ;              ContLen     := STRING_TO_DINT(pHelpString^);                      //zapsat delku
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300D;  IEC_STRING _TO_ IEC_DINT
 WRX  ContLen
#debug_left dint ContLen
#srcline 219 ;  //            Debug2       := pHelpString^;
#srcline 220 ;            END_IF;
fbHttpRequest_L51:
#srcline 221 ;          END_IF;
fbHttpRequest_L49:
#srcline 222 ;          
#srcline 223 ;          pHelpString := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 224 ;          
#srcline 225 ;          IF WasEOL & RecvData[0] = 13 & RecvData[1] = 10 THEN                  //posledni znak minuleho paketu byl LF a nyni zacina CRLF => konec hlavicky
 LDX  WasEOL
#debug bool WasEOL
 LDX  RecvData
 LDI  
#debug usint RecvData[0]
 LD   usint 13
 EQ
 AND
 LDX  RecvData
 ADD  1  ; + offset 
 LDI  
#debug usint RecvData[1]
 LD   usint 10
 EQ
 AND
 JMC  fbHttpRequest_L53
#srcline 226 ;            i := 65535; //-1                                                    //delku na -1
 LD   uint 65535
 WRY  i
#debug_left uint i
#srcline 227 ;          ELSE
 JMP  fbHttpRequest_L54
fbHttpRequest_L53:
#srcline 228 ;            i := FIND(IN1 := pHelpString^, IN2 := '$r$n$r$n');                  //nalezt konec hlavicky
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 LEA  _str_fbHttpRequest_11
 SFND 
 WRY  i
#debug_left uint i
#srcline 229 ;          END_IF;
fbHttpRequest_L54:
#srcline 230 ;          IF i <> 0 THEN                                                        //byl konec hlavicky
 LDY  i
#debug uint i
 LD   uint 0
 EQ
 NEG
 JMC  fbHttpRequest_L55
#srcline 231 ;            HeaderRecv := true;                                                 //priznak hlavicka prijata
 LD   bool -1       ; true
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 232 ;            pUsint     := pHelpString + UINT_TO_UDINT(i+3);                     //nastavi pointer za hlavicku
 LEAY pHelpString
 LDIL 
#debug pointer pHelpString
 LDY  i
#debug uint i
 LD   uint 3
 ADD
 AND  $FFFF
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 233 ;            DataLen    := RecvFrom.lenData - i - 3;                             //odecist delku hlavicky
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 3
 SUB
 AND  $FFFF
 WRX  DataLen
#debug_left uint DataLen
#srcline 234 ;            MemcpyPtr(source := pUsint, dest := ADR(RecvData), length := UINT_TO_UDINT(DataLen)); //zkopirovat prijata data
 NXT
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LDX  RecvData
#debug pointer RecvData
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  DataLen
#debug uint DataLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 235 ;            ContLen := ContLen - UINT_TO_DINT(DataLen);                         //odecist delku od celkove delky k prijmuti
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 236 ;            IF NOT LenRecv THEN                                                 //pokud nebyla delka prijata
 LDX  LenRecv
#debug bool LenRecv
 NEG
 JMC  fbHttpRequest_L57
#srcline 237 ;              ContLen := 0;                                                     //vynulovat celkovou delku k prijmuti
 LD   dint 0
 WRX  ContLen
#debug_left dint ContLen
#srcline 238 ;            END_IF;
fbHttpRequest_L57:
#srcline 239 ;            WholeLen := ContLen;                                                //zapamatovat si kolik jeste budu prijimat
 LDX  ContLen
#debug dint ContLen
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 240 ;          ELSE
 JMP  fbHttpRequest_L56
fbHttpRequest_L55:
#srcline 241 ;            DataLen := 0;                                                       //neni konec hlavicky => zadna data
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 242 ;          END_IF;
fbHttpRequest_L56:
#srcline 243 ;          IF RecvFrom.lenData = 0 THEN                                          //nic se neprijalo - muze to vubec nastat ???
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 0
 EQ
 JMC  fbHttpRequest_L59
#srcline 244 ;            WasEOL := false;                                                    //tim padem nebyl ani LF !!HAZARD!!
 LD   bool 0       ; false
 WRX  WasEOL
#debug_left bool WasEOL
#srcline 245 ;          ELSE
 JMP  fbHttpRequest_L60
fbHttpRequest_L59:
#srcline 246 ;            WasEOL := RecvData[RecvFrom.lenData-1] = 10;                        //zkontrolovat jeli posledni znak LF
 LDX  RecvData
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 1
 SUB
 AND  $FFFF
 RCHK 511   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint RecvData[RecvFrom.lenData-1]
 LD   usint 10
 EQ
 WRX  WasEOL
#debug_left bool WasEOL
#srcline 247 ;          END_IF;
fbHttpRequest_L60:
#srcline 248 ;        END_IF;
fbHttpRequest_L44:
#srcline 249 ;        DataReady := DataLen > 0;                                               //vydat priznak ze byla prijata data
 LDX  DataLen
#debug uint DataLen
 LD   uint 0
 GT
 WRX  DataReady
#debug_left bool DataReady
#srcline 250 ;      ELSE                                                                      //nic neprislo
 JMP  fbHttpRequest_L42
fbHttpRequest_L41:
#srcline 251 ;        DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 252 ;      END_IF;
fbHttpRequest_L42:
#srcline 253 ;      
#srcline 254 ;      //bDebug := NOT IsEstabTCPconnection(chanCode := chanCode) & ContLen > 0 & NOT DataReady;
#srcline 256 ;      IF NOT IsEstabTCPconnection(chanCode := chanCode) & NOT DataReady THEN //spojeni se zavrelo a nejsou zadna data
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 NEG
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 JMC  fbHttpRequest_L61
#srcline 257 ;        Err    := ContLen > 0;                                               //jeste jsem mel neco prijmout => Error
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 258 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequest_L63
#srcline 259 ;          ErrId := 2;
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
#srcline 260 ;        END_IF;
fbHttpRequest_L63:
#srcline 261 ;//        ErrId  := BOOL_TO_USINT(Err)*2; //Set 2 if error occured
#srcline 262 ;        Done   := NOT Err;                                                   //pokud nebyl error je hotovo
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 263 ;        State  := hs_HttpIdle;                                               //klidovy stav
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 264 ;      END_IF;
fbHttpRequest_L61:
#srcline 266 ;      IF Close & ContLen = 0 THEN
 LDX  Close
#debug bool Close
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 EQ
 AND
 JMC  fbHttpRequest_L65
#srcline 267 ;        CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 268 ;      END_IF;
fbHttpRequest_L65:
 JMP  fbHttpRequest_L7
fbHttpRequest_L40:
fbHttpRequest_L7:
#srcline 272 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbHttpRequest_L67
#srcline 273 ;    IF WholeLen > 0 THEN
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 0
 GTS
 JMC  fbHttpRequest_L69
#srcline 274 ;      Progress := DINT_TO_SINT(((WholeLen - ContLen) * 100 + WholeLen / 2) / WholeLen);
 LDX  WholeLen
#debug dint WholeLen
 LDX  ContLen
#debug dint ContLen
 SUB
 LD   dint 100
 MULS
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 2
 DIVS
 ADD
 LDX  WholeLen
#debug dint WholeLen
 DIVS
 EXTB
 WRX  Progress
#debug_left sint Progress
#srcline 275 ;    ELSE
 JMP  fbHttpRequest_L70
fbHttpRequest_L69:
#srcline 276 ;      Progress := -1;
 LD   sint -1
 WRX  Progress
#debug_left sint Progress
#srcline 277 ;    END_IF;
fbHttpRequest_L70:
#srcline 278 ;  END_IF;
fbHttpRequest_L67:
#srcline 280 ;END_FUNCTION_BLOCK
fbHttpRequest_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbHttpRequest__InstanceInit__:
 LINK 0
 LD   uint 80
 WRX  port
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBSMTP.ST'
#pou fbSmtp
#srcline 19 ;FUNCTION_BLOCK fbSmtp

#struct fbSmtp__temp__
  pointer ptrUsint,
  TMacAdr mac,  ;MAC adresa
  udint tmpud,
  int pos,
  TRemoteEthAdr rea,
  uint tmpReplyCode,
  TUniDesc UniDesc,
  bool timeout_elapsed,  ; true pokud nastal timeout
  usint P0__st__,
  string[257] PS0__st__,
  string[82] PS1__st__
#data byte _str_fbSmtp_0 = 
  '-',0
#data byte _str_fbSmtp_1 = 
  ' ',$0D,$0A,0
#data byte _str_fbSmtp_2 = 
  'E','H','L','O',' ','t','e','c','o','m','a','t','.','P','L','C',$0D,$0A,0
#data byte _str_fbSmtp_3 = 
  'H','E','L','O',' ','t','e','c','o','m','a','t','.','P','L','C',$0D,$0A,0
#data byte _str_fbSmtp_4 = 
  'A','U','T','H',' ','L','O','G','I','N',$0D,$0A,0
#data byte _str_fbSmtp_5 = 
  'M','A','I','L',' ','F','R','O','M',':',' ','<',0
#data byte _str_fbSmtp_6 = 
  ';',0
#data byte _str_fbSmtp_7 = 
  '<',0
#data byte _str_fbSmtp_8 = 
  '>',0
#data byte _str_fbSmtp_9 = 
  ',','<',0
#data byte _str_fbSmtp_10 = 
  '>',0
#data byte _str_fbSmtp_11 = 
  'R','C','P','T',' ','T','O',':','<',0
#data byte _str_fbSmtp_12 = 
  'D','A','T','A',$0D,$0A,0
#data byte _str_fbSmtp_13 = 
  'D','A','T','E',':',' ',0
#data byte _str_fbSmtp_14 = 
  'F','R','O','M',':',' ','"',0
#data byte _str_fbSmtp_15 = 
  '"',' ','<',0
#data byte _str_fbSmtp_16 = 
  'T','O',':',' ',0
#data byte _str_fbSmtp_17 = 
  '@',0
#data byte _str_fbSmtp_18 = 
  'M','e','s','s','a','g','e','-','I','D',':',' ','<',0
#data byte _str_fbSmtp_19 = 
  '%','T','Y','Y','M','M','D','D','h','h','m','m','s','s','z','z','z',0
#data byte _str_fbSmtp_20 = 
  'S','U','B','J','E','C','T',':',' ','=','?',0
#data byte _str_fbSmtp_21 = 
  '?','B','?',0
#data byte _str_fbSmtp_22 = 
  '?','=',$0D,$0A,0
#data byte _str_fbSmtp_23 = 
  'S','U','B','J','E','C','T',':',' ',0
#data byte _str_fbSmtp_24 = 
  'M','I','M','E','-','V','e','r','s','i','o','n',':',' ','1','.','0',$0D,$0A,'C',
  'o','n','t','e','n','t','-','T','y','p','e',':',' ','m','u','l','t','i','p','a',
  'r','t','/','m','i','x','e','d',';',$0D,$0A,' ','b','o','u','n','d','a','r','y',
  '=','"','-','-','-','-','=','_','N','e','x','t','P','a','r','t','_','0','0','0',
  '_','0','0','0','D','_','6','6','6','F','7','8','7','4','.','7','4','6','5','6',
  '3','6','F','"',$0D,$0A,$0D,$0A,'T','h','i','s',' ','i','s',' ','a',' ','m','e',
  's','s','a','g','e',' ','w','i','t','h',' ','m','u','l','t','i','p','l','e',' ',
  'p','a','r','t','s',' ','i','n',' ','M','I','M','E',' ','f','o','r','m','a','t',
  '.',$0D,$0A,$0D,$0A,'-','-','-','-','-','-','=','_','N','e','x','t','P','a','r',
  't','_','0','0','0','_','0','0','0','D','_','6','6','6','F','7','8','7','4','.',
  '7','4','6','5','6','3','6','F',$0D,$0A,0
#data byte _str_fbSmtp_25 = 
  'C','o','n','t','e','n','t','-','T','y','p','e',':',' ','t','e','x','t','/','p',
  'l','a','i','n',';',' ','c','h','a','r','s','e','t','=',0
#data byte _str_fbSmtp_26 = 
  $0D,$0A,$0D,$0A,0
#data byte _str_fbSmtp_27 = 
  'C','o','n','t','e','n','t','-','T','y','p','e',':',' ','t','e','x','t','/','p',
  'l','a','i','n',';',$0D,$0A,$0D,$0A,0
#data byte _str_fbSmtp_28 = 
  '',0
#data byte _str_fbSmtp_29 = 
  'a','p','p','l','i','c','a','t','i','o','n','/','o','c','t','e','t','-','s','t',
  'r','e','a','m',0
#data byte _str_fbSmtp_30 = 
  '-','-','-','-','-','-','=','_','N','e','x','t','P','a','r','t','_','0','0','0',
  '_','0','0','0','D','_','6','6','6','F','7','8','7','4','.','7','4','6','5','6',
  '3','6','F',$0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',':',' ',0
#data byte _str_fbSmtp_31 = 
  ';',' ','n','a','m','e','=','"',0
#data byte _str_fbSmtp_32 = 
  '"',$0D,$0A,0
#data byte _str_fbSmtp_33 = 
  'C','o','n','t','e','n','t','-','T','r','a','n','s','f','e','r','-','E','n','c',
  'o','d','i','n','g',':',' ','b','a','s','e','6','4',$0D,$0A,'C','o','n','t','e',
  'n','t','-','D','i','s','p','o','s','i','t','i','o','n',':',' ','a','t','t','a',
  'c','h','m','e','n','t',';',' ','f','i','l','e','n','a','m','e','=','"',0
#data byte _str_fbSmtp_34 = 
  '"',$0D,$0A,$0D,$0A,0
#data byte _str_fbSmtp_35 = 
  $0D,$0A,0
#data byte _str_fbSmtp_36 = 
  $0D,$0A,0
#data byte _str_fbSmtp_37 = 
  $0D,$0A,0
#data byte _str_fbSmtp_38 = 
  '-','-','-','-','-','-','=','_','N','e','x','t','P','a','r','t','_','0','0','0',
  '_','0','0','0','D','_','6','6','6','F','7','8','7','4','.','7','4','6','5','6',
  '3','6','F','-','-',$0D,$0A,'.',$0D,$0A,0
#data byte _str_fbSmtp_39 = 
  'Q','U','I','T',$0D,$0A,0
P     61
fbSmtp_L0:
 LINK __SizeOf(fbSmtp__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrUsint
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Send
 LETX __EDGE_R__Send
 WRX  Send
 LDX  Cancel
 LETX __EDGE_R__Cancel
 WRX  Cancel
#srcline 96 ;  mesRec := Recv_from.lenMes > 0;
 LDX  Recv_from~lenMes
#debug uint Recv_from.lenMes
 LD   uint 0
 GT
 WRX  mesRec
#debug_left bool mesRec
#srcline 98 ;  UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 99 ;  IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 259) OR (UniDesc.lenUniOut < 259) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 259
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 259
 LT
 OR  
 JMC  fbSmtp_L1
#srcline 100 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 101 ;    ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 102 ;    RETURN;
 JMP  fbSmtp_RET
#srcline 103 ;  END_IF;
fbSmtp_L1:
#srcline 105 ;  IF Cancel THEN
 LDX  Cancel
#debug bool Cancel
 JMC  fbSmtp_L3
#srcline 106 ;    state := ss_SmtpInit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 107 ;  END_IF;
fbSmtp_L3:
#srcline 109 ;  IF state <> ss_Smtptxattachementbody & state <> ss_Smtptxattachement THEN
 LDX  state
#debug usint state
 LD   udint 25  ; TSmtpState#ss_SmtpTxAttachementBody
 EQ
 NEG
 LDX  state
#debug usint state
 LD   udint 24  ; TSmtpState#ss_SmtpTxAttachement
 EQ
 NEG
 AND
 JMC  fbSmtp_L5
#srcline 110 ;    IF h <> INVALID_HANDLE_VALUE THEN
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbSmtp_L7
#srcline 111 ;      FileClose(h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 112 ;      h := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  h
#debug_left udint h
#srcline 113 ;    END_IF;
fbSmtp_L7:
#srcline 114 ;  END_IF;
fbSmtp_L5:
#srcline 116 ;  timeout_cntr( IN := Recv_from.getMes & NOT Send_to.rq, PT := T#1m50s, Q => timeout_elapsed); // timeout
 LDX  Recv_from~getMes
#debug bool Recv_from.getMes
 LDX  Send_to~rq
#debug bool Send_to.rq
 NEG
 AND
 WRX  timeout_cntr~IN
#debug_left bool timeout_cntr~IN
 LD   time 110000
 WRX  timeout_cntr~PT
#debug_left time timeout_cntr~PT
 LEAX timeout_cntr
 CAL  TON_L0
; output assigment 
 LDX  timeout_cntr~Q
#debug bool timeout_cntr~Q
 WRY  timeout_elapsed
#debug_left bool timeout_elapsed
#srcline 118 ;  IF NOT TRO THEN
 LDX  TRO
#debug bool TRO
 NEG
 JMC  fbSmtp_L9
#srcline 119 ;    if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L11
#srcline 120 ;      tmpReplyCode := STRING_TO_UINT(cmd);
 LEAX cmd
#debug string cmd
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 WRY  tmpReplyCode
#debug_left uint tmpReplyCode
#srcline 121 ;      IF Busy AND NOT Err THEN
 LDX  Busy
#debug bool Busy
 LDX  Err
#debug bool Err
 NEG
 AND
 JMC  fbSmtp_L13
#srcline 122 ;        ReplyCode := tmpReplyCode;
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 123 ;      END_IF;
fbSmtp_L13:
#srcline 124 ;      IF FIND(IN1 := cmd, IN2 := '-') = 4 THEN //pokracuje na dalsim radku
 LEAX cmd
#debug string cmd
 LEA  _str_fbSmtp_0
 SFND 
 LD   int 4
 EQ
 JMC  fbSmtp_L15
#srcline 125 ;        mesRec := 0;
 LD   bool 0       ; false
 WRX  mesRec
#debug_left bool mesRec
#srcline 126 ;      END_IF;
fbSmtp_L15:
#srcline 127 ;    end_if;
fbSmtp_L11:
#srcline 129 ;    CASE state OF
 LDX  state
#debug usint state
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L18
#srcline 130 ;      // inicializace ------------------------------------------------------------
#srcline 131 ;      ss_Smtpinit :
#srcline 132 ;        busy        := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 133 ;        Done        := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 134 ;        state       := ss_Smtpidle;
 LD   udint 1  ; TSmtpState#ss_SmtpIdle
 WRX  state
#debug_left usint state
#srcline 135 ;        // nenavazovat spojeni : r0_p0_Control_ETH1_UNI0.CONTROL.0 := 1;
#srcline 136 ;        CloseTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
 JMP  fbSmtp_L17
fbSmtp_L18:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L19
#srcline 138 ;      // cekani na start ---------------------------------------------------------
#srcline 139 ;      ss_Smtpidle :
#srcline 140 ;        if Send then
 LDX  Send
#debug bool Send
 JMC  fbSmtp_L20
#srcline 141 ;          lAuth := Auth;
 LDX  Auth
#debug bool Auth
 WRX  lAuth
#debug_left bool lAuth
#srcline 142 ;          // vycistime prijimaci a vysilaci buffer
#srcline 143 ;          Recv_from.getMes := FALSE;
 LD   bool 0       ; false
 WRX  Recv_from~getMes
#debug_left bool Recv_from.getMes
#srcline 144 ;          Send_to.rq   := FALSE;   Send_to.lenTx := 1;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
 LD   uint 1
 WRX  Send_to~lenTx
#debug_left uint Send_to.lenTx
#srcline 145 ;          state := ss_SmtpSetIp;
 LD   udint 2  ; TSmtpState#ss_SmtpSetIP
 WRX  state
#debug_left usint state
#srcline 146 ;          busy  := true; body_lines := USINT_TO_SINT(lines);
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
 LDX  lines
#debug usint lines
 EXTB
 WRX  body_lines
#debug_left sint body_lines
#srcline 147 ;          Err   := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 148 ;          ErrId := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 149 ;          ReplyCode := 0;
 LD   uint 0
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 150 ;        end_if;
fbSmtp_L20:
 JMP  fbSmtp_L17
fbSmtp_L19:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L22
#srcline 151 ;      // nastaveni IP adresy
#srcline 152 ;      ss_SmtpSetIp:
#srcline 153 ;        IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbSmtp_L23
#srcline 154 ;          Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 155 ;          ErrId  := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 156 ;          state  := ss_Smtpidle;
 LD   udint 1  ; TSmtpState#ss_SmtpIdle
 WRX  state
#debug_left usint state
#srcline 157 ;        ELSE
 JMP  fbSmtp_L24
fbSmtp_L23:
#srcline 158 ;          rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 159 ;          rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 160 ;          IF SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbSmtp_L25
#srcline 161 ;            EstabTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 162 ;            state := ss_Smtprxconnect; //ss_Smtptxconnect;
 LD   udint 4  ; TSmtpState#ss_SmtpRxConnect
 WRX  state
#debug_left usint state
#srcline 163 ;          END_IF;
fbSmtp_L25:
#srcline 164 ;        END_IF;
fbSmtp_L24:
 JMP  fbSmtp_L17
fbSmtp_L22:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L27
#srcline 165 ;      // kontaktujeme server -----------------------------------------------------
#srcline 166 ;      ss_Smtptxconnect :
#srcline 167 ;        // navazat spojeni se serverem : r0_p0_Control_ETH1_UNI0.CONTROL.0 := 0;
#srcline 168 ;        cmd := ' $r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_1
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 169 ;        Send_to.rq := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 170 ;        state := ss_Smtprxconnect;
 LD   udint 4  ; TSmtpState#ss_SmtpRxConnect
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L27:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L28
#srcline 171 ;      // cekani na odezvu --------------------------------------------------------
#srcline 172 ;      ss_Smtprxconnect :
#srcline 173 ;        Send_to.rq   := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 174 ;        Recv_from.getMes := TRUE;
 LD   bool -1       ; true
 WRX  Recv_from~getMes
#debug_left bool Recv_from.getMes
#srcline 175 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L29
#srcline 176 ;          {$IFDEF _DEBUG} dbg1 := cmd; {$END_IF}
#srcline 177 ;          if tmpReplyCode = 220 then //je to odezva typu '220 proxy.tecomat.cz ESMTP ready'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 220
 EQ
 JMC  fbSmtp_L31
#srcline 178 ;            state := ss_Smtptxhelo;
 LD   udint 5  ; TSmtpState#ss_SmtpTxHelo
 WRX  state
#debug_left usint state
#srcline 179 ;          else
 JMP  fbSmtp_L32
fbSmtp_L31:
#srcline 180 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 181 ;          end_if;
fbSmtp_L32:
#srcline 182 ;        else
 JMP  fbSmtp_L30
fbSmtp_L29:
#srcline 183 ;          if timeout_elapsed then    //server neodpovida
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L33
#srcline 184 ;            state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 185 ;          end_if;
fbSmtp_L33:
#srcline 186 ;        end_if;
fbSmtp_L30:
 JMP  fbSmtp_L17
fbSmtp_L28:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L35
#srcline 189 ;      // posleme prikaz helo -----------------------------------------------------
#srcline 190 ;      ss_Smtptxhelo :
#srcline 191 ;        IF lAuth THEN
 LDX  lAuth
#debug bool lAuth
 JMC  fbSmtp_L36
#srcline 192 ;          cmd := 'EHLO tecomat.PLC$r$l'; //ESMTP
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_2
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 193 ;        ELSE
 JMP  fbSmtp_L37
fbSmtp_L36:
#srcline 194 ;          cmd := 'HELO tecomat.PLC$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_3
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 195 ;        END_IF;
fbSmtp_L37:
#srcline 196 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 197 ;        state := ss_Smtprxhelo;
 LD   udint 6  ; TSmtpState#ss_SmtpRxHelo
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L35:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L38
#srcline 199 ;      // cekani na odezvu --------------------------------------------------------
#srcline 200 ;      ss_Smtprxhelo :
#srcline 201 ;        Send_to.rq   := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 202 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L39
#srcline 203 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 204 ;          if tmpReplyCode = 250 then //je to odezva typu '250'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtp_L41
#srcline 205 ;            if lAuth then
 LDX  lAuth
#debug bool lAuth
 JMC  fbSmtp_L43
#srcline 206 ;              state := ss_Smtptxauthlogin;
 LD   udint 7  ; TSmtpState#ss_SmtpTxAuthlogin
 WRX  state
#debug_left usint state
#srcline 207 ;            else
 JMP  fbSmtp_L44
fbSmtp_L43:
#srcline 208 ;              state := ss_Smtptxmailfrom;
 LD   udint 13  ; TSmtpState#ss_SmtpTxMailFrom
 WRX  state
#debug_left usint state
#srcline 209 ;            end_if;
fbSmtp_L44:
#srcline 210 ;          else
 JMP  fbSmtp_L42
fbSmtp_L41:
#srcline 211 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 212 ;          end_if;
fbSmtp_L42:
#srcline 213 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtp_L40
fbSmtp_L39:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L45
#srcline 214 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 215 ;        end_if;
 JMP  fbSmtp_L40
fbSmtp_L45:
fbSmtp_L40:
 JMP  fbSmtp_L17
fbSmtp_L38:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L46
#srcline 217 ;      // AUTH LOGIN
#srcline 218 ;      ss_Smtptxauthlogin:
#srcline 219 ;        cmd := 'AUTH LOGIN$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_4
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 220 ;        Send_to.rq   := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 221 ;        state := ss_Smtprxauthlogin;
 LD   udint 8  ; TSmtpState#ss_SmtpRxAuthlogin
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L46:
 LD   8
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L47
#srcline 223 ;      // 334
#srcline 224 ;      ss_Smtprxauthlogin:
#srcline 225 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 226 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L48
#srcline 227 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 228 ;          if tmpReplyCode = 334 then //je to odezva typu '334'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 334
 EQ
 JMC  fbSmtp_L50
#srcline 229 ;            state := ss_Smtptxusername;
 LD   udint 9  ; TSmtpState#ss_SmtpTxUserName
 WRX  state
#debug_left usint state
#srcline 230 ;          else
 JMP  fbSmtp_L51
fbSmtp_L50:
#srcline 231 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 232 ;          end_if;
fbSmtp_L51:
#srcline 233 ;        elsif timeout_elapsed then   // server neodpovida
 JMP  fbSmtp_L49
fbSmtp_L48:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L52
#srcline 234 ;          state := ss_Smtptxusername;
 LD   udint 9  ; TSmtpState#ss_SmtpTxUserName
 WRX  state
#debug_left usint state
#srcline 235 ;        end_if;
 JMP  fbSmtp_L49
fbSmtp_L52:
fbSmtp_L49:
 JMP  fbSmtp_L17
fbSmtp_L47:
 LD   9
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L53
#srcline 237 ;      // Username:
#srcline 238 ;      ss_Smtptxusername:
#srcline 239 ;        cmd := Base64_encode_string(username) + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LDX  username
#debug string username
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 240 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 241 ;        state := ss_Smtprxusername;
 LD   udint 10  ; TSmtpState#ss_SmtpRxUserName
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L53:
 LD   10
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L54
#srcline 243 ;      // 334
#srcline 244 ;      ss_Smtprxusername:
#srcline 245 ;        Send_to.rq   := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 246 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L55
#srcline 247 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 248 ;          if tmpReplyCode = 334 then //je to odezva typu '334'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 334
 EQ
 JMC  fbSmtp_L57
#srcline 249 ;            state := ss_Smtptxpassword;
 LD   udint 11  ; TSmtpState#ss_SmtpTxPassword
 WRX  state
#debug_left usint state
#srcline 250 ;          else
 JMP  fbSmtp_L58
fbSmtp_L57:
#srcline 251 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 252 ;          end_if;
fbSmtp_L58:
#srcline 253 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtp_L56
fbSmtp_L55:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L59
#srcline 254 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 255 ;        end_if;
 JMP  fbSmtp_L56
fbSmtp_L59:
fbSmtp_L56:
 JMP  fbSmtp_L17
fbSmtp_L54:
 LD   11
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L60
#srcline 257 ;      // Password:
#srcline 258 ;      ss_Smtptxpassword:
#srcline 259 ;        cmd := Base64_encode_string(password) + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LDX  password
#debug string password
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 260 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 261 ;        state := ss_Smtprxpassword;
 LD   udint 12  ; TSmtpState#ss_SmtpRxPassword
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L60:
 LD   12
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L61
#srcline 263 ;      // 235
#srcline 264 ;      ss_Smtprxpassword:
#srcline 265 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 266 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L62
#srcline 267 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 268 ;          if tmpReplyCode = 235 then   //je to odezva typu '235'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 235
 EQ
 JMC  fbSmtp_L64
#srcline 269 ;            state := ss_Smtptxmailfrom;
 LD   udint 13  ; TSmtpState#ss_SmtpTxMailFrom
 WRX  state
#debug_left usint state
#srcline 270 ;          else
 JMP  fbSmtp_L65
fbSmtp_L64:
#srcline 271 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 272 ;          end_if;
fbSmtp_L65:
#srcline 273 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtp_L63
fbSmtp_L62:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L66
#srcline 274 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 275 ;        end_if;
 JMP  fbSmtp_L63
fbSmtp_L66:
fbSmtp_L63:
 JMP  fbSmtp_L17
fbSmtp_L61:
 LD   13
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L67
#srcline 278 ;      // posleme adresu odesilatele ----------------------------------------------
#srcline 279 ;      ss_Smtptxmailfrom :
#srcline 280 ;        cmd := 'MAIL FROM: <'+sender+SMTP_END_OF_LINE_2_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_5
 SCON 
 LDX  sender
#debug string sender
 SCON 
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 281 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 282 ;        state := ss_Smtprxmailfrom;
 LD   udint 14  ; TSmtpState#ss_SmtpRxMailFrom
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L67:
 LD   14
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L68
#srcline 284 ;      // cekani na odezvu --------------------------------------------------------
#srcline 285 ;      ss_Smtprxmailfrom :
#srcline 286 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 287 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L69
#srcline 288 ;          {$IFDEF _DEBUG} dbg3 := cmd; {$END_IF}
#srcline 289 ;          if tmpReplyCode = 250 then //je to odezva typu '250'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtp_L71
#srcline 290 ;            state := ss_Smtptxrcptto;
 LD   udint 15  ; TSmtpState#ss_SmtpTxRcptTo
 WRX  state
#debug_left usint state
#srcline 291 ;            copy_rcpt := rcpt;
 LD   0   ; null string
 LEAX copy_rcpt
 WRI  
 LEAX copy_rcpt
 LD   255
 DST    ; Level 1
 LDX  rcpt
#debug string rcpt
 SCON 
#debug_left string copy_rcpt
 PDST   ; Level 1
#srcline 292 ;            body_rcpt := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX body_rcpt
 WRI  
 LEAX body_rcpt
 LD   80
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string body_rcpt
 PDST   ; Level 1
#srcline 293 ;          else
 JMP  fbSmtp_L72
fbSmtp_L71:
#srcline 294 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 295 ;          end_if;
fbSmtp_L72:
#srcline 296 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtp_L70
fbSmtp_L69:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L73
#srcline 297 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 298 ;        end_if;
 JMP  fbSmtp_L70
fbSmtp_L73:
fbSmtp_L70:
 JMP  fbSmtp_L17
fbSmtp_L68:
 LD   15
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L74
#srcline 300 ;      // posleme adresu prijemce -------------------------------------------------
#srcline 301 ;      ss_Smtptxrcptto :
#srcline 302 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 303 ;        pos := find( copy_rcpt, ';');
 LEAX copy_rcpt
#debug string copy_rcpt
 LEA  _str_fbSmtp_6
 SFND 
 WRY  pos
#debug_left int pos
#srcline 304 ;        ptrUsint := ADR(temp_rcpt);
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 305 ;        if pos <> 0 then
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  fbSmtp_L75
#srcline 306 ;          temp_rcpt := left( copy_rcpt, pos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   180
 DST    ; Level 1
 LEAX copy_rcpt
#debug string copy_rcpt
 LDY  pos
#debug int pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX temp_rcpt
 WRI  
 LEAX temp_rcpt
 LD   180
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string temp_rcpt
 PDST   ; Level 1
#srcline 307 ;          copy_rcpt := delete(IN := copy_rcpt, L := pos, P := 1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX copy_rcpt
#debug string copy_rcpt
 LDY  pos
#debug int pos
 EXTW 
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX copy_rcpt
 WRI  
 LEAX copy_rcpt
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string copy_rcpt
 PDST   ; Level 1
#srcline 308 ;        else
 JMP  fbSmtp_L76
fbSmtp_L75:
#srcline 309 ;          temp_rcpt := copy_rcpt;
 LD   0   ; null string
 LEAX temp_rcpt
 WRI  
 LEAX temp_rcpt
 LD   180
 DST    ; Level 1
 LEAX copy_rcpt
#debug string copy_rcpt
 SCON 
#debug_left string temp_rcpt
 PDST   ; Level 1
#srcline 310 ;          copy_rcpt := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX copy_rcpt
 WRI  
 LEAX copy_rcpt
 LD   255
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string copy_rcpt
 PDST   ; Level 1
#srcline 311 ;        end_if;
fbSmtp_L76:
#srcline 312 ;        if ptrUsint^ = 46 then
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint 46
 EQ
 JMC  fbSmtp_L77
#srcline 313 ;           temp_rcpt := delete(IN := temp_rcpt, L := 1, P := 1); //vymazat prvni znak ktery urcil ze je to hidden
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   180
 DST    ; Level 1
 LEAX temp_rcpt
#debug string temp_rcpt
 LD   1
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX temp_rcpt
 WRI  
 LEAX temp_rcpt
 LD   180
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string temp_rcpt
 PDST   ; Level 1
#srcline 314 ;        else
 JMP  fbSmtp_L78
fbSmtp_L77:
#srcline 315 ;          ptrUsint := ADR(body_rcpt);
 LEAX body_rcpt
#debug pointer body_rcpt
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 316 ;          if ptrUsint^ = 0 then
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint 0
 EQ
 JMC  fbSmtp_L79
#srcline 317 ;            body_rcpt := '<'+temp_rcpt+'>';    //priprava pro telo zpravy
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_fbSmtp_7
 SCON 
 LEAX temp_rcpt
#debug string temp_rcpt
 SCON 
 LEA  _str_fbSmtp_8
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX body_rcpt
 WRI  
 LEAX body_rcpt
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string body_rcpt
 PDST   ; Level 1
#srcline 318 ;          else
 JMP  fbSmtp_L80
fbSmtp_L79:
#srcline 319 ;            body_rcpt := body_rcpt+',<'+temp_rcpt+'>';    //priprava pro telo zpravy
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX body_rcpt
#debug string body_rcpt
 SCON 
 LEA  _str_fbSmtp_9
 SCON 
 LEAX temp_rcpt
#debug string temp_rcpt
 SCON 
 LEA  _str_fbSmtp_10
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX body_rcpt
 WRI  
 LEAX body_rcpt
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string body_rcpt
 PDST   ; Level 1
#srcline 320 ;          end_if;
fbSmtp_L80:
#srcline 321 ;        end_if;
fbSmtp_L78:
#srcline 322 ;//        body_rcpt := body_rcpt+'<'+temp_rcpt+'>';    //priprava pro telo zpravy
#srcline 323 ;        cmd := 'RCPT TO:<'+temp_rcpt+SMTP_END_OF_LINE_2_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_11
 SCON 
 LEAX temp_rcpt
#debug string temp_rcpt
 SCON 
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 324 ;        state := ss_Smtprxrcptto;
 LD   udint 16  ; TSmtpState#ss_SmtpRxRcptTo
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L74:
 LD   16
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L81
#srcline 326 ;      // cekani na odezvu --------------------------------------------------------
#srcline 327 ;      ss_Smtprxrcptto :
#srcline 328 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 329 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L82
#srcline 330 ;          {$IFDEF _DEBUG} dbg4 := cmd; {$END_IF}
#srcline 331 ;          if tmpReplyCode = 250 or tmpReplyCode = 251 then //je to odezva typu '250' nebo '251'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 251
 EQ
 OR  
 JMC  fbSmtp_L84
#srcline 332 ;            if len(copy_rcpt) = 0 then
 LEAX copy_rcpt
#debug string copy_rcpt
 SLEN 
 LD   int 0
 EQ
 JMC  fbSmtp_L86
#srcline 333 ;              state := ss_Smtptxdata;         //telo zpravy
 LD   udint 17  ; TSmtpState#ss_SmtpTxData
 WRX  state
#debug_left usint state
#srcline 334 ;            else
 JMP  fbSmtp_L87
fbSmtp_L86:
#srcline 335 ;              state := ss_Smtptxrcptto;       //dalsi prijemce
 LD   udint 15  ; TSmtpState#ss_SmtpTxRcptTo
 WRX  state
#debug_left usint state
#srcline 336 ;//              body_rcpt := body_rcpt+',';
#srcline 337 ;            end_if;
fbSmtp_L87:
#srcline 338 ;          else
 JMP  fbSmtp_L85
fbSmtp_L84:
#srcline 339 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 340 ;          end_if;
fbSmtp_L85:
#srcline 341 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtp_L83
fbSmtp_L82:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L88
#srcline 342 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 343 ;        end_if;
 JMP  fbSmtp_L83
fbSmtp_L88:
fbSmtp_L83:
 JMP  fbSmtp_L17
fbSmtp_L81:
 LD   17
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L89
#srcline 344 ;      // posleme telo zpravy -----------------------------------------------------
#srcline 345 ;      ss_Smtptxdata :
#srcline 346 ;        cmd := 'DATA$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_12
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 347 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 348 ;        state := ss_Smtprxdata;
 LD   udint 18  ; TSmtpState#ss_SmtpRxData
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L89:
 LD   18
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L90
#srcline 350 ;      // cekani na odezvu --------------------------------------------------------
#srcline 351 ;      ss_Smtprxdata :
#srcline 352 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 353 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L91
#srcline 354 ;          {$IFDEF _DEBUG} dbg5 := cmd; {$END_IF}
#srcline 355 ;          if tmpReplyCode = 354 then //je to odezva typu '354'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 354
 EQ
 JMC  fbSmtp_L93
#srcline 356 ;            state := ss_Smtptxdate;
 LD   udint 32  ; TSmtpState#ss_SmtpTxDate
 WRX  state
#debug_left usint state
#srcline 357 ;          else
 JMP  fbSmtp_L94
fbSmtp_L93:
#srcline 358 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 359 ;          end_if;
fbSmtp_L94:
#srcline 360 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtp_L92
fbSmtp_L91:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L95
#srcline 361 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 362 ;        end_if;
 JMP  fbSmtp_L92
fbSmtp_L95:
fbSmtp_L92:
 JMP  fbSmtp_L17
fbSmtp_L90:
 LD   32
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L96
#srcline 364 ;      // posleme datum kdy jsme zpravu poslali -----------------------------------
#srcline 365 ;      ss_Smtptxdate :
#srcline 366 ;        cmd := 'DATE: ' + GetDateAndTime_RFC2822(UtcOff := UtcOff)+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_13
 SCON 
 NXT
 LDX  UtcOff
#debug int UtcOff
 EXTW 
 WR   __Instance__GetDateAndTime_RFC2822~UtcOff
#debug_left int __Instance__GetDateAndTime_RFC2822~UtcOff
 PRV
 LEA  __Instance__GetDateAndTime_RFC2822
 CAL  GetDateAndTime_RFC2822_L0

 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 367 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 368 ;        state := ss_Smtptxdatafrom;
 LD   udint 19  ; TSmtpState#ss_SmtpTxDataFrom
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L96:
 LD   19
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L97
#srcline 370 ;      // posleme telo zpravy - odesilatel ----------------------------------------
#srcline 371 ;      ss_Smtptxdatafrom :
#srcline 372 ;        cmd := 'FROM: "'+SendName+'" <'+sender+SMTP_END_OF_LINE_2_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_14
 SCON 
 LDX  SendName
#debug string SendName
 SCON 
 LEA  _str_fbSmtp_15
 SCON 
 LDX  sender
#debug string sender
 SCON 
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 373 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 374 ;        state := ss_Smtptxdatato;
 LD   udint 20  ; TSmtpState#ss_SmtpTxDataTo
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L97:
 LD   20
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L98
#srcline 376 ;      // posleme telo zpravy - prijemce ------------------------------------------
#srcline 377 ;      ss_Smtptxdatato :
#srcline 378 ;        cmd := 'TO: '+body_rcpt+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_16
 SCON 
 LEAX body_rcpt
#debug string body_rcpt
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 379 ;        IF genMessageID THEN
 LDX  genMessageID
#debug bool genMessageID
 JMC  fbSmtp_L99
#srcline 380 ;          state := ss_SmtpTxMessageId;
 LD   udint 34  ; TSmtpState#ss_SmtpTxMessageId
 WRX  state
#debug_left usint state
#srcline 381 ;        ELSE
 JMP  fbSmtp_L100
fbSmtp_L99:
#srcline 382 ;          state := ss_Smtptxdatasubject;
 LD   udint 21  ; TSmtpState#ss_SmtpTxDataSubject
 WRX  state
#debug_left usint state
#srcline 383 ;        END_IF;
fbSmtp_L100:
 JMP  fbSmtp_L17
fbSmtp_L98:
 LD   34
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L101
#srcline 385 ;      //pokus o vygenerovani Message-ID
#srcline 386 ;      ss_SmtpTxMessageId:
#srcline 387 ;        pos := FIND(Sender, '@');
 LDX  Sender
#debug string Sender
 LEA  _str_fbSmtp_17
 SFND 
 WRY  pos
#debug_left int pos
#srcline 388 ;        ptrText := ADR(Sender) + INT_TO_UDINT(pos) - 1;
 LDX  Sender
#debug pointer Sender
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LD   udint 1
 SUB
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 389 ;        IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  fbSmtp_L102
#srcline 390 ;          GetMACaddress(ethChan := ETH1, MacAdr := mac);
 NXT
 LD   usint 225
 WR   __Instance__GetMACaddress~ethChan
#debug_left usint __Instance__GetMACaddress~ethChan
 LEAY mac
 WR   __Instance__GetMACaddress~MacAdr
#debug_left pointer __Instance__GetMACaddress.MacAdr
 PRV
 LEA  __Instance__GetMACaddress
 CAL  GetMACaddress_L0
#srcline 391 ;          {ASM}
#srcline 392
             LDY word mac[0]
#srcline 393
             BAS
#srcline 394
             WRX dword cmd[0]
#srcline 395
             LDY word mac[2]
#srcline 396
             BAS
#srcline 397
             WRX dword cmd[4]
#srcline 398
             LDY word mac[4]
#srcline 399
             BAS
#srcline 400
             WRX dword cmd[8]
#srcline 401
             LD  0
#srcline 402
             WRX cmd[12]
#srcline 403 ;          {END_ASM}
#srcline 404 ;          cmd := 'Message-ID: <' + DT_TO_STRINGF(in := GetRTC(), format := '%TYYMMDDhhmmsszzz') +
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_18
 SCON 
 NXT
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_fbSmtp_19
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
#srcline 405 ;                  cmd +
 LEAX cmd
#debug string cmd
 SCON 
#srcline 406 ;                  ptrText^ +
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
#srcline 407 ;                  SMTP_END_OF_LINE_2_;
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 408 ;        END_IF;
fbSmtp_L102:
#srcline 409 ;        state := ss_Smtptxdatasubject;
 LD   udint 21  ; TSmtpState#ss_SmtpTxDataSubject
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L101:
 LD   21
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L104
#srcline 410 ;      // posleme telo zpravy - predmet -------------------------------------------
#srcline 411 ;      ss_Smtptxdatasubject :
#srcline 412 ;        IF LEN(charset) > 0 THEN
 LEAX charset
#debug string charset
 SLEN 
 LD   int 0
 GTS
 JMC  fbSmtp_L105
#srcline 413 ;          cmd := 'SUBJECT: =?'+charset+'?B?'+Base64_encode_string(subject)+'?=$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_20
 SCON 
 LEAX charset
#debug string charset
 SCON 
 LEA  _str_fbSmtp_21
 SCON 
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LDX  subject
#debug string subject
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 LEA  _str_fbSmtp_22
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 414 ;        ELSE
 JMP  fbSmtp_L106
fbSmtp_L105:
#srcline 415 ;          cmd := 'SUBJECT: '+subject+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_23
 SCON 
 LDX  subject
#debug string subject
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 416 ;        END_IF;
fbSmtp_L106:
#srcline 417 ;        state := ss_Smtptxmultipart;
 LD   udint 22  ; TSmtpState#ss_SmtpTxMultipart
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L104:
 LD   22
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L107
#srcline 418 ;      // posleme odelovac casti --------------------------------------------------
#srcline 419 ;     // posleme odelovac casti v2 --------------------------------------------------
#srcline 420 ;      ss_Smtptxmultipart :
#srcline 421 ;        cmd := 'MIME-Version: 1.0$r$lContent-Type: multipart/mixed;$r$l boundary="----=_NextPart_000_000D_666F7874.7465636F"$r$l$r$lThis is a message with multiple parts in MIME format.$r$l$r$l------=_NextPart_000_000D_666F7874.7465636F$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_24
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 422 ;        state := ss_SmtptxContentType;
 LD   udint 33  ; TSmtpState#ss_SmtpTxContentType
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L107:
 LD   33
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L108
#srcline 423 ;     // posleme kodovani tela textu-------------------------------------------------
#srcline 424 ;      ss_SmtptxContentType :
#srcline 425 ;        IF LEN(charset) > 0 THEN
 LEAX charset
#debug string charset
 SLEN 
 LD   int 0
 GTS
 JMC  fbSmtp_L109
#srcline 426 ;          cmd := 'Content-Type: text/plain; charset='+charset+'$r$l$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_25
 SCON 
 LEAX charset
#debug string charset
 SCON 
 LEA  _str_fbSmtp_26
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 427 ;        ELSE
 JMP  fbSmtp_L110
fbSmtp_L109:
#srcline 428 ;          cmd := 'Content-Type: text/plain;$r$l$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_27
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 429 ;        END_IF;
fbSmtp_L110:
#srcline 430 ;        ptrText := ADR(text);
 LDX  text
#debug pointer text
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 431 ;        state := ss_Smtptxdatatext;
 LD   udint 23  ; TSmtpState#ss_SmtpTxDataText
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L108:
 LD   23
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L111
#srcline 432 ;      // posleme telo zpravy - text zpravy ---------------------------------------
#srcline 433 ;      ss_Smtptxdatatext :
#srcline 434 ;        IF body_lines < 1 THEN
 LDX  body_lines
#debug sint body_lines
 EXTB 
 LD   sint 1
 LTS
 JMC  fbSmtp_L112
#srcline 435 ;          cmd := INTERNETLIB_END_OF_LINE_;   //nedavat nic kdyz je pocet radek mensi nez 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 436 ;        ELSE
 JMP  fbSmtp_L113
fbSmtp_L112:
#srcline 437 ;          cmd := ptrText^+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 438 ;        END_IF;
fbSmtp_L113:
#srcline 439 ;        body_lines := body_lines - 1; ptrText := ptrText + 81; // sizeof(string)
 LDX  body_lines
#debug sint body_lines
 EXTB 
 LD   sint 1
 SUB
 EXTB
 WRX  body_lines
#debug_left sint body_lines
 LEAX ptrText
 LDIL 
#debug pointer ptrText
 LD   udint 81
 ADD
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 441 ;        if body_lines < 1 then
 LDX  body_lines
#debug sint body_lines
 EXTB 
 LD   sint 1
 LTS
 JMC  fbSmtp_L114
#srcline 442 ;          IF LEN(Attach) > 0 THEN
 LDX  Attach
#debug string Attach
 SLEN 
 LD   int 0
 GTS
 JMC  fbSmtp_L116
#srcline 443 ;            h := FileOpen(fileName := Attach, mode := F_READ);
 NXT
 LDX  Attach
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 LD   udint 0  ; TF_MODE#F_READ
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  h
#debug_left udint h
#srcline 444 ;            state := ss_Smtptxattachement;
 LD   udint 24  ; TSmtpState#ss_SmtpTxAttachement
 WRX  state
#debug_left usint state
#srcline 445 ;          ELSE
 JMP  fbSmtp_L117
fbSmtp_L116:
#srcline 446 ;            state := ss_Smtptxendofmail;
 LD   udint 26  ; TSmtpState#ss_SmtpTxEndOfMail
 WRX  state
#debug_left usint state
#srcline 447 ;          END_IF;
fbSmtp_L117:
#srcline 448 ;          IF state = ss_Smtptxattachement & h = INVALID_HANDLE_VALUE THEN
 LDX  state
#debug usint state
 LD   udint 24  ; TSmtpState#ss_SmtpTxAttachement
 EQ
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 AND
 JMC  fbSmtp_L118
#srcline 449 ;            Err   := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 450 ;            ErrId := 3; //cannot open file
 LD   usint 3
 WRX  ErrId
#debug_left usint ErrId
#srcline 451 ;            state := ss_Smtptxendofmail;
 LD   udint 26  ; TSmtpState#ss_SmtpTxEndOfMail
 WRX  state
#debug_left usint state
#srcline 452 ;          END_IF;
fbSmtp_L118:
#srcline 453 ;        END_IF;
fbSmtp_L114:
 JMP  fbSmtp_L17
fbSmtp_L111:
 LD   24
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L120
#srcline 454 ;      // priloha zacatek----------------------------------------------------------
#srcline 455 ;      ss_Smtptxattachement:
#srcline 456 ;        //najit posledni lomitko
#srcline 457 ;        ptrUsint := ADR(Attach);
 LDX  Attach
#debug pointer Attach
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 458 ;        ptrText  := ptrUsint;
 LEAY ptrUsint
 LDIL 
#debug pointer ptrUsint
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 459 ;        WHILE ptrUsint^ <> 0 DO
fbSmtp_L121:
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint 0
 EQ
 NEG
 JMC  fbSmtp_L122
 DBG 
#srcline 460 ;          IF ptrUsint^ = 16#2F THEN //'/'
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint $2F
 EQ
 JMC  fbSmtp_L123
#srcline 461 ;            ptrText  := ptrUsint+1;
 LEAY ptrUsint
 LDIL 
#debug pointer ptrUsint
 LD   udint 1
 ADD
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 462 ;          END_IF;
fbSmtp_L123:
#srcline 463 ;          ptrUsint := ptrUsint + 1;
 LEAY ptrUsint
 LDIL 
#debug pointer ptrUsint
 LD   udint 1
 ADD
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 464 ;        END_WHILE;
 JMP  fbSmtp_L121
fbSmtp_L122:
 NOP  -1
#srcline 466 ;        IF attachementType = '' THEN
 LEAX attachementType
#debug string attachementType
 LEA  _str_fbSmtp_28
 SCMP 
 EQ   0
 JMC  fbSmtp_L125
#srcline 467 ;          attachementType := 'application/octet-stream';
 LD   0   ; null string
 LEAX attachementType
 WRI  
 LEAX attachementType
 LD   32
 DST    ; Level 1
 LEA  _str_fbSmtp_29
 SCON 
#debug_left string attachementType
 PDST   ; Level 1
#srcline 468 ;        END_IF;
fbSmtp_L125:
#srcline 470 ;        cmd := '------=_NextPart_000_000D_666F7874.7465636F$r$lContent-Type: '+attachementType+'; name="'+ptrText^+'"$r$l'+
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_30
 SCON 
 LEAX attachementType
#debug string attachementType
 SCON 
 LEA  _str_fbSmtp_31
 SCON 
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
 LEA  _str_fbSmtp_32
 SCON 
#srcline 471 ;               'Content-Transfer-Encoding: base64$r$lContent-Disposition: attachment; filename="'+ptrText^+'"$r$l$r$l';
 LEA  _str_fbSmtp_33
 SCON 
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
 LEA  _str_fbSmtp_34
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 473 ;        state := ss_Smtptxattachementbody;
 LD   udint 25  ; TSmtpState#ss_SmtpTxAttachementBody
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L120:
 LD   25
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L127
#srcline 474 ;      // priloha telo----------------------------------------------------------
#srcline 475 ;      ss_Smtptxattachementbody:
#srcline 476 ;        tmpud := FileRead(h, PTR_TO_UDINT(ADR(temp_rcpt)), SMTP_MAXIMUM_FILE_LINE_LENGTH_);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LEAX temp_rcpt
#debug pointer temp_rcpt
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LD   udint 171
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
 WRY  tmpud
#debug_left udint tmpud
#srcline 477 ;        cmd := Base64_encode_ptr_string(ADR(temp_rcpt), UDINT_TO_UINT(min(SMTP_BASE64_LEN_,tmpud))) + '$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LEA  __Instance__Base64_encode_ptr_string~data
 WRIL 
#debug_left udint __Instance__Base64_encode_ptr_string~data
 LD   udint 57
 LDY  tmpud
#debug udint tmpud
 MIN
 AND  $FFFF
 WR   __Instance__Base64_encode_ptr_string~dataLen
#debug_left uint __Instance__Base64_encode_ptr_string~dataLen
 PRV
 LEA  __Instance__Base64_encode_ptr_string
 CAL  Base64_encode_ptr_string_L0

 SCON 
 LEA  _str_fbSmtp_35
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 478 ;        IF tmpud > SMTP_BASE64_LEN_ THEN
 LDY  tmpud
#debug udint tmpud
 LD   udint 57
 GT
 JMC  fbSmtp_L128
#srcline 479 ;           cmd := cmd + Base64_encode_ptr_string(ADR(temp_rcpt)+SMTP_BASE64_LEN_, UDINT_TO_UINT(min(SMTP_BASE64_LEN_,tmpud-SMTP_BASE64_LEN_))) + '$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX cmd
#debug string cmd
 SCON 
 NXT
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LD   udint 57
 ADD
 LEA  __Instance__Base64_encode_ptr_string~data
 WRIL 
#debug_left udint __Instance__Base64_encode_ptr_string~data
 LD   udint 57
 LDY  tmpud
#debug udint tmpud
 LD   udint 57
 SUB
 MIN
 AND  $FFFF
 WR   __Instance__Base64_encode_ptr_string~dataLen
#debug_left uint __Instance__Base64_encode_ptr_string~dataLen
 PRV
 LEA  __Instance__Base64_encode_ptr_string
 CAL  Base64_encode_ptr_string_L0

 SCON 
 LEA  _str_fbSmtp_36
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 480 ;        END_IF;
fbSmtp_L128:
#srcline 481 ;        IF tmpud > SMTP_BASE64_LEN2_ THEN
 LDY  tmpud
#debug udint tmpud
 LD   udint 114
 GT
 JMC  fbSmtp_L130
#srcline 482 ;           cmd := cmd + Base64_encode_ptr_string(ADR(temp_rcpt)+SMTP_BASE64_LEN2_, UDINT_TO_UINT(tmpud-SMTP_BASE64_LEN2_)) + '$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX cmd
#debug string cmd
 SCON 
 NXT
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LD   udint 114
 ADD
 LEA  __Instance__Base64_encode_ptr_string~data
 WRIL 
#debug_left udint __Instance__Base64_encode_ptr_string~data
 LDY  tmpud
#debug udint tmpud
 LD   udint 114
 SUB
 AND  $FFFF
 WR   __Instance__Base64_encode_ptr_string~dataLen
#debug_left uint __Instance__Base64_encode_ptr_string~dataLen
 PRV
 LEA  __Instance__Base64_encode_ptr_string
 CAL  Base64_encode_ptr_string_L0

 SCON 
 LEA  _str_fbSmtp_37
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 483 ;        END_IF;
fbSmtp_L130:
#srcline 484 ;        //Send_to.rq  := TRUE;
#srcline 485 ;        IF tmpud < SMTP_MAXIMUM_FILE_LINE_LENGTH_ THEN
 LDY  tmpud
#debug udint tmpud
 LD   udint 171
 LT
 JMC  fbSmtp_L132
#srcline 486 ;          state := ss_Smtptxendofmail;
 LD   udint 26  ; TSmtpState#ss_SmtpTxEndOfMail
 WRX  state
#debug_left usint state
#srcline 487 ;        END_IF;
fbSmtp_L132:
 JMP  fbSmtp_L17
fbSmtp_L127:
 LD   26
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L134
#srcline 488 ;      // konec emailu ------------------------------------------------------------
#srcline 489 ;      (*
#srcline 490 ;      ss_SmtpPause:
#srcline 491 ;        IF timpause - %SL52 <= T#0s THEN
#srcline 492 ;          state := ss_Smtptxattachementbody;
#srcline 493 ;        END_IF;
#srcline 494 ;        return;
#srcline 495 ;      *)
#srcline 496 ;      ss_Smtptxendofmail:
#srcline 497 ;        cmd := '------=_NextPart_000_000D_666F7874.7465636F--$r$l.$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_38
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 498 ;        state := ss_Smtprxack;
 LD   udint 27  ; TSmtpState#ss_SmtpRxAck
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L134:
 LD   27
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L135
#srcline 499 ;      // cekani na odezvu --------------------------------------------------------
#srcline 500 ;      ss_Smtprxack :
#srcline 501 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 502 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L136
#srcline 503 ;          {$IFDEF _DEBUG} dbg6 := cmd; {$END_IF}
#srcline 504 ;          if tmpReplyCode = 250 then //je to odezva typu '250'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtp_L138
#srcline 505 ;            state := ss_Smtptxquit;
 LD   udint 28  ; TSmtpState#ss_SmtpTxQuit
 WRX  state
#debug_left usint state
#srcline 506 ;          else
 JMP  fbSmtp_L139
fbSmtp_L138:
#srcline 507 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 508 ;          end_if;
fbSmtp_L139:
#srcline 509 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtp_L137
fbSmtp_L136:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L140
#srcline 510 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 511 ;        end_if;
 JMP  fbSmtp_L137
fbSmtp_L140:
fbSmtp_L137:
 JMP  fbSmtp_L17
fbSmtp_L135:
 LD   28
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L141
#srcline 513 ;      // ukonceni spojeni --------------------------------------------------------
#srcline 514 ;      ss_Smtptxquit :
#srcline 515 ;        cmd := 'QUIT$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_39
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 516 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 517 ;        state := ss_Smtprxclose;
 LD   udint 29  ; TSmtpState#ss_SmtpRxClose
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L17
fbSmtp_L141:
 LD   29
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L142
#srcline 519 ;      // cekani na ukonceni spojeni ----------------------------------------------
#srcline 520 ;      ss_Smtprxclose :
#srcline 521 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 522 ;        if IsEstabTCPconnection(chanCode := chanCode) = false then  // spojeni ukonceno
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbSmtp_L143
#srcline 523 ;          Done := NOT Err;
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 524 ;          state  := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 525 ;        elsif mesRec then            //prijata odezva
 JMP  fbSmtp_L144
fbSmtp_L143:
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L145
#srcline 526 ;          {$IFDEF _DEBUG} dbg7 := cmd; {$END_IF}
#srcline 527 ;          if tmpReplyCode = 221 then //je to odezva typu '221'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 221
 EQ
 JMC  fbSmtp_L146
#srcline 528 ;            Done := NOT Err;
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 529 ;            state  := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 530 ;          elsif tmpReplyCode = 250 then //je to odezva typu '250'?
 JMP  fbSmtp_L147
fbSmtp_L146:
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtp_L148
#srcline 531 ;            state := ss_Smtptxquit;  //nechce nas pustit posleme jeste jednou
 LD   udint 28  ; TSmtpState#ss_SmtpTxQuit
 WRX  state
#debug_left usint state
#srcline 532 ;          else
 JMP  fbSmtp_L147
fbSmtp_L148:
#srcline 533 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 534 ;          end_if;
fbSmtp_L147:
#srcline 535 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtp_L144
fbSmtp_L145:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L149
#srcline 536 ;          state := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 537 ;        end_if;
 JMP  fbSmtp_L144
fbSmtp_L149:
fbSmtp_L144:
 JMP  fbSmtp_L17
fbSmtp_L142:
 LD   30
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L150
#srcline 539 ;      // osetreni kdyz je timeout prijmu -----------------------------------------
#srcline 540 ;      ss_Smtprxtimeout :
#srcline 541 ;        state := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 542 ;        Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 543 ;        ErrId := 1; //timeout
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
 JMP  fbSmtp_L17
fbSmtp_L150:
 LD   31
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L151
#srcline 545 ;      // osetreni kdyz je chybna odezva ------------------------------------------
#srcline 546 ;      ss_Smtprxerror :
#srcline 547 ;        state := ss_Smtptxquit;
 LD   udint 28  ; TSmtpState#ss_SmtpTxQuit
 WRX  state
#debug_left usint state
#srcline 548 ;        Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 549 ;        ErrId := 2; //unexpected reply
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
 JMP  fbSmtp_L17
fbSmtp_L151:
#srcline 551 ;    // ilegalni stav, provedeme restart stavoveho automatu -----------------------
#srcline 552 ;    ELSE
#srcline 553 ;      state := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 554 ;    END_CASE;
fbSmtp_L17:
#srcline 555 ;  END_IF;
fbSmtp_L9:
#srcline 557 ;  Send_to   (lenTx := len(cmd), chanCode := chanCode, data := void(cmd));
 LEAX cmd
#debug string cmd
 SLEN 
 WRX  Send_to~lenTx
#debug_left uint Send_to~lenTx
 LDX  chanCode
#debug uint chanCode
 WRX  Send_to~chanCode
#debug_left uint Send_to~chanCode
 LEAX cmd
 WRX  Send_to~data
#debug_left pointer Send_to.data
 LEAX Send_to
 CAL  fbSendTo_L0
#srcline 558 ;  TRO := Send_to.error = COM_ERR5; //buffer is full wait
 LDX  Send_to~error
#debug usint Send_to.error
 LD   usint 5
 EQ
 WRX  TRO
#debug_left bool TRO
#srcline 559 ;//  Recv_from (lenRx := 255, chanCode := chanCode,      data := void(cmd));
#srcline 560 ;  IF NOT TRO THEN //pokud je TRO nesmim to volat, jinak mi to prepise moje data
 LDX  TRO
#debug bool TRO
 NEG
 JMC  fbSmtp_L152
#srcline 561 ;    Recv_from(chanCode := chanCode, lenBuf := 512, lenTxt := 255, buffer := buff[0], txtMes := void(cmd));
 LDX  chanCode
#debug uint chanCode
 WRX  Recv_from~chanCode
#debug_left uint Recv_from~chanCode
 LD   uint 512
 WRX  Recv_from~lenBuf
#debug_left uint Recv_from~lenBuf
 LD   uint 255
 WRX  Recv_from~lenTxt
#debug_left uint Recv_from~lenTxt
 LEAX buff
 WRX  Recv_from~buffer
#debug_left pointer Recv_from.buffer
 LEAX cmd
 WRX  Recv_from~txtMes
#debug_left pointer Recv_from.txtMes
 LEAX Recv_from
 CAL  fbRecvTxt_L0
#srcline 562 ;  END_IF;
fbSmtp_L152:
#srcline 564 ;END_FUNCTION_BLOCK
fbSmtp_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbSmtp__InstanceInit__:
 LINK 0
 LD   uint 25
 WRX  port
 LD   udint $FFFFFFFF    ; nil
 WRX  ptrText
 LEAX Recv_from
 CAL  fbRecvTxt__InstanceInit__
 LEAX Send_to
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBSNTP.ST'
#pou fbSntp
#srcline 22 ;FUNCTION_BLOCK fbSntp
#table byte __Init___fbSntp_NtpPacket = 
     27, 15,  8,248;

#struct fbSntp__temp__
  pointer pu,
  pointer pue,
  lreal x,
  lreal y,
  lreal tmpoff,
  lreal tmperr,
  lreal OriginateTime,
  lreal ReceiveTime,
  lreal TransmitTime,
  TUniDesc UniDesc,
  TRemoteEthAdr rea
P     61
fbSntp_L0:
 LINK __SizeOf(fbSntp__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pu
 LD   udint $FFFFFFFF    ; nil
 WRY  pue
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Get
 LETX __EDGE_R__Get
 WRX  Get
 LDX  Accept
 LETX __EDGE_R__Accept
 WRX  Accept
#srcline 93 ;  UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 94 ;  IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 64) OR (UniDesc.lenUniOut < 64) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 64
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 64
 LT
 OR  
 JMC  fbSntp_L1
#srcline 95 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 96 ;    ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 97 ;    RETURN;
 JMP  fbSntp_RET
#srcline 98 ;  END_IF;
fbSntp_L1:
#srcline 100 ;  Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 102 ;  IF Get THEN
 LDX  Get
#debug bool Get
 JMC  fbSntp_L3
#srcline 103 ;    IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbSntp_L5
#srcline 104 ;      Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 105 ;      ErrId := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 106 ;    ELSE
 JMP  fbSntp_L6
fbSntp_L5:
#srcline 107 ;      Busy    := true;   //pracujeme
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 108 ;      Attemps := 5;
 LD   udint 5
 WRX  Attemps
#debug_left udint Attemps
#srcline 109 ;      Success := 0;
 LD   udint 0
 WRX  Success
#debug_left udint Success
#srcline 110 ;      Error   := 3600.0;
 LDQ  lreal 3600.0
 WRX  Error
#debug_left lreal Error
#srcline 111 ;      Offset  := 0.0;
 LDQ  lreal 0.0
 WRX  Offset
#debug_left lreal Offset
#srcline 112 ;      Recv    := false;
 LD   bool 0       ; false
 WRX  Recv
#debug_left bool Recv
#srcline 113 ;      Err     := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 114 ;      ErrId   := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 115 ;      TimeSet := false;
 LD   bool 0       ; false
 WRX  TimeSet
#debug_left bool TimeSet
#srcline 116 ;      rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 117 ;      rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 118 ;      SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea);
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
#srcline 119 ;    END_IF;
fbSntp_L6:
#srcline 120 ;  END_IF;
fbSntp_L3:
#srcline 122 ;  Timeout(IN := Busy, PT := T#15s);         //celkovy timeout
 LDX  Busy
#debug bool Busy
 WRX  Timeout~IN
#debug_left bool Timeout~IN
 LD   time 15000
 WRX  Timeout~PT
#debug_left time Timeout~PT
 LEAX Timeout
 CAL  TON_L0
#srcline 123 ;  ShortTimeout(IN := Recv, PT := T#4s);     //timeout na zpravu
 LDX  Recv
#debug bool Recv
 WRX  ShortTimeout~IN
#debug_left bool ShortTimeout~IN
 LD   time 4000
 WRX  ShortTimeout~PT
#debug_left time ShortTimeout~PT
 LEAX ShortTimeout
 CAL  TON_L0
#srcline 124 ;  
#srcline 125 ;  //Get RTC
#srcline 126 ;  {asm}
#srcline 127
    #def  __SNTP_R0__ %R0
#srcline 128
    LEAX  NowTeco
#srcline 129
    LEA   __SNTP_R0__
#srcline 130
    SUB
#srcline 131
    SYS   3           ; //RDT -> nacist okamzity cas
#srcline 132
    LEAX  NowTeco
#srcline 133
    SYS   18          ; //konverze TTecoDateTime -> DATE_AND_TIME;
#srcline 134
    WRX   NowLocal
#srcline 135 ;  {end_asm}
#srcline 137 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbSntp_L7
#srcline 138 ;    Now := LREAL_TO_DT(DT_TO_LREAL(NowLocal) - DINT_TO_LREAL((INT_TO_DINT(UtcOff)+BOOL_TO_DINT(%S35.6)*60)*60) + 2208988800.0); //korekce na UTC
 LDX  NowLocal
#debug dt NowLocal
 LDX  UtcOff
#debug int UtcOff
 EXTW 
 EXTW
 LD   %S35.6
 AND  1
 LD   dint 60
 MULS
 ADD
 LD   dint 60
 MULS
 ILDF
 SUDF
 LDQ  lreal 2208988800.0
 ADDF
 WRX  Now
#debug_left dt Now
#srcline 139 ;    //pointery pro obraceni dwordu
#srcline 140 ;    pu := ADR(NtpPacket.RootDelay);
 LEAX NtpPacket
 ADD  4  ; + offset 
#debug pointer NtpPacket.RootDelay
 LEAY pu
 WRIL 
#debug_left pointer pu
#srcline 141 ;    pue := ADR(NtpPacket.TransmitTSFrac);
 LEAX NtpPacket
 ADD  44  ; + offset 
#debug pointer NtpPacket.TransmitTSFrac
 LEAY pue
 WRIL 
#debug_left pointer pue
#srcline 143 ;    IF Recv THEN
 LDX  Recv
#debug bool Recv
 JMC  fbSntp_L9
#srcline 144 ;      RecvFrom(rq := true, chanCode := chanCode, lenRx := SIZEOF(NtpPacket), data := void(NtpPacket));
 LD   bool -1       ; true
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   48  ; SizeOf()
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX NtpPacket
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 145 ;      IF RecvFrom.mesRec THEN
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbSntp_L11
#srcline 146 ;        //obracenÌ dword
#srcline 147 ;        WHILE PTR_TO_UDINT(pu) <> PTR_TO_UDINT(pue) DO
fbSntp_L13:
 LEAY pu
 LDIL 
#debug pointer pu
 LEAY pue
 LDIL 
#debug pointer pue
 EQ
 NEG
 JMC  fbSntp_L14
 DBG 
#srcline 148 ;          {asm}
#srcline 149
            ldy pu
#srcline 150
            ldil
#srcline 151
            swp
#srcline 152
            swl
#srcline 153
            swp
#srcline 154
            ldy pu
#srcline 155
            wril
#srcline 156 ;          {end_asm}
#srcline 157 ;          pu := pu + 4;
 LEAY pu
 LDIL 
#debug pointer pu
 LD   udint 4
 ADD
 LEAY pu
 WRIL 
#debug_left pointer pu
#srcline 158 ;        END_WHILE;
 JMP  fbSntp_L13
fbSntp_L14:
 NOP  -1
#srcline 160 ;        //prepocet casu
#srcline 161 ;        ReceiveTime   := UDINT_TO_LREAL(NtpPacket.ReceiveTS)+UDINT_TO_LREAL(NtpPacket.ReceiveTSFrac)/4294967296.0;
 LDX  NtpPacket~ReceiveTS
#debug udint NtpPacket.ReceiveTS
 ULDF
 LDX  NtpPacket~ReceiveTSFrac
#debug udint NtpPacket.ReceiveTSFrac
 ULDF
 LDQ  lreal 4294967296.0
 DIDF
 ADDF
 WRY  ReceiveTime
#debug_left lreal ReceiveTime
#srcline 162 ;        TransmitTime  := UDINT_TO_LREAL(NtpPacket.TransmitTS)+UDINT_TO_LREAL(NtpPacket.TransmitTSFrac)/4294967296.0;
 LDX  NtpPacket~TransmitTS
#debug udint NtpPacket.TransmitTS
 ULDF
 LDX  NtpPacket~TransmitTSFrac
#debug udint NtpPacket.TransmitTSFrac
 ULDF
 LDQ  lreal 4294967296.0
 DIDF
 ADDF
 WRY  TransmitTime
#debug_left lreal TransmitTime
#srcline 163 ;        OriginateTime := UDINT_TO_LREAL(NtpPacket.OriginateTS)+UDINT_TO_LREAL(NtpPacket.OriginateTSFrac)/4294967296.0;
 LDX  NtpPacket~OriginateTS
#debug udint NtpPacket.OriginateTS
 ULDF
 LDX  NtpPacket~OriginateTSFrac
#debug udint NtpPacket.OriginateTSFrac
 ULDF
 LDQ  lreal 4294967296.0
 DIDF
 ADDF
 WRY  OriginateTime
#debug_left lreal OriginateTime
#srcline 165 ;        Recv := false; //prepnout na vysilani
 LD   bool 0       ; false
 WRX  Recv
#debug_left bool Recv
#srcline 167 ;        IF (TransmitTime - ReceiveTime) < (DT_TO_LREAL(Now) - OriginateTime) THEN
 LDY  TransmitTime
#debug lreal TransmitTime
 LDY  ReceiveTime
#debug lreal ReceiveTime
 SUDF
 LDX  Now
#debug dt Now
 LDY  OriginateTime
#debug lreal OriginateTime
 SUDF
 LTDF
 JMC  fbSntp_L15
#srcline 168 ;          //vypocet offsetu
#srcline 169 ;          x := ReceiveTime - OriginateTime;
 LDY  ReceiveTime
#debug lreal ReceiveTime
 LDY  OriginateTime
#debug lreal OriginateTime
 SUDF
 WRY  x
#debug_left lreal x
#srcline 170 ;          IF TransmitTime = 0.0 THEN
 LDY  TransmitTime
#debug lreal TransmitTime
 LDQ  lreal 0.0
 EQDF
 JMC  fbSntp_L17
#srcline 171 ;            y := 0.0;
 LDQ  lreal 0.0
 WRY  y
#debug_left lreal y
#srcline 172 ;          ELSE
 JMP  fbSntp_L18
fbSntp_L17:
#srcline 173 ;            y := TransmitTime - DT_TO_LREAL(Now);
 LDY  TransmitTime
#debug lreal TransmitTime
 LDX  Now
#debug dt Now
 SUDF
 WRY  y
#debug_left lreal y
#srcline 174 ;          END_IF;
fbSntp_L18:
#srcline 175 ;          tmpoff  := 0.5*(x+y);
 LDQ  lreal 0.5
 LDY  x
#debug lreal x
 LDY  y
#debug lreal y
 ADDF
 MUDF
 WRY  tmpoff
#debug_left lreal tmpoff
#srcline 176 ;          tmperr  := x - y;
 LDY  x
#debug lreal x
 LDY  y
#debug lreal y
 SUDF
 WRY  tmperr
#debug_left lreal tmperr
#srcline 177 ;          x    := DT_TO_LREAL(Now) - OriginateTime;
 LDX  Now
#debug dt Now
 LDY  OriginateTime
#debug lreal OriginateTime
 SUDF
 WRY  x
#debug_left lreal x
#srcline 178 ;          tmperr  := max(tmperr, 0.5*x);
 LDY  tmperr
#debug lreal tmperr
 LDQ  lreal 0.5
 LDY  x
#debug lreal x
 MUDF
 MAXD
 WRY  tmperr
#debug_left lreal tmperr
#srcline 180 ;          IF tmperr < Error THEN //vzit ten s nejmesi chybou
 LDY  tmperr
#debug lreal tmperr
 LDX  Error
#debug lreal Error
 LTDF
 JMC  fbSntp_L19
#srcline 181 ;            Error  := tmperr;
 LDY  tmperr
#debug lreal tmperr
 WRX  Error
#debug_left lreal Error
#srcline 182 ;            Offset := tmpoff;
 LDY  tmpoff
#debug lreal tmpoff
 WRX  Offset
#debug_left lreal Offset
#srcline 183 ;          END_IF;
fbSntp_L19:
#srcline 184 ;          Success := Success + 1;
 LDX  Success
#debug udint Success
 LD   udint 1
 ADD
 WRX  Success
#debug_left udint Success
#srcline 185 ;        END_IF;
fbSntp_L15:
#srcline 186 ;      END_IF;
fbSntp_L11:
#srcline 187 ;    ELSE
 JMP  fbSntp_L10
fbSntp_L9:
#srcline 188 ;      IF attemps > 0 THEN
 LDX  attemps
#debug udint attemps
 LD   udint 0
 GT
 JMC  fbSntp_L21
#srcline 189 ;        attemps := attemps - 1;
 LDX  attemps
#debug udint attemps
 LD   udint 1
 SUB
 WRX  attemps
#debug_left udint attemps
#srcline 191 ;        NtpPacket := _fbSntp_EMPTY_NTP_MESSAGE_;
 LEA  __Const__fbSntp__fbSntp_EMPTY_NTP_MESSAGE_
#debug pointer _fbSntp_EMPTY_NTP_MESSAGE_
 SRC  %IB0
 LEAX NtpPacket
#debug_left pointer NtpPacket
 LD   48   ;SizeOf() 
 MOV  %IB0
#srcline 193 ;        NtpPacket.TransmitTS := LREAL_TO_UDINT(DATE_AND_TIME_TO_LREAL(Now)-0.5);
 LDX  Now
#debug dt Now
 LDQ  lreal 0.5
 SUDF
 RNDD
 UDFL
 WRX  NtpPacket~TransmitTS
#debug_left udint NtpPacket.TransmitTS
#srcline 194 ;        NtpPacket.TransmitTSFrac := DWORD_TO_UDINT(SHL(UDINT_TO_DWORD(UINT_TO_UDINT(NowMili)*65536/1000),16));
 LDX  NowMili
#debug uint NowMili
 LD   udint 65536
 MUL
 LD   udint 1000
 DIVL
 LD   uint 16
 SHL
 WRX  NtpPacket~TransmitTSFrac
#debug_left udint NtpPacket.TransmitTSFrac
#srcline 196 ;        //obracenÌ dword
#srcline 197 ;        WHILE PTR_TO_UDINT(pu) <> PTR_TO_UDINT(pue) DO
fbSntp_L23:
 LEAY pu
 LDIL 
#debug pointer pu
 LEAY pue
 LDIL 
#debug pointer pue
 EQ
 NEG
 JMC  fbSntp_L24
 DBG 
#srcline 198 ;          {asm}
#srcline 199
            ldy pu
#srcline 200
            ldil
#srcline 201
            swp
#srcline 202
            swl
#srcline 203
            swp
#srcline 204
            ldy pu
#srcline 205
            wril
#srcline 206 ;          {end_asm}
#srcline 207 ;          pu := pu + 4;
 LEAY pu
 LDIL 
#debug pointer pu
 LD   udint 4
 ADD
 LEAY pu
 WRIL 
#debug_left pointer pu
#srcline 208 ;        END_WHILE;
 JMP  fbSntp_L23
fbSntp_L24:
 NOP  -1
#srcline 210 ;        SendTo(rq := true, chanCode := chanCode, lenTx := SIZEOF(NtpPacket), data := void(NtpPacket));
 LD   bool -1       ; true
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LD   48  ; SizeOf()
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX NtpPacket
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 211 ;        Recv := true; //cekat na prijem
 LD   bool -1       ; true
 WRX  Recv
#debug_left bool Recv
#srcline 212 ;      ELSE
 JMP  fbSntp_L22
fbSntp_L21:
#srcline 213 ;        Done := Success > 2 OR Error < 3600.0;
 LDX  Success
#debug udint Success
 LD   udint 2
 GT
 LDX  Error
#debug lreal Error
 LDQ  lreal 3600.0
 LTDF
 OR  
 WRX  Done
#debug_left bool Done
#srcline 214 ;        Busy := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 215 ;        IF NOT Done THEN
 LDX  Done
#debug bool Done
 NEG
 JMC  fbSntp_L25
#srcline 216 ;          Err   := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 217 ;          ErrId := 2;
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
#srcline 218 ;        END_IF;
fbSntp_L25:
#srcline 219 ;      END_IF;
fbSntp_L22:
#srcline 220 ;    END_IF;
fbSntp_L10:
#srcline 221 ;  END_IF;
fbSntp_L7:
#srcline 223 ;  IF Accept & NOT Busy & NOT Err & NOT TimeSet THEN
 LDX  Accept
#debug bool Accept
 LDX  Busy
#debug bool Busy
 NEG
 AND
 LDX  Err
#debug bool Err
 NEG
 AND
 LDX  TimeSet
#debug bool TimeSet
 NEG
 AND
 JMC  fbSntp_L27
#srcline 224 ;    SettingTime := true;
 LD   bool -1       ; true
 WRX  SettingTime
#debug_left bool SettingTime
#srcline 225 ;    maxSW22     := %SW22;
 LD   %SW22
 WRX  maxSW22
#debug_left uint maxSW22
#srcline 226 ;  END_IF;
fbSntp_L27:
#srcline 227 ;  
#srcline 228 ;  IF SettingTime THEN
 LDX  SettingTime
#debug bool SettingTime
 JMC  fbSntp_L29
#srcline 229 ;    maxSW22 := max(maxSW22,%SW22);
 LDX  maxSW22
#debug uint maxSW22
 LD   %SW22
 MAX
 WRX  maxSW22
#debug_left uint maxSW22
#srcline 230 ;    NowLocal := LREAL_TO_DT(DT_TO_LREAL(NowLocal) + Offset);
 LDX  NowLocal
#debug dt NowLocal
 LDX  Offset
#debug lreal Offset
 ADDF
 WRX  NowLocal
#debug_left dt NowLocal
#srcline 231 ;    IF (UINT_TO_LREAL(maxSW22) * 0.0001) > (DT_TO_LREAL(NowLocal) - UDINT_TO_LREAL(TRUNC(DT_TO_LREAL(NowLocal)))) THEN
 LDX  maxSW22
#debug uint maxSW22
 ULDF
 LDQ  lreal 0.0001
 MUDF
 LDX  NowLocal
#debug dt NowLocal
 LDX  NowLocal
#debug dt NowLocal
 FLOD
 UDFL
 ULDF
 SUDF
 GTDF
 JMC  fbSntp_L31
#srcline 232 ;      Offset := 0.0;
 LDQ  lreal 0.0
 WRX  Offset
#debug_left lreal Offset
#srcline 233 ;      SettingTime := false;
 LD   bool 0       ; false
 WRX  SettingTime
#debug_left bool SettingTime
#srcline 234 ;      TimeSet     := true;
 LD   bool -1       ; true
 WRX  TimeSet
#debug_left bool TimeSet
#srcline 235 ;      {ASM}
#srcline 236
        LEAX  NowTeco
#srcline 237
        LDX   NowLocal
#srcline 238
        SYS   19                ;//konverze DATE_AND_TIME -> TTecoDateTime
#srcline 239
        LEAX  NowTeco
#srcline 240
        LEA   __SNTP_R0__
#srcline 241
        SUB
#srcline 242
        SYS   4                 ;//WRT -> nacist okamzity cas
#srcline 243 ;      {END_ASM}
#srcline 244 ;    END_IF;
fbSntp_L31:
#srcline 245 ;  END_IF;
fbSntp_L29:
#srcline 247 ;  IF Timeout.Q THEN
 LDX  Timeout~Q
#debug bool Timeout.Q
 JMC  fbSntp_L33
#srcline 248 ;    Busy  := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 249 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 250 ;    ErrId := 1;
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
#srcline 251 ;  END_IF;
fbSntp_L33:
#srcline 253 ;  Recv := Recv XOR (ShortTimeout.Q AND Attemps > 0);  //dosel timeout a je co vysilat prejit do vysilani
 LDX  Recv
#debug bool Recv
 LDX  ShortTimeout~Q
#debug bool ShortTimeout.Q
 LDX  Attemps
#debug udint Attemps
 LD   udint 0
 GT
 AND
 XOR 
 WRX  Recv
#debug_left bool Recv
#srcline 255 ;END_FUNCTION_BLOCK
fbSntp_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbSntp__InstanceInit__:
 LINK 0
 LD   uint 123
 WRX  port
 LD   0
 SRC  byte __Init___fbSntp_NtpPacket
 LEAX byte NtpPacket
 LD   48
 MOV  %X0
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBNSLOOKUPBYTABLE.ST'
#pou fbNsLookUpByTable
#srcline 15 ;FUNCTION_BLOCK fbNsLookUpByTable

#struct fbNsLookUpByTable__temp__
  uint P0__st__
P     61
fbNsLookUpByTable_L0:
 LINK __SizeOf(fbNsLookUpByTable__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 40 ;  NsLookUp(getIP := Busy, chanCode := chanCode,
 LDX  Busy
#debug bool Busy
 WRX  NsLookUp~getIP
#debug_left bool NsLookUp~getIP
 LDX  chanCode
#debug uint chanCode
 WRX  NsLookUp~chanCode
#debug_left uint NsLookUp~chanCode
#srcline 41 ;           Err => NsLookUpItem.Err,
#srcline 42 ;           ErrId => ErrId,
#srcline 43 ;           Done => NsLookUpItem.Done,
#srcline 44 ;           Name := NsLookUpItem.Name,
 LEAX NsLookUpItem
 ADD  5  ; + offset 
 WRX  NsLookUp~Name
#debug_left pointer NsLookUp.Name
#srcline 45 ;           DnsIP := DnsIP,
 LEAX DnsIP
#debug pointer DnsIP
 SRC  %IB0
 LEAX NsLookUp~DnsIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 46 ;           IP := NsLookUpItem.IP);
 LEAX NsLookUpItem
 ADD  1  ; + offset 
 WRX  NsLookUp~IP
#debug_left pointer NsLookUp.IP
 LEAX NsLookUp
 CAL  fbNsLookUp_L0
; output assigment 
 LDX  NsLookUp~Err
#debug bool NsLookUp~Err
 WRX  NsLookUpItem~Err
#debug_left bool NsLookUpItem.Err
 LDX  NsLookUp~ErrId
#debug usint NsLookUp~ErrId
 WRX  ErrId
#debug_left usint ErrId
 LDX  NsLookUp~Done
#debug bool NsLookUp~Done
 WRX  NsLookUpItem~Done
#debug_left bool NsLookUpItem.Done
#srcline 48 ;  Err := NsLookUpItem.Err;
 LDX  NsLookUpItem~Err
#debug bool NsLookUpItem.Err
 WRX  Err
#debug_left bool Err
#srcline 50 ;  //nic se nedeje hledame pozadavky
#srcline 51 ;  IF NOT Busy THEN
 LDX  Busy
#debug bool Busy
 NEG
 JMC  fbNsLookUpByTable_L1
#srcline 52 ;    FOR i := 0 TO 15 DO
 LD   uint 0
 WRX  i
 LD   uint 15
 WRY  P0__st__
fbNsLookUpByTable_L3:
 LDX  i
 LDY  P0__st__
 GT   
 JMD  fbNsLookUpByTable_L4
 DBG  
#srcline 53 ;      //smazat vsechny priznaky Done
#srcline 54 ;      NsLookUpTable[i].Done := false;
 LD   bool 0       ; false
 LDX  NsLookUpTable
 LDX  i
#debug uint i
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  2   ; Bool offset 
 WRIB 
#debug_left bool NsLookUpTable[i].Done
#srcline 55 ;      //zjistit jestli je zadost
#srcline 56 ;      IF NsLookUpTable[i].Request & NOT Busy THEN
 LDX  NsLookUpTable
 LDX  i
#debug uint i
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
 MUL  8   ; -> bool pointer 
 LDIB 
#debug bool NsLookUpTable[i].Request
 LDX  Busy
#debug bool Busy
 NEG
 AND
 JMC  fbNsLookUpByTable_L5
#srcline 57 ;        //je-li zadost nastavit polozku a busy
#srcline 58 ;        NsLookUpTable[i].Request := false;
 LD   bool 0       ; false
 LDX  NsLookUpTable
 LDX  i
#debug uint i
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
 MUL  8   ; -> bool pointer 
 WRIB 
#debug_left bool NsLookUpTable[i].Request
#srcline 59 ;        NsLookUpTable[i].Set     := false;
 LD   bool 0       ; false
 LDX  NsLookUpTable
 LDX  i
#debug uint i
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  1   ; Bool offset 
 WRIB 
#debug_left bool NsLookUpTable[i].Set
#srcline 60 ;        NsLookUpItem := NsLookUpTable[i];
 LDX  NsLookUpTable
 LDX  i
#debug uint i
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
#debug pointer NsLookUpTable[i]
 SRC  %IB0
 LEAX NsLookUpItem
#debug_left pointer NsLookUpItem
 LD   86   ;SizeOf() 
 MOV  %IB0
#srcline 61 ;        Busy := true; NsLookUp.Err := false;
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
 LD   bool 0       ; false
 WRX  NsLookUp~Err
#debug_left bool NsLookUp.Err
#srcline 62 ;        j := i;
 LDX  i
#debug uint i
 WRX  j
#debug_left uint j
#srcline 63 ;      END_IF;
fbNsLookUpByTable_L5:
#srcline 64 ;    END_FOR;
 LDX  i
 LD   1
 ADD  
 WRX  i
 JMP  fbNsLookUpByTable_L3
fbNsLookUpByTable_L4:
 NOP  -1
#srcline 65 ;  END_IF;
fbNsLookUpByTable_L1:
#srcline 67 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbNsLookUpByTable_L7
#srcline 68 ;    //ziskali jsme IP adresu - hotovo
#srcline 69 ;    IF NsLookUp.Done OR NsLookUp.Err THEN
 LDX  NsLookUp~Done
#debug bool NsLookUp.Done
 LDX  NsLookUp~Err
#debug bool NsLookUp.Err
 OR  
 JMC  fbNsLookUpByTable_L9
#srcline 70 ;      NsLookUpItem.Set := NsLookUp.Done;
 LDX  NsLookUp~Done
#debug bool NsLookUp.Done
 WRX  NsLookUpItem~Set
#debug_left bool NsLookUpItem.Set
#srcline 71 ;      NsLookUpTable[j] := NsLookUpItem;
 LEAX NsLookUpItem
#debug pointer NsLookUpItem
 SRC  %IB0
 LDX  NsLookUpTable
 LDX  j
#debug uint j
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
#debug_left pointer NsLookUpTable[j]
 LD   86   ;SizeOf() 
 MOV  %IB0
#srcline 72 ;      Err              := NsLookUp.Err;
 LDX  NsLookUp~Err
#debug bool NsLookUp.Err
 WRX  Err
#debug_left bool Err
#srcline 73 ;      Busy             := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 74 ;    END_IF;
fbNsLookUpByTable_L9:
#srcline 75 ;  END_IF;
fbNsLookUpByTable_L7:
#srcline 78 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbNsLookUpByTable__InstanceInit__:
 LINK 0
 LEAX NsLookUp
 CAL  fbNsLookUp__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBFTP.ST'
#pou fbStoreToFtp
#srcline 28 ;FUNCTION_BLOCK fbStoreToFtp
#table byte __Init___fbStoreToFtp_h = 
      0,  0;

#struct fbStoreToFtp__temp__
  TUniDesc UniDescCom,
  uint tmpReplyCode,
  udint tmpud,
  pointer pStr,
  uint iPos,
  uint iIdx,
  string[2] endLocal,
  string[2] endRemot,
  uint ReplyCodeClass,
  usint P0__st__,
  usint P1__st__,
  string[257] PS0__st__
#data byte _str_fbStoreToFtp_0 = 
  'U','S','E','R',' ',0
#data byte _str_fbStoreToFtp_1 = 
  'P','A','S','S',' ',0
#data byte _str_fbStoreToFtp_2 = 
  'T','Y','P','E',' ','I',0
#data byte _str_fbStoreToFtp_3 = 
  'P','A','S','V',$0D,$0A,0
#data byte _str_fbStoreToFtp_4 = 
  '(',0
#data byte _str_fbStoreToFtp_5 = 
  ',',0
#data byte _str_fbStoreToFtp_6 = 
  'S','T','O','R',' ',0
#data byte _str_fbStoreToFtp_7 = 
  '/',0
#data byte _str_fbStoreToFtp_8 = 
  '/',0
#data byte _str_fbStoreToFtp_9 = 
  '/',0
#data byte _str_fbStoreToFtp_10 = 
  'M','K','D',' ',0
#data byte _str_fbStoreToFtp_11 = 
  'Q','U','I','T',0
P     61
fbStoreToFtp_L0:
 LINK __SizeOf(fbStoreToFtp__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pStr
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Send
 LETX __EDGE_R__Send
 WRX  Send
#srcline 104 ;  UniDescCom := GetChanDesc(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDescCom
#debug_left pointer UniDescCom
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 105 ;  IF (UniDescCom.modeChan <> 5) OR (UniDescCom.lenUniIn <> 259) OR (UniDescCom.lenUniOut < 259) THEN
 LDY  UniDescCom~modeChan
#debug byte UniDescCom.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDescCom~lenUniIn
#debug uint UniDescCom.lenUniIn
 LD   uint 259
 EQ
 NEG
 OR  
 LDY  UniDescCom~lenUniOut
#debug uint UniDescCom.lenUniOut
 LD   uint 259
 LT
 OR  
 JMC  fbStoreToFtp_L1
#srcline 106 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 107 ;    ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 108 ;    RETURN;
 JMP  fbStoreToFtp_RET
#srcline 109 ;  END_IF;
fbStoreToFtp_L1:
#srcline 111 ;  UniDescCom := GetChanDesc(chanCode := chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDescCom
#debug_left pointer UniDescCom
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 112 ;  IF (UniDescCom.modeChan <> 5) OR (UniDescCom.lenUniOut < 259) THEN
 LDY  UniDescCom~modeChan
#debug byte UniDescCom.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDescCom~lenUniOut
#debug uint UniDescCom.lenUniOut
 LD   uint 259
 LT
 OR  
 JMC  fbStoreToFtp_L3
#srcline 113 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 114 ;    ErrId := 253;
 LD   usint 253
 WRX  ErrId
#debug_left usint ErrId
#srcline 115 ;    RETURN;
 JMP  fbStoreToFtp_RET
#srcline 116 ;  END_IF;
fbStoreToFtp_L3:
#srcline 118 ;  Err   := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 119 ;  Done  := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 121 ;  timeoutCom(PT := T#30s); //timeout
 LD   time 30000
 WRX  timeoutCom~PT
#debug_left time timeoutCom~PT
 LEAX timeoutCom
 CAL  TON_L0
#srcline 122 ;  KeepAliveTCP(rq := State = fss_TxData, chanCode := chanCodeCom, PT := T#30s);
 LDX  State
#debug usint State
 LD   udint 17  ; TFtpStoreState#fss_TxData
 EQ
 WRX  KeepAliveTCP~rq
#debug_left bool KeepAliveTCP~rq
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  KeepAliveTCP~chanCode
#debug_left uint KeepAliveTCP~chanCode
 LD   time 30000
 WRX  KeepAliveTCP~PT
#debug_left time KeepAliveTCP~PT
 LEAX KeepAliveTCP
 CAL  fbKeepAliveTCP_L0
#srcline 124 ;  IF timeoutCom.Q THEN
 LDX  timeoutCom~Q
#debug bool timeoutCom.Q
 JMC  fbStoreToFtp_L5
#srcline 125 ;    state  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
#srcline 126 ;    eErrId := 1;
 LD   usint 1
 WRX  eErrId
#debug_left usint eErrId
#srcline 127 ;  END_IF;
fbStoreToFtp_L5:
#srcline 129 ;  IF NOT TRO THEN
 LDX  TRO
#debug bool TRO
 NEG
 JMC  fbStoreToFtp_L7
#srcline 130 ;    if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L9
#srcline 131 ;      tmpReplyCode := STRING_TO_UINT(cmdCom);
 LEAX cmdCom
#debug string cmdCom
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 WRY  tmpReplyCode
#debug_left uint tmpReplyCode
#srcline 132 ;      ReplyCodeClass := tmpReplyCode / 100;
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 100
 DIVL
 AND  $FFFF
 WRY  ReplyCodeClass
#debug_left uint ReplyCodeClass
#srcline 133 ;      IF Busy AND NOT Err THEN
 LDX  Busy
#debug bool Busy
 LDX  Err
#debug bool Err
 NEG
 AND
 JMC  fbStoreToFtp_L11
#srcline 134 ;        ReplyCode := tmpReplyCode;
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 135 ;      END_IF;
fbStoreToFtp_L11:
#srcline 136 ;    end_if;
fbStoreToFtp_L9:
#srcline 138 ;    CASE state OF
 LDX  state
#debug usint state
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L14
#srcline 139 ;      // inicializace ------------------------------------------------------------
#srcline 140 ;      fss_Init :
#srcline 141 ;        busy        := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 142 ;        state       := fss_Idle;
 LD   udint 1  ; TFtpStoreState#fss_Idle
 WRX  state
#debug_left usint state
#srcline 143 ;        // nenavazovat spojeni
#srcline 144 ;        CloseTCPconnection(chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 145 ;        CloseTCPconnection(chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 146 ;        IF h <> INVALID_HANDLE_VALUE THEN
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L15
#srcline 147 ;          FileClose(hFile := h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 148 ;          h := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  h
#debug_left udint h
#srcline 149 ;        END_IF;
fbStoreToFtp_L15:
#srcline 151 ;        FOR i := 0 TO dirStackLev DO
 LD   usint 0
 WRX  i
 LDX  dirStackLev
#debug usint dirStackLev
 WRY  P1__st__
fbStoreToFtp_L17:
 LDX  i
 LDY  P1__st__
 GT   
 JMD  fbStoreToFtp_L18
 DBG  
#srcline 152 ;          IF dirStack[i].hDir <> INVALID_HANDLE_VALUE THEN
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[i].hDir
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L19
#srcline 153 ;            DirClose(hDir := dirStack[i].hDir);
 NXT
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[i].hDir
 WR   __Instance__DirClose~hDir
#debug_left udint __Instance__DirClose~hDir
 PRV
 LEA  __Instance__DirClose
 CAL  DirClose_L0
#srcline 154 ;            dirStack[i].hDir := INVALID_HANDLE_VALUE;
 LD   udint 0
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 WRIL 
#debug_left udint dirStack[i].hDir
#srcline 155 ;            dirStack[i].sDir := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string dirStack[i].sDir
 PDST   ; Level 1
#srcline 156 ;          END_IF;
fbStoreToFtp_L19:
#srcline 157 ;        END_FOR;
 LDX  i
 LD   1
 ADD  
 WRX  i
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L18:
 NOP  -1
#srcline 159 ;        dirStackLev := 0;
 LD   usint 0
 WRX  dirStackLev
#debug_left usint dirStackLev
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L14:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L21
#srcline 161 ;      // cekani na start ---------------------------------------------------------
#srcline 162 ;      fss_Idle :
#srcline 163 ;        if Send then
 LDX  Send
#debug bool Send
 JMC  fbStoreToFtp_L22
#srcline 164 ;          // vycistime prijimaci a vysilaci buffer
#srcline 165 ;          Recv_From_Com.rq  := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 166 ;          //Send_To_Com.rq    := 0;
#srcline 167 ;          Send_To_Com.lenTx := 0;
 LD   uint 0
 WRX  Send_To_Com~lenTx
#debug_left uint Send_To_Com.lenTx
#srcline 168 ;          state             := fss_OpenFile;
 LD   udint 2  ; TFtpStoreState#fss_OpenFile
 WRX  state
#debug_left usint state
#srcline 169 ;          busy              := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 170 ;          ErrId             := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 171 ;          eErrId            := 0;
 LD   usint 0
 WRX  eErrId
#debug_left usint eErrId
#srcline 172 ;          ReplyCode         := 0;
 LD   uint 0
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 173 ;          lRemotName        := RemotName;   //ulozit vzdalene jmeno
 LD   0   ; null string
 LEAX lRemotName
 WRI  
 LEAX lRemotName
 LD   80
 DST    ; Level 1
 LDX  RemotName
#debug string RemotName
 SCON 
#debug_left string lRemotName
 PDST   ; Level 1
#srcline 174 ;          idPos             := 0;
 LD   udint 0
 WRX  idPos
#debug_left udint idPos
#srcline 175 ;          Progress          := 0;
 LD   usint 0
 WRX  Progress
#debug_left usint Progress
#srcline 176 ;          _FindNextPathSeparator(In := lRemotName, Pos := idPos);
 NXT
 LEAX lRemotName
 WR   __Instance___FindNextPathSeparator~In
#debug_left pointer __Instance___FindNextPathSeparator.In
 LEAX idPos
 WR   __Instance___FindNextPathSeparator~Pos
#debug_left pointer __Instance___FindNextPathSeparator.Pos
 PRV
 LEA  __Instance___FindNextPathSeparator
 CAL  _FindNextPathSeparator_L0
#srcline 177 ;        end_if;
fbStoreToFtp_L22:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L21:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L24
#srcline 178 ;      // nastavit IP
#srcline 179 ;      fss_IpCom :
#srcline 180 ;        IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbStoreToFtp_L25
#srcline 181 ;          Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 182 ;          ErrId  := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 183 ;          state  := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
#srcline 184 ;        ELSE
 JMP  fbStoreToFtp_L26
fbStoreToFtp_L25:
#srcline 185 ;          rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAX rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 186 ;          rea.remotePort := port;
 LDX  port
#debug uint port
 WRX  rea~remotePort
#debug_left uint rea.remotePort
#srcline 187 ;          rea.localPort  := 0;
 LD   uint 0
 WRX  rea~localPort
#debug_left uint rea.localPort
#srcline 188 ;          IF SetRemoteIPaddress(rq := 1, chanCode := chanCodeCom, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbStoreToFtp_L27
#srcline 189 ;            state := fss_Connect;
 LD   udint 4  ; TFtpStoreState#fss_Connect
 WRX  state
#debug_left usint state
#srcline 190 ;          END_IF;
fbStoreToFtp_L27:
#srcline 191 ;        END_IF;
fbStoreToFtp_L26:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L24:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L29
#srcline 192 ;      fss_Connect :
#srcline 193 ;        EstabTCPconnection(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 194 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 195 ;        IF IsEstabTCPconnection(chanCode := chanCodeCom) THEN
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbStoreToFtp_L30
#srcline 196 ;          state := fss_Rx220;
 LD   udint 5  ; TFtpStoreState#fss_Rx220
 WRX  state
#debug_left usint state
#srcline 197 ;        END_IF;
fbStoreToFtp_L30:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L29:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L32
#srcline 198 ;      fss_Rx220 :
#srcline 199 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L33
#srcline 200 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 201 ;          IF tmpReplyCode = 220 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 220
 EQ
 JMC  fbStoreToFtp_L35
#srcline 202 ;            state := fss_TxUser;
 LD   udint 6  ; TFtpStoreState#fss_TxUser
 WRX  state
#debug_left usint state
#srcline 203 ;          ELSE
 JMP  fbStoreToFtp_L36
fbStoreToFtp_L35:
#srcline 204 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 205 ;          END_IF;
fbStoreToFtp_L36:
#srcline 206 ;        END_IF;
fbStoreToFtp_L33:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L32:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L37
#srcline 207 ;      fss_TxUser:
#srcline 208 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 209 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 210 ;        cmdCom := 'USER ' + User + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_0
 SCON 
 LDX  User
#debug string User
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 211 ;        state := fss_RxUser;
 LD   udint 7  ; TFtpStoreState#fss_RxUser
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L37:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L38
#srcline 212 ;      fss_RxUser:
#srcline 213 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L39
#srcline 214 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 215 ;          IF tmpReplyCode = 331 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 331
 EQ
 JMC  fbStoreToFtp_L41
#srcline 216 ;            state := fss_TxPass;
 LD   udint 8  ; TFtpStoreState#fss_TxPass
 WRX  state
#debug_left usint state
#srcline 217 ;          ELSE
 JMP  fbStoreToFtp_L42
fbStoreToFtp_L41:
#srcline 218 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 219 ;          END_IF;
fbStoreToFtp_L42:
#srcline 220 ;        END_IF;
fbStoreToFtp_L39:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L38:
 LD   8
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L43
#srcline 221 ;      fss_TxPass:
#srcline 222 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 223 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 224 ;        cmdCom := 'PASS ' + Pass + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_1
 SCON 
 LDX  Pass
#debug string Pass
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 225 ;        state := fss_RxPass;
 LD   udint 9  ; TFtpStoreState#fss_RxPass
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L43:
 LD   9
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L44
#srcline 226 ;      fss_RxPass:
#srcline 227 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L45
#srcline 228 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 229 ;          IF tmpReplyCode = 230 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 230
 EQ
 JMC  fbStoreToFtp_L47
#srcline 230 ;            state := fss_TxType;
 LD   udint 10  ; TFtpStoreState#fss_TxType
 WRX  state
#debug_left usint state
#srcline 231 ;          ELSE
 JMP  fbStoreToFtp_L48
fbStoreToFtp_L47:
#srcline 232 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 233 ;          END_IF;
fbStoreToFtp_L48:
#srcline 234 ;        END_IF;
fbStoreToFtp_L45:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L44:
 LD   10
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L49
#srcline 235 ;      fss_TxType:
#srcline 236 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 237 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 238 ;        cmdCom := 'TYPE I' + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_2
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 239 ;        state := fss_RxType;
 LD   udint 11  ; TFtpStoreState#fss_RxType
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L49:
 LD   11
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L50
#srcline 240 ;      fss_RxType:
#srcline 241 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L51
#srcline 242 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 243 ;          IF tmpReplyCode = 200 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 200
 EQ
 JMC  fbStoreToFtp_L53
#srcline 244 ;            state := fss_TxPasv;
 LD   udint 12  ; TFtpStoreState#fss_TxPasv
 WRX  state
#debug_left usint state
#srcline 245 ;          ELSE
 JMP  fbStoreToFtp_L54
fbStoreToFtp_L53:
#srcline 246 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 247 ;          END_IF;
fbStoreToFtp_L54:
#srcline 248 ;        END_IF;
fbStoreToFtp_L51:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L50:
 LD   12
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L55
#srcline 249 ;      fss_TxPasv:
#srcline 250 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 251 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 252 ;        cmdCom := 'PASV$r$l';
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_3
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 253 ;        state := fss_RxPasv;
 LD   udint 13  ; TFtpStoreState#fss_RxPasv
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L55:
 LD   13
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L56
#srcline 254 ;      fss_RxPasv:
#srcline 255 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L57
#srcline 256 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 257 ;          IF tmpReplyCode = 227 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 227
 EQ
 JMC  fbStoreToFtp_L59
#srcline 258 ;            iPos := FIND(IN1 := cmdCom, IN2 := '(');
 LEAX cmdCom
#debug string cmdCom
 LEA  _str_fbStoreToFtp_4
 SFND 
 WRY  iPos
#debug_left uint iPos
#srcline 259 ;            pStr := ADR(cmdCom);
 LEAX cmdCom
#debug pointer cmdCom
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 260 ;            WHILE iPos > 0 & iIdx < 6 DO
fbStoreToFtp_L61:
 LDY  iPos
#debug uint iPos
 LD   uint 0
 GT
 LDY  iIdx
#debug uint iIdx
 LD   uint 6
 LT
 AND
 JMC  fbStoreToFtp_L62
 DBG 
#srcline 261 ;              pStr := pStr + UINT_TO_UDINT(iPos);
 LEAY pStr
 LDIL 
#debug pointer pStr
 LDY  iPos
#debug uint iPos
 ADD
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 262 ;              pasvDat[iIdx] := STRING_TO_USINT(pStr^);
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 LEAX pasvDat
 LDY  iIdx
#debug uint iIdx
 RCHK 5   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint pasvDat[iIdx]
#srcline 263 ;              iIdx := iIdx + 1;
 LDY  iIdx
#debug uint iIdx
 LD   uint 1
 ADD
 AND  $FFFF
 WRY  iIdx
#debug_left uint iIdx
#srcline 264 ;              iPos := FIND(IN1 := pStr^, IN2 := ',');
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 LEA  _str_fbStoreToFtp_5
 SFND 
 WRY  iPos
#debug_left uint iPos
#srcline 265 ;            END_WHILE;
 JMP  fbStoreToFtp_L61
fbStoreToFtp_L62:
 NOP  -1
#srcline 266 ;            state := fss_TxStor;
 LD   udint 14  ; TFtpStoreState#fss_TxStor
 WRX  state
#debug_left usint state
#srcline 267 ;          ELSE
 JMP  fbStoreToFtp_L60
fbStoreToFtp_L59:
#srcline 268 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 269 ;          END_IF;
fbStoreToFtp_L60:
#srcline 270 ;        END_IF;
fbStoreToFtp_L57:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L56:
 LD   14
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L63
#srcline 271 ;      fss_TxStor:
#srcline 272 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 273 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 274 ;        cmdCom := 'STOR ' + lRemotName + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_6
 SCON 
 LEAX lRemotName
#debug string lRemotName
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 275 ;        data   := 0;
 LD   udint 0
 WRX  data
#debug_left udint data
#srcline 276 ;        IF IsEstabTCPconnection(chanCode := chanCodeDat) THEN
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbStoreToFtp_L64
#srcline 277 ;          state  := fss_WaitForOpen;
 LD   udint 16  ; TFtpStoreState#fss_WaitForOpen
 WRX  state
#debug_left usint state
#srcline 278 ;        ELSE
 JMP  fbStoreToFtp_L65
fbStoreToFtp_L64:
#srcline 279 ;          state  := fss_IpDat;
 LD   udint 15  ; TFtpStoreState#fss_IpDat
 WRX  state
#debug_left usint state
#srcline 280 ;        END_IF;
fbStoreToFtp_L65:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L63:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L66
#srcline 281 ;      fss_OpenFile:
#srcline 282 ;        state  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
#srcline 283 ;        eErrId := 3;
 LD   usint 3
 WRX  eErrId
#debug_left usint eErrId
#srcline 284 ;        CurrFile := LocalName;
 LD   0   ; null string
 LEAX CurrFile
 WRI  
 LEAX CurrFile
 LD   80
 DST    ; Level 1
 LDX  LocalName
#debug string LocalName
 SCON 
#debug_left string CurrFile
 PDST   ; Level 1
#srcline 285 ;        h := FileOpen(fileName := LocalName, mode := F_READ);
 NXT
 LDX  LocalName
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 LD   udint 0  ; TF_MODE#F_READ
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  h
#debug_left udint h
#srcline 286 ;        IF h <> INVALID_HANDLE_VALUE THEN //je to soubor klasicky
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L67
#srcline 287 ;          lSize  := FileSize(hFile := h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileSize~hFile
#debug_left udint __Instance__FileSize~hFile
 PRV
 LEA  __Instance__FileSize
 CAL  FileSize_L0
 WRX  lSize
#debug_left udint lSize
#srcline 288 ;          state  := fss_IpCom;
 LD   udint 3  ; TFtpStoreState#fss_IpCom
 WRX  state
#debug_left usint state
#srcline 289 ;        ELSE
 JMP  fbStoreToFtp_L68
fbStoreToFtp_L67:
#srcline 290 ;          endLocal := RIGHT(LocalName,1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   1
 DST    ; Level 1
 LDX  LocalName
#debug string LocalName
 LD   1
 SRGT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY endLocal
 WRI  
 LEAY endLocal
 LD   1
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string endLocal
 PDST   ; Level 1
#srcline 291 ;          IF endLocal = '/' THEN
 LEAY endLocal
#debug string endLocal
 LEA  _str_fbStoreToFtp_7
 SCMP 
 EQ   0
 JMC  fbStoreToFtp_L69
#srcline 292 ;            endRemot := RIGHT(RemotName,1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   1
 DST    ; Level 1
 LDX  RemotName
#debug string RemotName
 LD   1
 SRGT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY endRemot
 WRI  
 LEAY endRemot
 LD   1
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string endRemot
 PDST   ; Level 1
#srcline 293 ;            IF endRemot = '/' THEN
 LEAY endRemot
#debug string endRemot
 LEA  _str_fbStoreToFtp_8
 SCMP 
 EQ   0
 JMC  fbStoreToFtp_L71
#srcline 294 ;              dirStack[0].hDir := DirOpen(dirName := LocalName, dirInfo := lLocalFileInfo);
 NXT
 LDX  LocalName
 WR   __Instance__DirOpen~dirName
#debug_left pointer __Instance__DirOpen.dirName
 LEAX lLocalFileInfo
 WR   __Instance__DirOpen~dirInfo
#debug_left pointer __Instance__DirOpen.dirInfo
 PRV
 LEA  __Instance__DirOpen
 CAL  DirOpen_L0
 LEAX dirStack
 WRIL 
#debug_left udint dirStack[0].hDir
#srcline 295 ;              IF dirStack[0].hDir <> INVALID_HANDLE_VALUE THEN
 LEAX dirStack
 LDIL 
#debug udint dirStack[0].hDir
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L73
#srcline 296 ;                iniDir    := true;
 LD   bool -1       ; true
 WRX  iniDir
#debug_left bool iniDir
#srcline 297 ;                state     := fss_ReadDir;
 LD   udint 26  ; TFtpStoreState#fss_ReadDir
 WRX  state
#debug_left usint state
#srcline 298 ;              END_IF;
fbStoreToFtp_L73:
#srcline 299 ;            ELSE
 JMP  fbStoreToFtp_L72
fbStoreToFtp_L71:
#srcline 300 ;              State  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  State
#debug_left usint State
#srcline 301 ;              eErrId := 7; //dest is not dir
 LD   usint 7
 WRX  eErrId
#debug_left usint eErrId
#srcline 302 ;            END_IF;
fbStoreToFtp_L72:
#srcline 303 ;          END_IF;
fbStoreToFtp_L69:
#srcline 304 ;        END_IF;
fbStoreToFtp_L68:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L66:
 LD   26
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L75
#srcline 305 ;      fss_ReadDir:
#srcline 306 ;        {$IFDEF _DEBUG}
#srcline 307 ;        Stop := true;
#srcline 308 ;        {$END_IF}
#srcline 310 ;        IF dirStack[dirStackLev].hDir <> INVALID_HANDLE_VALUE THEN //je adresar
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L76
#srcline 311 ;          IF lLocalFileInfo.fileName <> INTERNETLIB_EMPTY_STRING_ THEN
 LEAX lLocalFileInfo
 ADD  24  ; + offset 
#debug string lLocalFileInfo.fileName
 LEA  INTERNETLIB_EMPTY_STRING_
 SCMP 
 EQ   0
 NEG
 JMC  fbStoreToFtp_L78
#srcline 312 ;//            lRemotName := RemotName + dirStack[1].sDir + dirStack[2].sDir + dirStack[3].sDir + dirStack[4].sDir + lLocalFileInfo.fileName;
#srcline 313 ;            lRemotName := dirStack[1].sDir + dirStack[2].sDir + dirStack[3].sDir + dirStack[4].sDir + lLocalFileInfo.fileName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX dirStack
 ADD  21  ; + offset 
#debug string dirStack[1].sDir
 SCON 
 LEAX dirStack
 ADD  38  ; + offset 
#debug string dirStack[2].sDir
 SCON 
 LEAX dirStack
 ADD  55  ; + offset 
#debug string dirStack[3].sDir
 SCON 
 LEAX dirStack
 ADD  72  ; + offset 
#debug string dirStack[4].sDir
 SCON 
 LEAX lLocalFileInfo
 ADD  24  ; + offset 
#debug string lLocalFileInfo.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lRemotName
 WRI  
 LEAX lRemotName
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lRemotName
 PDST   ; Level 1
#srcline 314 ;            CurrFile := LocalName + dirStack[1].sDir + dirStack[2].sDir + dirStack[3].sDir + dirStack[4].sDir + lLocalFileInfo.fileName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  LocalName
#debug string LocalName
 SCON 
 LEAX dirStack
 ADD  21  ; + offset 
#debug string dirStack[1].sDir
 SCON 
 LEAX dirStack
 ADD  38  ; + offset 
#debug string dirStack[2].sDir
 SCON 
 LEAX dirStack
 ADD  55  ; + offset 
#debug string dirStack[3].sDir
 SCON 
 LEAX dirStack
 ADD  72  ; + offset 
#debug string dirStack[4].sDir
 SCON 
 LEAX lLocalFileInfo
 ADD  24  ; + offset 
#debug string lLocalFileInfo.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX CurrFile
 WRI  
 LEAX CurrFile
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CurrFile
 PDST   ; Level 1
#srcline 315 ;            IF LEN(lRemotName) + LEN(RemotName) > 80 THEN
 LEAX lRemotName
#debug string lRemotName
 SLEN 
 LDX  RemotName
#debug string RemotName
 SLEN 
 ADD
 EXTW
 LD   int 80
 GTS
 JMC  fbStoreToFtp_L80
#srcline 316 ;              State  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  State
#debug_left usint State
#srcline 317 ;              eErrId := 4; //remote name to long
 LD   usint 4
 WRX  eErrId
#debug_left usint eErrId
#srcline 318 ;              RETURN;
 JMP  fbStoreToFtp_RET
#srcline 319 ;            ELSE
 JMP  fbStoreToFtp_L81
fbStoreToFtp_L80:
#srcline 320 ;              lRemotName := RemotName + lRemotName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  RemotName
#debug string RemotName
 SCON 
 LEAX lRemotName
#debug string lRemotName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lRemotName
 WRI  
 LEAX lRemotName
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lRemotName
 PDST   ; Level 1
#srcline 321 ;            END_IF;
fbStoreToFtp_L81:
#srcline 323 ;            idPos  := 0;
 LD   udint 0
 WRX  idPos
#debug_left udint idPos
#srcline 324 ;            _FindNextPathSeparator(In := lRemotName, Pos := idPos);
 NXT
 LEAX lRemotName
 WR   __Instance___FindNextPathSeparator~In
#debug_left pointer __Instance___FindNextPathSeparator.In
 LEAX idPos
 WR   __Instance___FindNextPathSeparator~Pos
#debug_left pointer __Instance___FindNextPathSeparator.Pos
 PRV
 LEA  __Instance___FindNextPathSeparator
 CAL  _FindNextPathSeparator_L0
#srcline 326 ;            h := FileOpen(fileName := CurrFile, mode := F_READ); //otevrit file
 NXT
 LEAX CurrFile
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 LD   udint 0  ; TF_MODE#F_READ
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  h
#debug_left udint h
#srcline 327 ;            Progress := 0;
 LD   usint 0
 WRX  Progress
#debug_left usint Progress
#srcline 328 ;            IF h = INVALID_HANDLE_VALUE THEN
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 JMC  fbStoreToFtp_L82
#srcline 329 ;              IF dirStackLev < FTP_DIR_STACK_ THEN
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 4
 LT
 JMC  fbStoreToFtp_L84
#srcline 330 ;                dirStackLev := dirStackLev + 1;
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 1
 ADD
 AND  $FF
 WRX  dirStackLev
#debug_left usint dirStackLev
#srcline 331 ;                dirStack[dirStackLev].sDir := lLocalFileInfo.fileName + '/';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   12
 DST    ; Level 1
 LEAX lLocalFileInfo
 ADD  24  ; + offset 
#debug string lLocalFileInfo.fileName
 SCON 
 LEA  _str_fbStoreToFtp_9
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string dirStack[dirStackLev].sDir
 PDST   ; Level 1
#srcline 332 ;                dirStack[dirStackLev].hDir := DirOpen(dirName := CurrFile, dirInfo := lLocalFileInfo);
 NXT
 LEAX CurrFile
 WR   __Instance__DirOpen~dirName
#debug_left pointer __Instance__DirOpen.dirName
 LEAX lLocalFileInfo
 WR   __Instance__DirOpen~dirInfo
#debug_left pointer __Instance__DirOpen.dirInfo
 PRV
 LEA  __Instance__DirOpen
 CAL  DirOpen_L0
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 WRIL 
#debug_left udint dirStack[dirStackLev].hDir
#srcline 333 ;                IF dirStack[dirStackLev].hDir = INVALID_HANDLE_VALUE THEN
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 LD   udint 0
 EQ
 JMC  fbStoreToFtp_L86
#srcline 334 ;                  (* ignorovat chybu, vznikne na prazdnem adresary
#srcline 335 ;                  State  := fss_Error;
#srcline 336 ;                  eErrId := !; //failed to open dir
#srcline 337 ;                  *)
#srcline 338 ;                  dirStack[dirStackLev].sDir := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string dirStack[dirStackLev].sDir
 PDST   ; Level 1
#srcline 339 ;                  dirStackLev := dirStackLev - 1;
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 1
 SUB
 AND  $FF
 WRX  dirStackLev
#debug_left usint dirStackLev
#srcline 340 ;                END_IF;
fbStoreToFtp_L86:
#srcline 341 ;              ELSE
 JMP  fbStoreToFtp_L85
fbStoreToFtp_L84:
#srcline 342 ;                State  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  State
#debug_left usint State
#srcline 343 ;                eErrId := 5; //to many subdirectories
 LD   usint 5
 WRX  eErrId
#debug_left usint eErrId
#srcline 344 ;              END_IF;
fbStoreToFtp_L85:
#srcline 345 ;              RETURN;
 JMP  fbStoreToFtp_RET
#srcline 346 ;            ELSE
 JMP  fbStoreToFtp_L83
fbStoreToFtp_L82:
#srcline 347 ;              lSize := lLocalFileInfo.fileSize;
 LDX  lLocalFileInfo~fileSize
#debug udint lLocalFileInfo.fileSize
 WRX  lSize
#debug_left udint lSize
#srcline 348 ;            END_IF;
fbStoreToFtp_L83:
#srcline 349 ;          END_IF;
fbStoreToFtp_L78:
#srcline 351 ;          IF NOT DirRead(hDir := dirStack[dirStackLev].hDir, dirInfo := lLocalFileInfo) THEN        //nacist dalsi jmeno
 NXT
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 WR   __Instance__DirRead~hDir
#debug_left udint __Instance__DirRead~hDir
 LEAX lLocalFileInfo
 WR   __Instance__DirRead~dirInfo
#debug_left pointer __Instance__DirRead.dirInfo
 PRV
 LEA  __Instance__DirRead
 CAL  DirRead_L0
 NEG
 JMC  fbStoreToFtp_L88
#srcline 352 ;            DirClose(hDir := dirStack[dirStackLev].hDir);
 NXT
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 WR   __Instance__DirClose~hDir
#debug_left udint __Instance__DirClose~hDir
 PRV
 LEA  __Instance__DirClose
 CAL  DirClose_L0
#srcline 353 ;            dirStack[dirStackLev].hDir := INVALID_HANDLE_VALUE;
 LD   udint 0
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 WRIL 
#debug_left udint dirStack[dirStackLev].hDir
#srcline 354 ;            dirStack[dirStackLev].sDir := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string dirStack[dirStackLev].sDir
 PDST   ; Level 1
#srcline 355 ;            IF dirStackLev > 0 THEN
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 0
 GT
 JMC  fbStoreToFtp_L90
#srcline 356 ;              dirStackLev := dirStackLev - 1;
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 1
 SUB
 AND  $FF
 WRX  dirStackLev
#debug_left usint dirStackLev
#srcline 357 ;            END_IF;
fbStoreToFtp_L90:
#srcline 358 ;          END_IF;
fbStoreToFtp_L88:
#srcline 359 ;        END_IF;
fbStoreToFtp_L76:
#srcline 361 ;        endDir := dirStack[0].hDir = INVALID_HANDLE_VALUE AND h = INVALID_HANDLE_VALUE;
 LEAX dirStack
 LDIL 
#debug udint dirStack[0].hDir
 LD   udint 0
 EQ
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 AND
 WRX  endDir
#debug_left bool endDir
#srcline 362 ;        IF iniDir THEN //prvni soubor k vyslani
 LDX  iniDir
#debug bool iniDir
 JMC  fbStoreToFtp_L92
#srcline 363 ;          IF endDir THEN //adresar skoncil chyba
 LDX  endDir
#debug bool endDir
 JMC  fbStoreToFtp_L94
#srcline 364 ;            State  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  State
#debug_left usint State
#srcline 365 ;            eErrId := 6; //empty dir
 LD   usint 6
 WRX  eErrId
#debug_left usint eErrId
#srcline 366 ;          ELSIF h <> INVALID_HANDLE_VALUE THEN //nasel se file navazat spojeni
 JMP  fbStoreToFtp_L95
fbStoreToFtp_L94:
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L96
#srcline 367 ;            State  := fss_IpCom;
 LD   udint 3  ; TFtpStoreState#fss_IpCom
 WRX  State
#debug_left usint State
#srcline 368 ;          END_IF;
 JMP  fbStoreToFtp_L95
fbStoreToFtp_L96:
fbStoreToFtp_L95:
#srcline 369 ;        ELSE //dalsi
 JMP  fbStoreToFtp_L93
fbStoreToFtp_L92:
#srcline 370 ;          IF endDir THEN //adresar skoncil konec
 LDX  endDir
#debug bool endDir
 JMC  fbStoreToFtp_L97
#srcline 371 ;            State := fss_TxQuit;
 LD   udint 19  ; TFtpStoreState#fss_TxQuit
 WRX  State
#debug_left usint State
#srcline 372 ;          ELSIF h <> INVALID_HANDLE_VALUE THEN //nasel se file odeslat
 JMP  fbStoreToFtp_L98
fbStoreToFtp_L97:
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L99
#srcline 373 ;            State  := fss_TxPasv;
 LD   udint 12  ; TFtpStoreState#fss_TxPasv
 WRX  State
#debug_left usint State
#srcline 374 ;          END_IF;
 JMP  fbStoreToFtp_L98
fbStoreToFtp_L99:
fbStoreToFtp_L98:
#srcline 375 ;        END_IF;
fbStoreToFtp_L93:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L75:
 LD   15
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L100
#srcline 376 ;      fss_IpDat:
#srcline 377 ;        rea.remoteIP[0]   := pasvDat[0];
 LDX  pasvDat[0]
#debug usint pasvDat[0]
 WRX  rea~remoteIP[0]
#debug_left usint rea.remoteIP[0]
#srcline 378 ;        rea.remoteIP[1]   := pasvDat[1];
 LDX  pasvDat[1]
#debug usint pasvDat[1]
 WRX  rea~remoteIP[1]
#debug_left usint rea.remoteIP[1]
#srcline 379 ;        rea.remoteIP[2]   := pasvDat[2];
 LDX  pasvDat[2]
#debug usint pasvDat[2]
 WRX  rea~remoteIP[2]
#debug_left usint rea.remoteIP[2]
#srcline 380 ;        rea.remoteIP[3]   := pasvDat[3];
 LDX  pasvDat[3]
#debug usint pasvDat[3]
 WRX  rea~remoteIP[3]
#debug_left usint rea.remoteIP[3]
#srcline 381 ;        rea.remotePort    := USINT_TO_UINT(pasvDat[4])*256+USINT_TO_UINT(pasvDat[5]);
 LDX  pasvDat[4]
#debug usint pasvDat[4]
 AND  $FFFF
 LD   uint 256
 MUL
 AND  $FFFF
 LDX  pasvDat[5]
#debug usint pasvDat[5]
 AND  $FFFF
 ADD
 AND  $FFFF
 WRX  rea~remotePort
#debug_left uint rea.remotePort
#srcline 382 ;        rea.localPort  := 0;
 LD   uint 0
 WRX  rea~localPort
#debug_left uint rea.localPort
#srcline 383 ;        IF SetRemoteIPaddress(rq := 1, chanCode := chanCodeDat, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbStoreToFtp_L101
#srcline 384 ;          state := fss_WaitForOpen;
 LD   udint 16  ; TFtpStoreState#fss_WaitForOpen
 WRX  state
#debug_left usint state
#srcline 385 ;        END_IF;
fbStoreToFtp_L101:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L100:
 LD   16
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L103
#srcline 386 ;      fss_WaitForOpen:
#srcline 387 ;        EstabTCPconnection(chanCode := chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 388 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L104
#srcline 389 ;          IF ReplyCode = 150 OR ReplyCode = 125 THEN
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 150
 EQ
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 125
 EQ
 OR  
 JMC  fbStoreToFtp_L106
#srcline 390 ;            lTrans := 0;
 LD   udint 0
 WRX  lTrans
#debug_left udint lTrans
#srcline 391 ;            state := fss_TxData;
 LD   udint 17  ; TFtpStoreState#fss_TxData
 WRX  state
#debug_left usint state
#srcline 392 ;          ELSIF ReplyCodeClass = 5 AND idPos > 0 THEN
 JMP  fbStoreToFtp_L107
fbStoreToFtp_L106:
 LDY  ReplyCodeClass
#debug uint ReplyCodeClass
 LD   uint 5
 EQ
 LDX  idPos
#debug udint idPos
 LD   udint 0
 GT
 AND
 JMC  fbStoreToFtp_L108
#srcline 393 ;            State := fss_TxCreateDir;
 LD   udint 24  ; TFtpStoreState#fss_TxCreateDir
 WRX  State
#debug_left usint State
#srcline 394 ;          ELSE
 JMP  fbStoreToFtp_L107
fbStoreToFtp_L108:
#srcline 395 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 396 ;          END_IF;
fbStoreToFtp_L107:
#srcline 397 ;        END_IF;
fbStoreToFtp_L104:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L103:
 LD   24
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L109
#srcline 398 ;      fss_TxCreateDir:
#srcline 399 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 400 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 401 ;        cmdCom := LEFT(IN := lRemotName, L := UDINT_TO_UINT(idPos-1));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX lRemotName
#debug string lRemotName
 LDX  idPos
#debug udint idPos
 LD   udint 1
 SUB
 AND  $FFFF
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 402 ;        cmdCom := 'MKD ' + cmdCom  + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_10
 SCON 
 LEAX cmdCom
#debug string cmdCom
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 403 ;        state := fss_RxCreateDir;
 LD   udint 25  ; TFtpStoreState#fss_RxCreateDir
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L109:
 LD   25
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L110
#srcline 404 ;      fss_RxCreateDir:
#srcline 405 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L111
#srcline 406 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 407 ;          IF tmpReplyCode = 257 OR tmpReplyCode = 550 THEN //257 created - 550 already exists
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 257
 EQ
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 550
 EQ
 OR  
 JMC  fbStoreToFtp_L113
#srcline 408 ;            IF _FindNextPathSeparator(In := lRemotName, Pos := idPos) THEN
 NXT
 LEAX lRemotName
 WR   __Instance___FindNextPathSeparator~In
#debug_left pointer __Instance___FindNextPathSeparator.In
 LEAX idPos
 WR   __Instance___FindNextPathSeparator~Pos
#debug_left pointer __Instance___FindNextPathSeparator.Pos
 PRV
 LEA  __Instance___FindNextPathSeparator
 CAL  _FindNextPathSeparator_L0
 JMC  fbStoreToFtp_L115
#srcline 409 ;              state := fss_TxCreateDir;
 LD   udint 24  ; TFtpStoreState#fss_TxCreateDir
 WRX  state
#debug_left usint state
#srcline 410 ;            ELSE
 JMP  fbStoreToFtp_L116
fbStoreToFtp_L115:
#srcline 411 ;              state := fss_TxPasv; // fss_TxStor
 LD   udint 12  ; TFtpStoreState#fss_TxPasv
 WRX  state
#debug_left usint state
#srcline 412 ;            END_IF;
fbStoreToFtp_L116:
#srcline 413 ;          ELSE
 JMP  fbStoreToFtp_L114
fbStoreToFtp_L113:
#srcline 414 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 415 ;          END_IF;
fbStoreToFtp_L114:
#srcline 416 ;        END_IF;
fbStoreToFtp_L111:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L110:
 LD   17
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L117
#srcline 417 ;      fss_TxData:
#srcline 418 ;        Send_To_Dat.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Dat~rq
#debug_left bool Send_To_Dat.rq
#srcline 419 ;        tmpud := FileRead(h, PTR_TO_UDINT(ADR(cmdDat)), 255);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LEAX cmdDat
#debug pointer cmdDat
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LD   udint 255
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
 WRY  tmpud
#debug_left udint tmpud
#srcline 420 ;        Send_To_Dat.lenTx := UDINT_TO_UINT(tmpud);
 LDY  tmpud
#debug udint tmpud
 AND  $FFFF
 WRX  Send_To_Dat~lenTx
#debug_left uint Send_To_Dat.lenTx
#srcline 421 ;        lTrans := lTrans + tmpud;
 LDX  lTrans
#debug udint lTrans
 LDY  tmpud
#debug udint tmpud
 ADD
 WRX  lTrans
#debug_left udint lTrans
#srcline 422 ;        Progress := REAL_TO_USINT(UDINT_TO_REAL(lTrans)*100.0/UDINT_TO_REAL(lSize));
 LDX  lTrans
#debug udint lTrans
 ULF
 LD   real 100.0
 MUF
 LDX  lSize
#debug udint lSize
 ULF
 DIF
 RND
 UFW
 AND  $FF
 WRX  Progress
#debug_left usint Progress
#srcline 423 ;        IF tmpud < 255 THEN
 LDY  tmpud
#debug udint tmpud
 LD   udint 255
 LT
 JMC  fbStoreToFtp_L118
#srcline 424 ;          state := fss_RxComplete;
 LD   udint 18  ; TFtpStoreState#fss_RxComplete
 WRX  state
#debug_left usint state
#srcline 425 ;        END_IF;
fbStoreToFtp_L118:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L117:
 LD   18
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L120
#srcline 426 ;      fss_RxComplete:
#srcline 427 ;        FileClose(hFile := h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 428 ;        h := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  h
#debug_left udint h
#srcline 429 ;        CloseTCPconnection(chanCode := chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 430 ;        Send_To_Dat.rq   := 0;
 LD   bool 0       ; false
 WRX  Send_To_Dat~rq
#debug_left bool Send_To_Dat.rq
#srcline 431 ;//        Recv_From_Dat.rq := 0;
#srcline 432 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L121
#srcline 433 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 434 ;          IF tmpReplyCode = 226 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 226
 EQ
 JMC  fbStoreToFtp_L123
#srcline 435 ;            iniDir := false;
 LD   bool 0       ; false
 WRX  iniDir
#debug_left bool iniDir
#srcline 436 ;            State := fss_ReadDir;
 LD   udint 26  ; TFtpStoreState#fss_ReadDir
 WRX  State
#debug_left usint State
#srcline 437 ;            //state := fss_TxQuit;
#srcline 438 ;          ELSE
 JMP  fbStoreToFtp_L124
fbStoreToFtp_L123:
#srcline 439 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 440 ;          END_IF;
fbStoreToFtp_L124:
#srcline 441 ;        END_IF;
fbStoreToFtp_L121:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L120:
 LD   19
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L125
#srcline 442 ;      fss_TxQuit:
#srcline 443 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 444 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 445 ;        cmdCom := 'QUIT' + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_11
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 446 ;        state := fss_RxQuit;
 LD   udint 20  ; TFtpStoreState#fss_RxQuit
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L125:
 LD   20
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L126
#srcline 447 ;      fss_RxQuit:
#srcline 448 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L127
#srcline 449 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 450 ;          IF tmpReplyCode = 221 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 221
 EQ
 JMC  fbStoreToFtp_L129
#srcline 451 ;            state := fss_Close;
 LD   udint 21  ; TFtpStoreState#fss_Close
 WRX  state
#debug_left usint state
#srcline 452 ;          ELSE
 JMP  fbStoreToFtp_L130
fbStoreToFtp_L129:
#srcline 453 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 454 ;          END_IF;
fbStoreToFtp_L130:
#srcline 455 ;        END_IF;
fbStoreToFtp_L127:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L126:
 LD   21
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L131
#srcline 456 ;      fss_Close:
#srcline 457 ;        CloseTCPconnection(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 458 ;        IF IsEstabTCPconnection(chanCode := chanCodeCom) = false THEN
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbStoreToFtp_L132
#srcline 459 ;          Done := true;
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 460 ;          state := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
#srcline 461 ;        END_IF;
fbStoreToFtp_L132:
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L131:
 LD   23
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L134
#srcline 462 ;      fss_UnexpectedReply:
#srcline 463 ;        eErrId := 2;
 LD   usint 2
 WRX  eErrId
#debug_left usint eErrId
#srcline 464 ;        state := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L134:
 LD   22
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L135
#srcline 465 ;      fss_Error :
#srcline 466 ;        Err := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 467 ;        ErrId := eErrId;
 LDX  eErrId
#debug usint eErrId
 WRX  ErrId
#debug_left usint ErrId
#srcline 468 ;        Recv_From_Com.rq  := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 469 ;        state := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L13
fbStoreToFtp_L135:
fbStoreToFtp_L13:
#srcline 471 ;  END_IF;
fbStoreToFtp_L7:
#srcline 473 ;  timeoutCom.IN := Recv_From_Com.rq & NOT Send_To_Dat.rq;
 LDX  Recv_From_Com~rq
#debug bool Recv_From_Com.rq
 LDX  Send_To_Dat~rq
#debug bool Send_To_Dat.rq
 NEG
 AND
 WRX  timeoutCom~IN
#debug_left bool timeoutCom.IN
#srcline 475 ;  Send_To_Com   (lenTx := len(cmdCom), chanCode := chanCodeCom, data := void(cmdCom));
 LEAX cmdCom
#debug string cmdCom
 SLEN 
 WRX  Send_To_Com~lenTx
#debug_left uint Send_To_Com~lenTx
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  Send_To_Com~chanCode
#debug_left uint Send_To_Com~chanCode
 LEAX cmdCom
 WRX  Send_To_Com~data
#debug_left pointer Send_To_Com.data
 LEAX Send_To_Com
 CAL  fbSendTo_L0
#srcline 477 ;  Recv_From_Com (lenRx := 255, chanCode := chanCodeCom, data := void(cmdCom), mesRec => mesRec);
 LD   uint 255
 WRX  Recv_From_Com~lenRx
#debug_left uint Recv_From_Com~lenRx
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  Recv_From_Com~chanCode
#debug_left uint Recv_From_Com~chanCode
 LEAX cmdCom
 WRX  Recv_From_Com~data
#debug_left pointer Recv_From_Com.data
 LEAX Recv_From_Com
 CAL  fbRecvFrom_L0
; output assigment 
 LDX  Recv_From_Com~mesRec
#debug bool Recv_From_Com~mesRec
 WRX  mesRec
#debug_left bool mesRec
#srcline 479 ;  Send_To_Dat   (chanCode := chanCodeDat, data := void(cmdDat));
 LDX  chanCodeDat
#debug uint chanCodeDat
 WRX  Send_To_Dat~chanCode
#debug_left uint Send_To_Dat~chanCode
 LEAX cmdDat
 WRX  Send_To_Dat~data
#debug_left pointer Send_To_Dat.data
 LEAX Send_To_Dat
 CAL  fbSendTo_L0
#srcline 481 ;  TRO_dat := Send_To_Dat.error = 5; //buffer is full wait
 LDX  Send_To_Dat~error
#debug usint Send_To_Dat.error
 LD   usint 5
 EQ
 WRX  TRO_dat
#debug_left bool TRO_dat
#srcline 482 ;  TRO_com := Send_To_Com.error = 5;
 LDX  Send_To_Com~error
#debug usint Send_To_Com.error
 LD   usint 5
 EQ
 WRX  TRO_com
#debug_left bool TRO_com
#srcline 483 ;  TRO := TRO_com OR TRO_dat;
 LDX  TRO_com
#debug bool TRO_com
 LDX  TRO_dat
#debug bool TRO_dat
 OR  
 WRX  TRO
#debug_left bool TRO
#srcline 485 ;  Send_To_Com.rq := Send_To_Com.rq AND TRO_com;
 LDX  Send_To_Com~rq
#debug bool Send_To_Com.rq
 LDX  TRO_com
#debug bool TRO_com
 AND
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 486 ;  Send_To_Dat.rq := Send_To_Dat.rq  AND TRO_dat;
 LDX  Send_To_Dat~rq
#debug bool Send_To_Dat.rq
 LDX  TRO_dat
#debug bool TRO_dat
 AND
 WRX  Send_To_Dat~rq
#debug_left bool Send_To_Dat.rq
#srcline 488 ;END_FUNCTION_BLOCK
fbStoreToFtp_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbStoreToFtp__InstanceInit__:
 LINK 0
 LD   uint 21
 WRX  port
 LEAX Send_To_Com
 CAL  fbSendTo__InstanceInit__
 LEAX Recv_From_Com
 CAL  fbRecvFrom__InstanceInit__
 LEAX Send_To_Dat
 CAL  fbSendTo__InstanceInit__
 LD   0
 SRC  byte __Init___fbStoreToFtp_h
 LEAX byte h
 LD   4
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBHTTPREQUESTL.ST'
#pou fbHttpRequestL
#srcline 5 ;FUNCTION_BLOCK fbHttpRequestL

#struct fbHttpRequestL__temp__
  string[81] lNamePass,
  usint r,
  uint i,
  pointer pHelpString,
  pointer pUint,
  pointer pUsint,
  TUniDesc UniDesc,
  TRemoteEthAdr rea,
  udint l,
  uint authPos,
  usint P0__st__,
  string[257] PS0__st__,
  string[62] PS1__st__,
  string[257] PSC__st__
#data byte _str_fbHttpRequestL_0 = 
  '@',0
#data byte _str_fbHttpRequestL_1 = 
  'G','E','T',' ',0
#data byte _str_fbHttpRequestL_2 = 
  'P','O','S','T',' ',0
#data byte _str_fbHttpRequestL_3 = 
  ' ','H','T','T','P','/','1','.','0',$0D,$0A,'U','s','e','r','-','A','g','e','n',
  't',':',' ','F','o','x','t','r','o','t','/',0
#data byte _str_fbHttpRequestL_4 = 
  '.',0
#data byte _str_fbHttpRequestL_5 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',
  ':',' ','a','p','p','l','i','c','a','t','i','o','n','/','x','-','w','w','w','-',
  'f','o','r','m','-','u','r','l','e','n','c','o','d','e','d',$0D,$0A,'A','c','c',
  'e','p','t',':',' ','t','e','x','t','/','*',';','q','=','0','.','9',',',' ','*',
  '/','*',';','q','=','0','.','1',$0D,$0A,'H','o','s','t',':',' ',0
#data byte _str_fbHttpRequestL_6 = 
  $0D,$0A,'A','u','t','h','o','r','i','z','a','t','i','o','n',':',' ','B','a','s',
  'i','c',' ',0
#data byte _str_fbHttpRequestL_7 = 
  $0D,$0A,'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',' ',0
#data byte _str_fbHttpRequestL_8 = 
  $0D,$0A,'C','o','n','n','e','c','t','i','o','n',':',' ','C','l','o','s','e',$0D,
  $0A,$0D,$0A,0
#data byte _str_fbHttpRequestL_9 = 
  'H','T','T','P',0
#data byte _str_fbHttpRequestL_10 = 
  'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',0
#data byte _str_fbHttpRequestL_11 = 
  $0D,$0A,$0D,$0A,0
P     61
fbHttpRequestL_L0:
 LINK __SizeOf(fbHttpRequestL__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pHelpString
 LD   udint $FFFFFFFF    ; nil
 WRY  pUint
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Post
 LETX __EDGE_R__Post
 WRX  Post
 LDX  Get
 LETX __EDGE_R__Get
 WRX  Get
 LDX  Cancel
 LETX __EDGE_R__Cancel
 WRX  Cancel
#srcline 70 ;  UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 71 ;  IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 516) OR (UniDesc.lenUniOut < 516) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 516
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 516
 LT
 OR  
 JMC  fbHttpRequestL_L1
#srcline 72 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 73 ;    ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 74 ;    RETURN;
 JMP  fbHttpRequestL_RET
#srcline 75 ;  END_IF;
fbHttpRequestL_L1:
#srcline 77 ;  Busy := State <> hs_HttpIdle;
 LDX  State
#debug usint State
 LD   udint 0  ; THttpState#hs_HttpIdle
 EQ
 NEG
 WRX  Busy
#debug_left bool Busy
#srcline 79 ;  TimeOutTon(IN := Busy & NOT DataReady, PT := T#2m);
 LDX  Busy
#debug bool Busy
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 WRX  TimeOutTon~IN
#debug_left bool TimeOutTon~IN
 LD   time 120000
 WRX  TimeOutTon~PT
#debug_left time TimeOutTon~PT
 LEAX TimeOutTon
 CAL  TON_L0
#srcline 81 ;  DataReady := false;
 LD   bool 0       ; false
 WRX  DataReady
#debug_left bool DataReady
#srcline 83 ;  IF TimeOutTon.Q THEN
 LDX  TimeOutTon~Q
#debug bool TimeOutTon.Q
 JMC  fbHttpRequestL_L3
#srcline 84 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 85 ;    ErrId := 1;
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
#srcline 86 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 87 ;  END_IF;
fbHttpRequestL_L3:
#srcline 89 ;  IF Cancel THEN
 LDX  Cancel
#debug bool Cancel
 JMC  fbHttpRequestL_L5
#srcline 90 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 91 ;    Err   := ContLen > 0;
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 92 ;  END_IF;
fbHttpRequestL_L5:
#srcline 94 ;  CASE State OF
 LDX  State
#debug usint State
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L8
#srcline 95 ;    hs_HttpIdle   :
#srcline 96 ;      r := CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 97 ;      Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 98 ;      IF Post OR Get THEN
 LDX  Post
#debug bool Post
 LDX  Get
#debug bool Get
 OR  
 JMC  fbHttpRequestL_L9
#srcline 99 ;        WholeLen := 0;
 LD   dint 0
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 100 ;        Err     := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 101 ;        ErrId   := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 102 ;        Result  := 0;
 LD   int 0
 WRX  Result
#debug_left int Result
#srcline 103 ;        authPos := FIND(IN1 := Host, IN2 := '@');
 LDX  Host
#debug string Host
 LEA  _str_fbHttpRequestL_0
 SFND 
 WRY  authPos
#debug_left uint authPos
#srcline 104 ;        IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequestL_L11
#srcline 105 ;          lHost := MID(IN := Host, L := 80, P := authPos+1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LD   80
 LDY  authPos
#debug uint authPos
 LD   uint 1
 ADD
 AND  $FFFF
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 106 ;          lNamePass := LEFT(IN := Host, L := authPos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LDY  authPos
#debug uint authPos
 LD   uint 1
 SUB
 AND  $FFFF
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY lNamePass
 WRI  
 LEAY lNamePass
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lNamePass
 PDST   ; Level 1
#srcline 107 ;        ELSE
 JMP  fbHttpRequestL_L12
fbHttpRequestL_L11:
#srcline 108 ;          lHost := Host;
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 109 ;        END_IF;
fbHttpRequestL_L12:
#srcline 110 ;        (*
#srcline 111 ;        pUint := ADR(RecvData);
#srcline 112 ;        pHelpString := pUint;
#srcline 113 ;        *)
#srcline 114 ;        IF Get THEN
 LDX  Get
#debug bool Get
 JMC  fbHttpRequestL_L13
#srcline 115 ;          BodyLen := 0;
 LD   uint 0
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 116 ;          HelpString := 'GET ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_1
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 117 ;        ELSE
 JMP  fbHttpRequestL_L14
fbHttpRequestL_L13:
#srcline 118 ;          BodyLen := postLen;
 LDX  postLen
#debug uint postLen
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 119 ;          lPostLen := postLen;
 LDX  postLen
#debug uint postLen
 WRX  lPostLen
#debug_left uint lPostLen
#srcline 120 ;          HelpString := 'POST ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_2
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 121 ;        END_IF;
fbHttpRequestL_L14:
#srcline 122 ;        //TODO: Dodelat kontrolu delky vstupnich dat
#srcline 123 ;        pUint := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pUint
 WRIL 
#debug_left pointer pUint
#srcline 124 ;        pUsint := pUint  + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUint);
 LEAY pUint
 LDIL 
#debug pointer pUint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUint
 LDIL 
#debug pointer pUint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 125 ;        //max len 5+255 = 300
#srcline 126 ;        helpstring := ' HTTP/1.0$r$nUser-Agent: Foxtrot/' + USINT_TO_STRING(%S40) + '.' + USINT_TO_STRING(%S41);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_3
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S40
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequestL_4
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S41
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 127 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 128 ;        //max len 300+33+1+1+1 = 336
#srcline 129 ;        helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nContent-Type: application/x-www-form-urlencoded$r$nAccept: text/*;q=0.9, */*;q=0.1$r$nHost: ';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_5
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 130 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 131 ;        //max len 336+140 = 476
#srcline 132 ;        Err := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 133 ;        REPEAT
fbHttpRequestL_L15:
 DBG
#srcline 134 ;          l := LEN(lHost);
 LEAX lHost
#debug string lHost
 SLEN 
 WRY  l
#debug_left udint l
#srcline 135 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL_L17
 JMP  fbHttpRequestL_L16
fbHttpRequestL_L17:
#srcline 136 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(lHost), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX lHost
#debug pointer lHost
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 137 ;          
#srcline 138 ;          IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequestL_L19
#srcline 139 ;            //Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
#srcline 140 ;            helpstring := '$r$nAuthorization: Basic ' + Base64_encode_string(data := lNamePass);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_6
 SCON 
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LEAY lNamePass
#debug string lNamePass
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 141 ;            l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 142 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL_L21
 JMP  fbHttpRequestL_L16
fbHttpRequestL_L21:
#srcline 143 ;            pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 144 ;          END_IF;
fbHttpRequestL_L19:
#srcline 145 ;          
#srcline 146 ;          //max len 476+80 = 556!!!
#srcline 147 ;          helpstring := '$r$nContent-Length: ' + UINT_TO_STRING(BodyLen) + '$r$nConnection: Close$r$n$r$n';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_7
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LDX  BodyLen
#debug uint BodyLen
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequestL_8
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 148 ;          l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 149 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL_L23
 JMP  fbHttpRequestL_L16
fbHttpRequestL_L23:
#srcline 150 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 152 ;          
#srcline 153 ;          //max len 556+44=600!!!
#srcline 154 ;          (*
#srcline 155 ;          IF POST THEN //copy data to post
#srcline 156 ;            l := LEN(data);
#srcline 157 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
#srcline 158 ;            pUsint := pUsint + MemcpyPtr(length := LEN(data), source := ADR(data), dest := pUsint);
#srcline 159 ;            //max len 600+80=680!!!
#srcline 160 ;          END_IF;
#srcline 161 ;          *)
#srcline 162 ;          Err := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 163 ;        UNTIL true END_REPEAT;
 LD   bool -1       ; true
 JMC  fbHttpRequestL_L15
fbHttpRequestL_L16:
 NOP  -1
#srcline 164 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequestL_L25
#srcline 165 ;          ErrId := 3; //delka hlavicka protokolu presahla 512 bytes
 LD   usint 3
 WRX  ErrId
#debug_left usint ErrId
#srcline 166 ;        ELSE
 JMP  fbHttpRequestL_L26
fbHttpRequestL_L25:
#srcline 167 ;          SendTo.lenTx := UDINT_TO_UINT(PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint));
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 168 ;          State := hs_HttpSetIP;
 LD   udint 1  ; THttpState#hs_HttpSetIP
 WRX  State
#debug_left usint State
#srcline 169 ;          Busy  := true; //Busy is set in the same cycle when we left idle state!!!
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 170 ;        END_IF;
fbHttpRequestL_L26:
#srcline 171 ;      END_IF;
fbHttpRequestL_L9:
 JMP  fbHttpRequestL_L7
fbHttpRequestL_L8:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L27
#srcline 172 ;    hs_HttpSetIP:
#srcline 173 ;      IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbHttpRequestL_L28
#srcline 174 ;          Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 175 ;          ErrId := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 176 ;          State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 177 ;      ELSE
 JMP  fbHttpRequestL_L29
fbHttpRequestL_L28:
#srcline 178 ;        rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 179 ;        rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 180 ;        IF SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbHttpRequestL_L30
#srcline 181 ;          State := hs_HttpConnect;
 LD   udint 2  ; THttpState#hs_HttpConnect
 WRX  State
#debug_left usint State
#srcline 182 ;        END_IF;
fbHttpRequestL_L30:
#srcline 183 ;      END_IF;
fbHttpRequestL_L29:
 JMP  fbHttpRequestL_L7
fbHttpRequestL_L27:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L32
#srcline 184 ;    hs_HttpConnect:
#srcline 185 ;      r := EstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 186 ;      IF IsEstabTCPconnection(chanCode := chanCode) THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbHttpRequestL_L33
#srcline 187 ;        State := hs_HttpSend;
 LD   udint 3  ; THttpState#hs_HttpSend
 WRX  State
#debug_left usint State
#srcline 188 ;      END_IF;
fbHttpRequestL_L33:
 JMP  fbHttpRequestL_L7
fbHttpRequestL_L32:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L35
#srcline 189 ;    hs_HttpSend   :
#srcline 190 ;      SendTo(rq := 1, chanCode := chanCode, data := void(RecvData));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  RecvData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 191 ;      ResRecv    := false;
 LD   bool 0       ; false
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 192 ;      LenRecv    := false;
 LD   bool 0       ; false
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 193 ;      HeaderRecv := false;
 LD   bool 0       ; false
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 194 ;      WasEOL     := false;
 LD   bool 0       ; false
 WRX  WasEOL
#debug_left bool WasEOL
#srcline 195 ;      ContLen    := -1;
 LD   dint -1
 WRX  ContLen
#debug_left dint ContLen
#srcline 196 ;      State := hs_HttpSendPost;
 LD   udint 5  ; THttpState#hs_HttpSendPost
 WRX  State
#debug_left usint State
 JMP  fbHttpRequestL_L7
fbHttpRequestL_L35:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L36
#srcline 197 ;    hs_HttpSendPost :
#srcline 198 ;      IF BodyLen > 0 THEN
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL_L37
#srcline 199 ;        SendTo(rq := 1, chanCode := chanCode, data := void(Data[lPostLen-BodyLen]), lenTx := MIN(512,BodyLen));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  Data
 LDX  lPostLen
#debug uint lPostLen
 LDX  BodyLen
#debug uint BodyLen
 SUB
 AND  $FFFF
 RCHK 1535   ; Range Check
 ADD     ; + offset 
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LD   uint 512
 LDX  BodyLen
#debug uint BodyLen
 MIN
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 200 ;        IF SendTo.mesSent THEN
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbHttpRequestL_L39
#srcline 201 ;          BodyLen := BodyLen - MIN(512,BodyLen);
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 512
 LDX  BodyLen
#debug uint BodyLen
 MIN
 SUB
 AND  $FFFF
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 202 ;        END_IF;
fbHttpRequestL_L39:
#srcline 203 ;      ELSE
 JMP  fbHttpRequestL_L38
fbHttpRequestL_L37:
#srcline 204 ;        State := hs_HttpReceivingData;
 LD   udint 4  ; THttpState#hs_HttpReceivingData
 WRX  State
#debug_left usint State
#srcline 205 ;      END_IF;
fbHttpRequestL_L38:
 JMP  fbHttpRequestL_L7
fbHttpRequestL_L36:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L41
#srcline 206 ;    hs_HttpReceivingData  :
#srcline 207 ;      RecvFrom(rq := 1, chanCode := chanCode, lenRx := 512, data := void(RecvData));
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 512
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LDX  RecvData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 208 ;      IF RecvFrom.mesRec THEN
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbHttpRequestL_L42
#srcline 209 ;        IF HeaderRecv THEN
 LDX  HeaderRecv
#debug bool HeaderRecv
 JMC  fbHttpRequestL_L44
#srcline 210 ;          DataLen := RecvFrom.lenData;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 WRX  DataLen
#debug_left uint DataLen
#srcline 211 ;          ContLen := ContLen - UINT_TO_DINT(DataLen);
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 212 ;          pUsint  := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 213 ;        ELSE
 JMP  fbHttpRequestL_L45
fbHttpRequestL_L44:
#srcline 214 ;          IF RecvFrom.lenData < 511 THEN
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 511
 LT
 JMC  fbHttpRequestL_L46
#srcline 215 ;            RecvData[RecvFrom.lenData] := 0;
 LD   usint 0
 LDX  RecvData
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 RCHK 511   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint RecvData[RecvFrom.lenData]
#srcline 216 ;          END_IF;
fbHttpRequestL_L46:
#srcline 217 ;          pHelpString := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 218 ;          IF NOT ResRecv & FIND(IN1 := pHelpString^, IN2 := 'HTTP') = 1 THEN
 LDX  ResRecv
#debug bool ResRecv
 NEG
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 LEA  _str_fbHttpRequestL_9
 SFND 
 LD   int 1
 EQ
 AND
 JMC  fbHttpRequestL_L48
#srcline 219 ;            ResRecv := true;
 LD   bool -1       ; true
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 220 ;            pHelpString := pHelpString + 9;
 LEAY pHelpString
 LDIL 
#debug pointer pHelpString
 LD   udint 9
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 221 ;            Result := STRING_TO_INT(pHelpString^);
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300B;  IEC_STRING _TO_ IEC_INT
 WRX  Result
#debug_left int Result
#srcline 222 ;//            Debug1       := pHelpString^;
#srcline 223 ;          END_IF;
fbHttpRequestL_L48:
#srcline 224 ;                                               //012345678901234
#srcline 225 ;          i := FIND(IN1 := pHelpString^, IN2 := 'Content-Length:');
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 LEA  _str_fbHttpRequestL_10
 SFND 
 WRY  i
#debug_left uint i
#srcline 226 ;          IF NOT LenRecv & i > 0 THEN
 LDX  LenRecv
#debug bool LenRecv
 NEG
 LDY  i
#debug uint i
 LD   uint 0
 GT
 AND
 JMC  fbHttpRequestL_L50
#srcline 227 ;            LenRecv := true;
 LD   bool -1       ; true
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 228 ;            pHelpString := pHelpString + UINT_TO_UDINT(i+15);
 LEAY pHelpString
 LDIL 
#debug pointer pHelpString
 LDY  i
#debug uint i
 LD   uint 15
 ADD
 AND  $FFFF
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 229 ;            ContLen     := STRING_TO_DINT(pHelpString^);
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300D;  IEC_STRING _TO_ IEC_DINT
 WRX  ContLen
#debug_left dint ContLen
#srcline 230 ;//            Debug2       := pHelpString^;
#srcline 231 ;          END_IF;
fbHttpRequestL_L50:
#srcline 232 ;          
#srcline 233 ;          pHelpString := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 234 ;          
#srcline 235 ;          IF WasEOL & RecvData[0] = 13 & RecvData[1] = 10 THEN
 LDX  WasEOL
#debug bool WasEOL
 LDX  RecvData
 LDI  
#debug usint RecvData[0]
 LD   usint 13
 EQ
 AND
 LDX  RecvData
 ADD  1  ; + offset 
 LDI  
#debug usint RecvData[1]
 LD   usint 10
 EQ
 AND
 JMC  fbHttpRequestL_L52
#srcline 236 ;            i := 65535; //-1
 LD   uint 65535
 WRY  i
#debug_left uint i
#srcline 237 ;          ELSE
 JMP  fbHttpRequestL_L53
fbHttpRequestL_L52:
#srcline 238 ;            i := FIND(IN1 := pHelpString^, IN2 := '$r$n$r$n');
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 LEA  _str_fbHttpRequestL_11
 SFND 
 WRY  i
#debug_left uint i
#srcline 239 ;          END_IF;
fbHttpRequestL_L53:
#srcline 240 ;          IF i <> 0 THEN
 LDY  i
#debug uint i
 LD   uint 0
 EQ
 NEG
 JMC  fbHttpRequestL_L54
#srcline 241 ;            HeaderRecv := true;
 LD   bool -1       ; true
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 242 ;            pUsint     := pHelpString + UINT_TO_UDINT(i+3);
 LEAY pHelpString
 LDIL 
#debug pointer pHelpString
 LDY  i
#debug uint i
 LD   uint 3
 ADD
 AND  $FFFF
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 243 ;            DataLen    := RecvFrom.lenData - i - 3;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 3
 SUB
 AND  $FFFF
 WRX  DataLen
#debug_left uint DataLen
#srcline 244 ;            MemcpyPtr(source := pUsint, dest := ADR(RecvData), length := UINT_TO_UDINT(DataLen));
 NXT
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LDX  RecvData
#debug pointer RecvData
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  DataLen
#debug uint DataLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 245 ;            ContLen := ContLen - UINT_TO_DINT(DataLen);
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 246 ;            IF NOT LenRecv THEN
 LDX  LenRecv
#debug bool LenRecv
 NEG
 JMC  fbHttpRequestL_L56
#srcline 247 ;              ContLen := 0;
 LD   dint 0
 WRX  ContLen
#debug_left dint ContLen
#srcline 248 ;            END_IF;
fbHttpRequestL_L56:
#srcline 249 ;            WholeLen := ContLen;
 LDX  ContLen
#debug dint ContLen
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 250 ;          ELSE
 JMP  fbHttpRequestL_L55
fbHttpRequestL_L54:
#srcline 251 ;            DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 252 ;          END_IF;
fbHttpRequestL_L55:
#srcline 253 ;          IF RecvFrom.lenData = 0 THEN
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 0
 EQ
 JMC  fbHttpRequestL_L58
#srcline 254 ;            WasEOL := false;
 LD   bool 0       ; false
 WRX  WasEOL
#debug_left bool WasEOL
#srcline 255 ;          ELSE
 JMP  fbHttpRequestL_L59
fbHttpRequestL_L58:
#srcline 256 ;            WasEOL := RecvData[RecvFrom.lenData-1] = 10;
 LDX  RecvData
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 1
 SUB
 AND  $FFFF
 RCHK 511   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint RecvData[RecvFrom.lenData-1]
 LD   usint 10
 EQ
 WRX  WasEOL
#debug_left bool WasEOL
#srcline 257 ;          END_IF;
fbHttpRequestL_L59:
#srcline 258 ;        END_IF;
fbHttpRequestL_L45:
#srcline 259 ;        DataReady := DataLen > 0;
 LDX  DataLen
#debug uint DataLen
 LD   uint 0
 GT
 WRX  DataReady
#debug_left bool DataReady
#srcline 260 ;      ELSE
 JMP  fbHttpRequestL_L43
fbHttpRequestL_L42:
#srcline 261 ;        DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 262 ;      END_IF;
fbHttpRequestL_L43:
#srcline 263 ;      
#srcline 264 ;      //bDebug := NOT IsEstabTCPconnection(chanCode := chanCode) & ContLen > 0 & NOT DataReady;
#srcline 266 ;      IF NOT IsEstabTCPconnection(chanCode := chanCode) & NOT DataReady THEN //NOT IsEstabTCPconnection(chanCode := chanCode) & NOT DataReady THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 NEG
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 JMC  fbHttpRequestL_L60
#srcline 267 ;        Err    := ContLen > 0;
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 268 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequestL_L62
#srcline 269 ;          ErrId := 2;
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
#srcline 270 ;        END_IF;
fbHttpRequestL_L62:
#srcline 271 ;//        ErrId  := BOOL_TO_USINT(Err)*2; //Set 2 if error occured
#srcline 272 ;        Done   := NOT Err;
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 273 ;        State  := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 274 ;      END_IF;
fbHttpRequestL_L60:
#srcline 275 ;      
#srcline 276 ;      IF Close & ContLen = 0 THEN
 LDX  Close
#debug bool Close
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 EQ
 AND
 JMC  fbHttpRequestL_L64
#srcline 277 ;        CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 278 ;      END_IF;
fbHttpRequestL_L64:
 JMP  fbHttpRequestL_L7
fbHttpRequestL_L41:
fbHttpRequestL_L7:
#srcline 282 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbHttpRequestL_L66
#srcline 283 ;    IF WholeLen > 0 THEN
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 0
 GTS
 JMC  fbHttpRequestL_L68
#srcline 284 ;      Progress := DINT_TO_SINT(((WholeLen - ContLen) * 100 + WholeLen / 2) / WholeLen);
 LDX  WholeLen
#debug dint WholeLen
 LDX  ContLen
#debug dint ContLen
 SUB
 LD   dint 100
 MULS
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 2
 DIVS
 ADD
 LDX  WholeLen
#debug dint WholeLen
 DIVS
 EXTB
 WRX  Progress
#debug_left sint Progress
#srcline 285 ;    ELSE
 JMP  fbHttpRequestL_L69
fbHttpRequestL_L68:
#srcline 286 ;      Progress := -1;
 LD   sint -1
 WRX  Progress
#debug_left sint Progress
#srcline 287 ;    END_IF;
fbHttpRequestL_L69:
#srcline 288 ;  END_IF;
fbHttpRequestL_L66:
#srcline 290 ;END_FUNCTION_BLOCK
fbHttpRequestL_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbHttpRequestL__InstanceInit__:
 LINK 0
 LD   uint 80
 WRX  port
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBHTTPREQUESTL2.ST'
#pou fbHttpRequestL2
#srcline 1 ;FUNCTION_BLOCK fbHttpRequestL2

#struct fbHttpRequestL2__temp__
  string[81] lNamePass,
  usint r,
  uint i,
  pointer pHelpString,
  pointer pUint,
  pointer pUsint,
  TUniDesc UniDesc,
  TRemoteEthAdr rea,
  udint l,
  uint authPos,
  usint P0__st__,
  string[257] PS0__st__,
  string[62] PS1__st__,
  string[257] PSC__st__
#data byte _str_fbHttpRequestL2_0 = 
  '@',0
#data byte _str_fbHttpRequestL2_1 = 
  'G','E','T',' ',0
#data byte _str_fbHttpRequestL2_2 = 
  'P','O','S','T',' ',0
#data byte _str_fbHttpRequestL2_3 = 
  ' ','H','T','T','P','/','1','.','0',$0D,$0A,'U','s','e','r','-','A','g','e','n',
  't',':',' ','F','o','x','t','r','o','t','/',0
#data byte _str_fbHttpRequestL2_4 = 
  '.',0
#data byte _str_fbHttpRequestL2_5 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',
  ':',' ',0
#data byte _str_fbHttpRequestL2_6 = 
  $0D,$0A,'A','c','c','e','p','t',':',' ','t','e','x','t','/','*',';','q','=','0',
  '.','9',',',' ','*','/','*',';','q','=','0','.','1',$0D,$0A,'H','o','s','t',':',
  ' ',0
#data byte _str_fbHttpRequestL2_7 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',
  ':',' ','a','p','p','l','i','c','a','t','i','o','n','/','x','-','w','w','w','-',
  'f','o','r','m','-','u','r','l','e','n','c','o','d','e','d',$0D,$0A,'A','c','c',
  'e','p','t',':',' ','t','e','x','t','/','*',';','q','=','0','.','9',',',' ','*',
  '/','*',';','q','=','0','.','1',$0D,$0A,'H','o','s','t',':',' ',0
#data byte _str_fbHttpRequestL2_8 = 
  $0D,$0A,'A','u','t','h','o','r','i','z','a','t','i','o','n',':',' ','B','a','s',
  'i','c',' ',0
#data byte _str_fbHttpRequestL2_9 = 
  $0D,$0A,'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',' ',0
#data byte _str_fbHttpRequestL2_10 = 
  $0D,$0A,'C','o','n','n','e','c','t','i','o','n',':',' ','C','l','o','s','e',$0D,
  $0A,$0D,$0A,0
#data byte _str_fbHttpRequestL2_11 = 
  'H','T','T','P',0
#data byte _str_fbHttpRequestL2_12 = 
  'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',0
#data byte _str_fbHttpRequestL2_13 = 
  $0D,$0A,$0D,$0A,0
P     61
fbHttpRequestL2_L0:
 LINK __SizeOf(fbHttpRequestL2__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pHelpString
 LD   udint $FFFFFFFF    ; nil
 WRY  pUint
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Post
 LETX __EDGE_R__Post
 WRX  Post
 LDX  Get
 LETX __EDGE_R__Get
 WRX  Get
 LDX  Cancel
 LETX __EDGE_R__Cancel
 WRX  Cancel
#srcline 67 ;  UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 68 ;  IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 516) OR (UniDesc.lenUniOut < 516) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 516
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 516
 LT
 OR  
 JMC  fbHttpRequestL2_L1
#srcline 69 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 70 ;    ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 71 ;    RETURN;
 JMP  fbHttpRequestL2_RET
#srcline 72 ;  END_IF;
fbHttpRequestL2_L1:
#srcline 74 ;  Busy := State <> hs_HttpIdle;
 LDX  State
#debug usint State
 LD   udint 0  ; THttpState#hs_HttpIdle
 EQ
 NEG
 WRX  Busy
#debug_left bool Busy
#srcline 76 ;  TimeOutTon(IN := Busy & NOT DataReady, PT := T#2m);
 LDX  Busy
#debug bool Busy
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 WRX  TimeOutTon~IN
#debug_left bool TimeOutTon~IN
 LD   time 120000
 WRX  TimeOutTon~PT
#debug_left time TimeOutTon~PT
 LEAX TimeOutTon
 CAL  TON_L0
#srcline 78 ;  DataReady := false;
 LD   bool 0       ; false
 WRX  DataReady
#debug_left bool DataReady
#srcline 80 ;  IF TimeOutTon.Q THEN
 LDX  TimeOutTon~Q
#debug bool TimeOutTon.Q
 JMC  fbHttpRequestL2_L3
#srcline 81 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 82 ;    ErrId := 1;
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
#srcline 83 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 84 ;  END_IF;
fbHttpRequestL2_L3:
#srcline 86 ;  IF Cancel THEN
 LDX  Cancel
#debug bool Cancel
 JMC  fbHttpRequestL2_L5
#srcline 87 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 88 ;    Err   := ContLen > 0;
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 89 ;  END_IF;
fbHttpRequestL2_L5:
#srcline 91 ;  CASE State OF
 LDX  State
#debug usint State
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L8
#srcline 92 ;    hs_HttpIdle   :
#srcline 93 ;      r := CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 94 ;      Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 95 ;      IF Post OR Get THEN
 LDX  Post
#debug bool Post
 LDX  Get
#debug bool Get
 OR  
 JMC  fbHttpRequestL2_L9
#srcline 96 ;        WholeLen := 0;
 LD   dint 0
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 97 ;        Err     := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 98 ;        ErrId   := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 99 ;        Result  := 0;
 LD   int 0
 WRX  Result
#debug_left int Result
#srcline 100 ;        authPos := FIND(IN1 := Host, IN2 := '@');
 LDX  Host
#debug string Host
 LEA  _str_fbHttpRequestL2_0
 SFND 
 WRY  authPos
#debug_left uint authPos
#srcline 101 ;        IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequestL2_L11
#srcline 102 ;          lHost := MID(IN := Host, L := 80, P := authPos+1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LD   80
 LDY  authPos
#debug uint authPos
 LD   uint 1
 ADD
 AND  $FFFF
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 103 ;          lNamePass := LEFT(IN := Host, L := authPos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LDY  authPos
#debug uint authPos
 LD   uint 1
 SUB
 AND  $FFFF
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY lNamePass
 WRI  
 LEAY lNamePass
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lNamePass
 PDST   ; Level 1
#srcline 104 ;        ELSE
 JMP  fbHttpRequestL2_L12
fbHttpRequestL2_L11:
#srcline 105 ;          lHost := Host;
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 106 ;        END_IF;
fbHttpRequestL2_L12:
#srcline 107 ;        (*
#srcline 108 ;        pUint := ADR(RecvData);
#srcline 109 ;        pHelpString := pUint;
#srcline 110 ;        *)
#srcline 111 ;        IF Get THEN
 LDX  Get
#debug bool Get
 JMC  fbHttpRequestL2_L13
#srcline 112 ;          BodyLen := 0;
 LD   uint 0
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 113 ;          HelpString := 'GET ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_1
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 114 ;        ELSE
 JMP  fbHttpRequestL2_L14
fbHttpRequestL2_L13:
#srcline 115 ;          BodyLen := postLen;
 LDX  postLen
#debug uint postLen
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 116 ;          lPostLen := postLen;
 LDX  postLen
#debug uint postLen
 WRX  lPostLen
#debug_left uint lPostLen
#srcline 117 ;          HelpString := 'POST ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_2
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 118 ;        END_IF;
fbHttpRequestL2_L14:
#srcline 119 ;        //TODO: Dodelat kontrolu delky vstupnich dat
#srcline 120 ;        pUint := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pUint
 WRIL 
#debug_left pointer pUint
#srcline 121 ;        pUsint := pUint  + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUint);
 LEAY pUint
 LDIL 
#debug pointer pUint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUint
 LDIL 
#debug pointer pUint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 122 ;        //max len 5+255 = 300
#srcline 123 ;        helpstring := ' HTTP/1.0$r$nUser-Agent: Foxtrot/' + USINT_TO_STRING(%S40) + '.' + USINT_TO_STRING(%S41);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_3
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S40
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequestL2_4
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S41
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 124 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 125 ;        //max len 300+33+1+1+1 = 336
#srcline 126 ;        IF LEN(ContentType) > 0 THEN
 LDX  ContentType
#debug string ContentType
 SLEN 
 LD   int 0
 GTS
 JMC  fbHttpRequestL2_L15
#srcline 127 ;          helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nContent-Type: '+ContentType+'$r$nAccept: text/*;q=0.9, */*;q=0.1$r$nHost: ';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_5
 SCON 
 LDX  ContentType
#debug string ContentType
 SCON 
 LEA  _str_fbHttpRequestL2_6
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 128 ;        ELSE
 JMP  fbHttpRequestL2_L16
fbHttpRequestL2_L15:
#srcline 129 ;          helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nContent-Type: application/x-www-form-urlencoded$r$nAccept: text/*;q=0.9, */*;q=0.1$r$nHost: ';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_7
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 130 ;        END_IF;
fbHttpRequestL2_L16:
#srcline 131 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 132 ;        //max len 336+140 = 476
#srcline 133 ;        Err := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 134 ;        REPEAT
fbHttpRequestL2_L17:
 DBG
#srcline 135 ;          l := LEN(lHost);
 LEAX lHost
#debug string lHost
 SLEN 
 WRY  l
#debug_left udint l
#srcline 136 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL2_L19
 JMP  fbHttpRequestL2_L18
fbHttpRequestL2_L19:
#srcline 137 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(lHost), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX lHost
#debug pointer lHost
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 138 ;          
#srcline 139 ;          IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequestL2_L21
#srcline 140 ;            //Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
#srcline 141 ;            helpstring := '$r$nAuthorization: Basic ' + Base64_encode_string(lNamePass);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_8
 SCON 
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LEAY lNamePass
#debug string lNamePass
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 142 ;            l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 143 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL2_L23
 JMP  fbHttpRequestL2_L18
fbHttpRequestL2_L23:
#srcline 144 ;            pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 145 ;          END_IF;
fbHttpRequestL2_L21:
#srcline 146 ;          
#srcline 147 ;          //max len 476+80 = 556!!!
#srcline 148 ;          helpstring := '$r$nContent-Length: ' + UINT_TO_STRING(BodyLen) + '$r$nConnection: Close$r$n$r$n';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_9
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LDX  BodyLen
#debug uint BodyLen
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequestL2_10
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 149 ;          l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 150 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL2_L25
 JMP  fbHttpRequestL2_L18
fbHttpRequestL2_L25:
#srcline 151 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 153 ;          
#srcline 154 ;          //max len 556+44=600!!!
#srcline 155 ;          (*
#srcline 156 ;          IF POST THEN //copy data to post
#srcline 157 ;            l := LEN(data);
#srcline 158 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
#srcline 159 ;            pUsint := pUsint + MemcpyPtr(length := LEN(data), source := ADR(data), dest := pUsint);
#srcline 160 ;            //max len 600+80=680!!!
#srcline 161 ;          END_IF;
#srcline 162 ;          *)
#srcline 163 ;          Err := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 164 ;        UNTIL true END_REPEAT;
 LD   bool -1       ; true
 JMC  fbHttpRequestL2_L17
fbHttpRequestL2_L18:
 NOP  -1
#srcline 165 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequestL2_L27
#srcline 166 ;          ErrId := 3; //delka hlavicka protokolu presahla 512 bytes
 LD   usint 3
 WRX  ErrId
#debug_left usint ErrId
#srcline 167 ;        ELSE
 JMP  fbHttpRequestL2_L28
fbHttpRequestL2_L27:
#srcline 168 ;          SendTo.lenTx := UDINT_TO_UINT(PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint));
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 169 ;          State := hs_HttpSetIP;
 LD   udint 1  ; THttpState#hs_HttpSetIP
 WRX  State
#debug_left usint State
#srcline 170 ;          Busy  := true; //Busy is set in the same cycle when we left idle state!!!
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 171 ;        END_IF;
fbHttpRequestL2_L28:
#srcline 172 ;      END_IF;
fbHttpRequestL2_L9:
 JMP  fbHttpRequestL2_L7
fbHttpRequestL2_L8:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L29
#srcline 173 ;    hs_HttpSetIP:
#srcline 174 ;      IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbHttpRequestL2_L30
#srcline 175 ;          Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 176 ;          ErrId := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 177 ;          State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 178 ;      ELSE
 JMP  fbHttpRequestL2_L31
fbHttpRequestL2_L30:
#srcline 179 ;        rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 180 ;        rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 181 ;        IF SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbHttpRequestL2_L32
#srcline 182 ;          State := hs_HttpConnect;
 LD   udint 2  ; THttpState#hs_HttpConnect
 WRX  State
#debug_left usint State
#srcline 183 ;        END_IF;
fbHttpRequestL2_L32:
#srcline 184 ;      END_IF;
fbHttpRequestL2_L31:
 JMP  fbHttpRequestL2_L7
fbHttpRequestL2_L29:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L34
#srcline 185 ;    hs_HttpConnect:
#srcline 186 ;      r := EstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 187 ;      IF IsEstabTCPconnection(chanCode := chanCode) THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbHttpRequestL2_L35
#srcline 188 ;        State := hs_HttpSend;
 LD   udint 3  ; THttpState#hs_HttpSend
 WRX  State
#debug_left usint State
#srcline 189 ;      END_IF;
fbHttpRequestL2_L35:
 JMP  fbHttpRequestL2_L7
fbHttpRequestL2_L34:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L37
#srcline 190 ;    hs_HttpSend   :
#srcline 191 ;      SendTo(rq := 1, chanCode := chanCode, data := void(RecvData));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  RecvData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 192 ;      ResRecv    := false;
 LD   bool 0       ; false
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 193 ;      LenRecv    := false;
 LD   bool 0       ; false
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 194 ;      HeaderRecv := false;
 LD   bool 0       ; false
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 195 ;      WasEOL     := false;
 LD   bool 0       ; false
 WRX  WasEOL
#debug_left bool WasEOL
#srcline 196 ;      ContLen    := -1;
 LD   dint -1
 WRX  ContLen
#debug_left dint ContLen
#srcline 197 ;      State := hs_HttpSendPost;
 LD   udint 5  ; THttpState#hs_HttpSendPost
 WRX  State
#debug_left usint State
 JMP  fbHttpRequestL2_L7
fbHttpRequestL2_L37:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L38
#srcline 198 ;    hs_HttpSendPost :
#srcline 199 ;      IF BodyLen > 0 THEN
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL2_L39
#srcline 200 ;        SendTo(rq := 1, chanCode := chanCode, data := void(Data[lPostLen-BodyLen]), lenTx := MIN(512,BodyLen));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  Data
 LDX  lPostLen
#debug uint lPostLen
 LDX  BodyLen
#debug uint BodyLen
 SUB
 AND  $FFFF
 RCHK 1535   ; Range Check
 ADD     ; + offset 
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LD   uint 512
 LDX  BodyLen
#debug uint BodyLen
 MIN
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 201 ;        IF SendTo.mesSent THEN
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbHttpRequestL2_L41
#srcline 202 ;          BodyLen := BodyLen - MIN(512,BodyLen);
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 512
 LDX  BodyLen
#debug uint BodyLen
 MIN
 SUB
 AND  $FFFF
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 203 ;        END_IF;
fbHttpRequestL2_L41:
#srcline 204 ;      ELSE
 JMP  fbHttpRequestL2_L40
fbHttpRequestL2_L39:
#srcline 205 ;        State := hs_HttpReceivingData;
 LD   udint 4  ; THttpState#hs_HttpReceivingData
 WRX  State
#debug_left usint State
#srcline 206 ;      END_IF;
fbHttpRequestL2_L40:
 JMP  fbHttpRequestL2_L7
fbHttpRequestL2_L38:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L43
#srcline 207 ;    hs_HttpReceivingData  :
#srcline 208 ;      RecvFrom(rq := 1, chanCode := chanCode, lenRx := 512, data := void(RecvData));
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 512
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LDX  RecvData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 209 ;      IF RecvFrom.mesRec THEN
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbHttpRequestL2_L44
#srcline 210 ;        IF HeaderRecv THEN
 LDX  HeaderRecv
#debug bool HeaderRecv
 JMC  fbHttpRequestL2_L46
#srcline 211 ;          DataLen := RecvFrom.lenData;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 WRX  DataLen
#debug_left uint DataLen
#srcline 212 ;          ContLen := ContLen - UINT_TO_DINT(DataLen);
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 213 ;          pUsint  := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 214 ;        ELSE
 JMP  fbHttpRequestL2_L47
fbHttpRequestL2_L46:
#srcline 215 ;          IF RecvFrom.lenData < 511 THEN
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 511
 LT
 JMC  fbHttpRequestL2_L48
#srcline 216 ;            RecvData[RecvFrom.lenData] := 0;
 LD   usint 0
 LDX  RecvData
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 RCHK 511   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint RecvData[RecvFrom.lenData]
#srcline 217 ;          END_IF;
fbHttpRequestL2_L48:
#srcline 218 ;          pHelpString := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 219 ;          IF NOT ResRecv & FIND(IN1 := pHelpString^, IN2 := 'HTTP') = 1 THEN
 LDX  ResRecv
#debug bool ResRecv
 NEG
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 LEA  _str_fbHttpRequestL2_11
 SFND 
 LD   int 1
 EQ
 AND
 JMC  fbHttpRequestL2_L50
#srcline 220 ;            ResRecv := true;
 LD   bool -1       ; true
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 221 ;            pHelpString := pHelpString + 9;
 LEAY pHelpString
 LDIL 
#debug pointer pHelpString
 LD   udint 9
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 222 ;            Result := STRING_TO_INT(pHelpString^);
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300B;  IEC_STRING _TO_ IEC_INT
 WRX  Result
#debug_left int Result
#srcline 223 ;//            Debug1       := pHelpString^;
#srcline 224 ;          END_IF;
fbHttpRequestL2_L50:
#srcline 225 ;                                               //012345678901234
#srcline 226 ;          i := FIND(IN1 := pHelpString^, IN2 := 'Content-Length:');
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 LEA  _str_fbHttpRequestL2_12
 SFND 
 WRY  i
#debug_left uint i
#srcline 227 ;          IF NOT LenRecv & i > 0 THEN
 LDX  LenRecv
#debug bool LenRecv
 NEG
 LDY  i
#debug uint i
 LD   uint 0
 GT
 AND
 JMC  fbHttpRequestL2_L52
#srcline 228 ;            LenRecv := true;
 LD   bool -1       ; true
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 229 ;            pHelpString := pHelpString + UINT_TO_UDINT(i+15);
 LEAY pHelpString
 LDIL 
#debug pointer pHelpString
 LDY  i
#debug uint i
 LD   uint 15
 ADD
 AND  $FFFF
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 230 ;            ContLen     := STRING_TO_DINT(pHelpString^);
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300D;  IEC_STRING _TO_ IEC_DINT
 WRX  ContLen
#debug_left dint ContLen
#srcline 231 ;//            Debug2       := pHelpString^;
#srcline 232 ;          END_IF;
fbHttpRequestL2_L52:
#srcline 233 ;          
#srcline 234 ;          pHelpString := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 235 ;          
#srcline 236 ;          IF WasEOL & RecvData[0] = 13 & RecvData[1] = 10 THEN
 LDX  WasEOL
#debug bool WasEOL
 LDX  RecvData
 LDI  
#debug usint RecvData[0]
 LD   usint 13
 EQ
 AND
 LDX  RecvData
 ADD  1  ; + offset 
 LDI  
#debug usint RecvData[1]
 LD   usint 10
 EQ
 AND
 JMC  fbHttpRequestL2_L54
#srcline 237 ;            i := 65535; //-1
 LD   uint 65535
 WRY  i
#debug_left uint i
#srcline 238 ;          ELSE
 JMP  fbHttpRequestL2_L55
fbHttpRequestL2_L54:
#srcline 239 ;            i := FIND(IN1 := pHelpString^, IN2 := '$r$n$r$n');
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 LEA  _str_fbHttpRequestL2_13
 SFND 
 WRY  i
#debug_left uint i
#srcline 240 ;          END_IF;
fbHttpRequestL2_L55:
#srcline 241 ;          IF i <> 0 THEN
 LDY  i
#debug uint i
 LD   uint 0
 EQ
 NEG
 JMC  fbHttpRequestL2_L56
#srcline 242 ;            HeaderRecv := true;
 LD   bool -1       ; true
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 243 ;            pUsint     := pHelpString + UINT_TO_UDINT(i+3);
 LEAY pHelpString
 LDIL 
#debug pointer pHelpString
 LDY  i
#debug uint i
 LD   uint 3
 ADD
 AND  $FFFF
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 244 ;            DataLen    := RecvFrom.lenData - i - 3;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 3
 SUB
 AND  $FFFF
 WRX  DataLen
#debug_left uint DataLen
#srcline 245 ;            MemcpyPtr(source := pUsint, dest := ADR(RecvData), length := UINT_TO_UDINT(DataLen));
 NXT
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LDX  RecvData
#debug pointer RecvData
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  DataLen
#debug uint DataLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 246 ;            ContLen := ContLen - UINT_TO_DINT(DataLen);
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 247 ;            IF NOT LenRecv THEN
 LDX  LenRecv
#debug bool LenRecv
 NEG
 JMC  fbHttpRequestL2_L58
#srcline 248 ;              ContLen := 0;
 LD   dint 0
 WRX  ContLen
#debug_left dint ContLen
#srcline 249 ;            END_IF;
fbHttpRequestL2_L58:
#srcline 250 ;            WholeLen := ContLen;
 LDX  ContLen
#debug dint ContLen
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 251 ;          ELSE
 JMP  fbHttpRequestL2_L57
fbHttpRequestL2_L56:
#srcline 252 ;            DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 253 ;          END_IF;
fbHttpRequestL2_L57:
#srcline 254 ;          IF RecvFrom.lenData = 0 THEN
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 0
 EQ
 JMC  fbHttpRequestL2_L60
#srcline 255 ;            WasEOL := false;
 LD   bool 0       ; false
 WRX  WasEOL
#debug_left bool WasEOL
#srcline 256 ;          ELSE
 JMP  fbHttpRequestL2_L61
fbHttpRequestL2_L60:
#srcline 257 ;            WasEOL := RecvData[RecvFrom.lenData-1] = 10;
 LDX  RecvData
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 1
 SUB
 AND  $FFFF
 RCHK 511   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint RecvData[RecvFrom.lenData-1]
 LD   usint 10
 EQ
 WRX  WasEOL
#debug_left bool WasEOL
#srcline 258 ;          END_IF;
fbHttpRequestL2_L61:
#srcline 259 ;        END_IF;
fbHttpRequestL2_L47:
#srcline 260 ;        DataReady := DataLen > 0;
 LDX  DataLen
#debug uint DataLen
 LD   uint 0
 GT
 WRX  DataReady
#debug_left bool DataReady
#srcline 261 ;      ELSE
 JMP  fbHttpRequestL2_L45
fbHttpRequestL2_L44:
#srcline 262 ;        DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 263 ;      END_IF;
fbHttpRequestL2_L45:
#srcline 264 ;      
#srcline 265 ;      //bDebug := NOT IsEstabTCPconnection(chanCode := chanCode) & ContLen > 0 & NOT DataReady;
#srcline 267 ;      IF NOT IsEstabTCPconnection(chanCode := chanCode) & NOT DataReady THEN //NOT IsEstabTCPconnection(chanCode := chanCode) & NOT DataReady THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 NEG
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 JMC  fbHttpRequestL2_L62
#srcline 268 ;        Err    := ContLen > 0;
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 269 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequestL2_L64
#srcline 270 ;          ErrId := 2;
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
#srcline 271 ;        END_IF;
fbHttpRequestL2_L64:
#srcline 272 ;//        ErrId  := BOOL_TO_USINT(Err)*2; //Set 2 if error occured
#srcline 273 ;        Done   := NOT Err;
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 274 ;        State  := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 275 ;      END_IF;
fbHttpRequestL2_L62:
#srcline 277 ;      IF Close & ContLen = 0 THEN
 LDX  Close
#debug bool Close
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 EQ
 AND
 JMC  fbHttpRequestL2_L66
#srcline 278 ;        CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 279 ;      END_IF;
fbHttpRequestL2_L66:
 JMP  fbHttpRequestL2_L7
fbHttpRequestL2_L43:
fbHttpRequestL2_L7:
#srcline 283 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbHttpRequestL2_L68
#srcline 284 ;    IF WholeLen > 0 THEN
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 0
 GTS
 JMC  fbHttpRequestL2_L70
#srcline 285 ;      Progress := DINT_TO_SINT(((WholeLen - ContLen) * 100 + WholeLen / 2) / WholeLen);
 LDX  WholeLen
#debug dint WholeLen
 LDX  ContLen
#debug dint ContLen
 SUB
 LD   dint 100
 MULS
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 2
 DIVS
 ADD
 LDX  WholeLen
#debug dint WholeLen
 DIVS
 EXTB
 WRX  Progress
#debug_left sint Progress
#srcline 286 ;    ELSE
 JMP  fbHttpRequestL2_L71
fbHttpRequestL2_L70:
#srcline 287 ;      Progress := -1;
 LD   sint -1
 WRX  Progress
#debug_left sint Progress
#srcline 288 ;    END_IF;
fbHttpRequestL2_L71:
#srcline 289 ;  END_IF;
fbHttpRequestL2_L68:
#srcline 291 ;END_FUNCTION_BLOCK
fbHttpRequestL2_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbHttpRequestL2__InstanceInit__:
 LINK 0
 LD   uint 80
 WRX  port
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBSPLITURLADDRESS.ST'
#pou fbSplitUrlAddress
#srcline 1 ;FUNCTION_BLOCK fbSplitUrlAddress

#struct fbSplitUrlAddress__temp__
  bool dnsRequest,
  string[256] tmpStr,
  int pos,
  pointer pStr,
  udint pPos,
  string[257] PS0__st__
#data byte _str_fbSplitUrlAddress_0 = 
  ':','/','/',0
#data byte _str_fbSplitUrlAddress_1 = 
  '/',0
#data byte _str_fbSplitUrlAddress_2 = 
  '',0
#data byte _str_fbSplitUrlAddress_3 = 
  '@',0
#data byte _str_fbSplitUrlAddress_4 = 
  ':',0
P     61
fbSplitUrlAddress_L0:
 LINK __SizeOf(fbSplitUrlAddress__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pStr
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  split
 LETX __EDGE_R__split
 WRX  split
#srcline 39 ;  Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 40 ;  IF split THEN
 LDX  split
#debug bool split
 JMC  fbSplitUrlAddress_L1
#srcline 41 ;    // zpracovat pageName
#srcline 42 ;    pos := FIND( urlAddress, '://');
 LDX  urlAddress
#debug string urlAddress
 LEA  _str_fbSplitUrlAddress_0
 SFND 
 WRY  pos
#debug_left int pos
#srcline 43 ;    IF pos <> 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  fbSplitUrlAddress_L3
#srcline 44 ;      tmpStr := DELETE( IN := urlAddress, L := pos+2 , P := 1);    // delete '//http://'
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LDX  urlAddress
#debug string urlAddress
 LDY  pos
#debug int pos
 EXTW 
 LD   int 2
 ADD
 EXTW
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 45 ;    ELSE
 JMP  fbSplitUrlAddress_L4
fbSplitUrlAddress_L3:
#srcline 46 ;      tmpStr := urlAddress;
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LDX  urlAddress
#debug string urlAddress
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 47 ;    END_IF;
fbSplitUrlAddress_L4:
#srcline 48 ;    pos := FIND( tmpStr, '/');        // separate domain name and action
 LEAY tmpStr
#debug string tmpStr
 LEA  _str_fbSplitUrlAddress_1
 SFND 
 WRY  pos
#debug_left int pos
#srcline 49 ;    IF pos <> 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  fbSplitUrlAddress_L5
#srcline 50 ;      host := tmpStr;
 LD   0   ; null string
 LDX  host
 WRI  
 LDX  host
 LD   80
 DST    ; Level 1
 LEAY tmpStr
#debug string tmpStr
 SCON 
#debug_left string host
 PDST   ; Level 1
#srcline 51 ;      host := DELETE( IN := host, L := 255, P := pos);   // domain name
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  host
#debug string host
 LD   255
 LDY  pos
#debug int pos
 EXTW 
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  host
 WRI  
 LDX  host
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string host
 PDST   ; Level 1
#srcline 52 ;      Action   := DELETE( IN := tmpStr, L := pos-1, P := 1);   // action
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAY tmpStr
#debug string tmpStr
 LDY  pos
#debug int pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Action
 WRI  
 LDX  Action
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Action
 PDST   ; Level 1
#srcline 53 ;    ELSE
 JMP  fbSplitUrlAddress_L6
fbSplitUrlAddress_L5:
#srcline 54 ;      host := tmpStr;
 LD   0   ; null string
 LDX  host
 WRI  
 LDX  host
 LD   80
 DST    ; Level 1
 LEAY tmpStr
#debug string tmpStr
 SCON 
#debug_left string host
 PDST   ; Level 1
#srcline 55 ;      Action := '';
 LD   0   ; null string
 LDX  Action
 WRI  
 LDX  Action
 LD   80
 DST    ; Level 1
 LEA  _str_fbSplitUrlAddress_2
 SCON 
#debug_left string Action
 PDST   ; Level 1
#srcline 56 ;    END_IF;
fbSplitUrlAddress_L6:
#srcline 57 ;    
#srcline 58 ;    pStr := ADR(host);
 LDX  host
#debug pointer host
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 59 ;    pPos := FIND(host, '@'); //try to find basic autentification
 LDX  host
#debug string host
 LEA  _str_fbSplitUrlAddress_3
 SFND 
 WRY  pPos
#debug_left udint pPos
#srcline 60 ;    IF pPos > 0 THEN
 LDY  pPos
#debug udint pPos
 LD   udint 0
 GT
 JMC  fbSplitUrlAddress_L7
#srcline 61 ;      pStr := pStr + pPos;
 LEAY pStr
 LDIL 
#debug pointer pStr
 LDY  pPos
#debug udint pPos
 ADD
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 62 ;    END_IF;
fbSplitUrlAddress_L7:
#srcline 63 ;    
#srcline 64 ;    pos := FIND( pStr^, ':');       // try to find port number
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 LEA  _str_fbSplitUrlAddress_4
 SFND 
 WRY  pos
#debug_left int pos
#srcline 65 ;    IF pos <> 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  fbSplitUrlAddress_L9
#srcline 66 ;      tmpStr   := DELETE( IN := pStr^, L := pos, P := 1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 LDY  pos
#debug int pos
 EXTW 
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 67 ;      host := DELETE( IN := host, L := 255, P := pPos+INT_TO_UDINT(pos));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  host
#debug string host
 LD   255
 LDY  pPos
#debug udint pPos
 LDY  pos
#debug int pos
 EXTW 
 ADD
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  host
 WRI  
 LDX  host
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string host
 PDST   ; Level 1
#srcline 68 ;      port := STRING_TO_UINT( tmpStr);
 LEAY tmpStr
#debug string tmpStr
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 LDX  port
 WRIW 
#debug_left uint port
#srcline 69 ;    ELSE
 JMP  fbSplitUrlAddress_L10
fbSplitUrlAddress_L9:
#srcline 70 ;      port := 80;
 LD   uint 80
 LDX  port
 WRIW 
#debug_left uint port
#srcline 71 ;    END_IF;
fbSplitUrlAddress_L10:
#srcline 72 ;    // IP address
#srcline 73 ;    ipAdr := STRING_TO_IPADR(IPAdr := pStr^);
 NXT
 LD   0   ; null string
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 WRI 
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 LD   80
 DST    ; Level 1
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 SCON 
#debug_left string __Instance__STRING_TO_IPADR~IPAdr
 PDST   ; Level 1
 PRV
 LEA  __Instance__STRING_TO_IPADR
 CAL  STRING_TO_IPADR_L0
 LDX  ipAdr
#debug_left pointer ipAdr
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 74 ;    NsLookUp.Name := pStr^;
 LD   0   ; null string
 LEAX NsLookUp
 ADD  5  ; + offset 
 WRI  
 LEAX NsLookUp
 ADD  5  ; + offset 
 LD   80
 DST    ; Level 1
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 SCON 
#debug_left string NsLookUp.Name
 PDST   ; Level 1
#srcline 76 ;    dnsRequest := ipAdr = HTTP_IP_NULL;
 LDX  ipAdr
 LEA  __Const__fbSplitUrlAddress_HTTP_IP_NULL
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 WRY  dnsRequest
#debug_left bool dnsRequest
#srcline 77 ;    Busy := dnsRequest;
 LDY  dnsRequest
#debug bool dnsRequest
 WRX  Busy
#debug_left bool Busy
#srcline 78 ;    Done := NOT Busy;
 LDX  Busy
#debug bool Busy
 NEG
 WRX  Done
#debug_left bool Done
#srcline 79 ;    IF Done THEN
 LDX  Done
#debug bool Done
 JMC  fbSplitUrlAddress_L11
#srcline 80 ;      Err := 0; ErrId := 0;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 81 ;      RETURN;
 JMP  fbSplitUrlAddress_RET
#srcline 82 ;    END_IF;
fbSplitUrlAddress_L11:
#srcline 83 ;  END_IF;
fbSplitUrlAddress_L1:
#srcline 85 ;  // prevest domainove jmeno na IP adresu (je-li to potreba)
#srcline 87 ;  NsLookUp( getIP := dnsRequest, dnsIP := GetDNS_IP(ethChan := ETH1), IP := ipAdr, Done => Done, Busy => Busy, Err => Err, ErrId => ErrId);
 LDY  dnsRequest
#debug bool dnsRequest
 WRX  NsLookUp~getIP
#debug_left bool NsLookUp~getIP
 NXT
 LD   usint 225
 WR   __Instance__GetDNS_IP~ethChan
#debug_left usint __Instance__GetDNS_IP~ethChan
 PRV
 LEA  __Instance__GetDNS_IP
 CAL  GetDNS_IP_L0
 LEAX NsLookUp~dnsIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LDX  ipAdr
 WRX  NsLookUp~IP
#debug_left pointer NsLookUp.IP
 LEAX NsLookUp
 CAL  fbNsLookUpEx_L0
; output assigment 
 LDX  NsLookUp~Done
#debug bool NsLookUp~Done
 WRX  Done
#debug_left bool Done
 LDX  NsLookUp~Busy
#debug bool NsLookUp~Busy
 WRX  Busy
#debug_left bool Busy
 LDX  NsLookUp~Err
#debug bool NsLookUp~Err
 WRX  Err
#debug_left bool Err
 LDX  NsLookUp~ErrId
#debug usint NsLookUp~ErrId
 WRX  ErrId
#debug_left usint ErrId
#srcline 89 ;END_FUNCTION_BLOCK
fbSplitUrlAddress_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbSplitUrlAddress__InstanceInit__:
 LINK 0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBRETRIVEFROMFTP.ST'
#pou fbRetriveFromFtp
#srcline 1 ;FUNCTION_BLOCK fbRetriveFromFtp
#table byte __Init___fbRetriveFromFtp_h = 
      0,  0;

#struct fbRetriveFromFtp__temp__
  TUniDesc UniDescCom,
  uint tmpReplyCode,
  udint tmpud,
  pointer pStr,
  uint iPos,
  uint iIdx,
  string[2] endLocal,
  string[2] endRemot,
  uint ReplyCodeClass,
  usint P0__st__,
  string[257] PS0__st__
#data byte _str_fbRetriveFromFtp_0 = 
  'U','S','E','R',' ',0
#data byte _str_fbRetriveFromFtp_1 = 
  'P','A','S','S',' ',0
#data byte _str_fbRetriveFromFtp_2 = 
  'T','Y','P','E',' ','I',0
#data byte _str_fbRetriveFromFtp_3 = 
  'P','A','S','V',$0D,$0A,0
#data byte _str_fbRetriveFromFtp_4 = 
  '(',0
#data byte _str_fbRetriveFromFtp_5 = 
  ',',0
#data byte _str_fbRetriveFromFtp_6 = 
  'S','I','Z','E',' ',0
#data byte _str_fbRetriveFromFtp_7 = 
  'R','E','T','R',' ',0
#data byte _str_fbRetriveFromFtp_8 = 
  'Q','U','I','T',0
P     61
fbRetriveFromFtp_L0:
 LINK __SizeOf(fbRetriveFromFtp__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pStr
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Retrieve
 LETX __EDGE_R__Retrieve
 WRX  Retrieve
#srcline 76 ;  UniDescCom := GetChanDesc(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDescCom
#debug_left pointer UniDescCom
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 77 ;  IF (UniDescCom.modeChan <> 5) OR (UniDescCom.lenUniIn <> 259) OR (UniDescCom.lenUniOut < 259) THEN
 LDY  UniDescCom~modeChan
#debug byte UniDescCom.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDescCom~lenUniIn
#debug uint UniDescCom.lenUniIn
 LD   uint 259
 EQ
 NEG
 OR  
 LDY  UniDescCom~lenUniOut
#debug uint UniDescCom.lenUniOut
 LD   uint 259
 LT
 OR  
 JMC  fbRetriveFromFtp_L1
#srcline 78 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 79 ;    ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 80 ;    RETURN;
 JMP  fbRetriveFromFtp_RET
#srcline 81 ;  END_IF;
fbRetriveFromFtp_L1:
#srcline 83 ;  UniDescCom := GetChanDesc(chanCode := chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDescCom
#debug_left pointer UniDescCom
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 84 ;  IF (UniDescCom.modeChan <> 5) OR (UniDescCom.lenUniIn <> 259) THEN
 LDY  UniDescCom~modeChan
#debug byte UniDescCom.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDescCom~lenUniIn
#debug uint UniDescCom.lenUniIn
 LD   uint 259
 EQ
 NEG
 OR  
 JMC  fbRetriveFromFtp_L3
#srcline 85 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 86 ;    ErrId := 253;
 LD   usint 253
 WRX  ErrId
#debug_left usint ErrId
#srcline 87 ;    RETURN;
 JMP  fbRetriveFromFtp_RET
#srcline 88 ;  END_IF;
fbRetriveFromFtp_L3:
#srcline 90 ;  Err   := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 91 ;  Done  := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 93 ;  timeoutCom(PT := T#30s); //timeout
 LD   time 30000
 WRX  timeoutCom~PT
#debug_left time timeoutCom~PT
 LEAX timeoutCom
 CAL  TON_L0
#srcline 94 ;  KeepAliveTCP(rq := State = fss_RxData, chanCode := chanCodeCom, PT := T#30s);
 LDX  State
#debug usint State
 LD   udint 28  ; TFtpStoreState#fss_RxData
 EQ
 WRX  KeepAliveTCP~rq
#debug_left bool KeepAliveTCP~rq
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  KeepAliveTCP~chanCode
#debug_left uint KeepAliveTCP~chanCode
 LD   time 30000
 WRX  KeepAliveTCP~PT
#debug_left time KeepAliveTCP~PT
 LEAX KeepAliveTCP
 CAL  fbKeepAliveTCP_L0
#srcline 96 ;  IF timeoutCom.Q THEN
 LDX  timeoutCom~Q
#debug bool timeoutCom.Q
 JMC  fbRetriveFromFtp_L5
#srcline 97 ;    state  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
#srcline 98 ;    eErrId := 1;
 LD   usint 1
 WRX  eErrId
#debug_left usint eErrId
#srcline 99 ;  END_IF;
fbRetriveFromFtp_L5:
#srcline 101 ;  IF NOT TRO THEN
 LDX  TRO
#debug bool TRO
 NEG
 JMC  fbRetriveFromFtp_L7
#srcline 102 ;    if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L9
#srcline 103 ;      tmpReplyCode := STRING_TO_UINT(cmdCom);
 LEAX cmdCom
#debug string cmdCom
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 WRY  tmpReplyCode
#debug_left uint tmpReplyCode
#srcline 104 ;      ReplyCodeClass := tmpReplyCode / 100;
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 100
 DIVL
 AND  $FFFF
 WRY  ReplyCodeClass
#debug_left uint ReplyCodeClass
#srcline 105 ;      IF Busy AND NOT Err THEN
 LDX  Busy
#debug bool Busy
 LDX  Err
#debug bool Err
 NEG
 AND
 JMC  fbRetriveFromFtp_L11
#srcline 106 ;        ReplyCode := tmpReplyCode;
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 107 ;      END_IF;
fbRetriveFromFtp_L11:
#srcline 108 ;    end_if;
fbRetriveFromFtp_L9:
#srcline 110 ;    CASE state OF
 LDX  state
#debug usint state
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L14
#srcline 111 ;      // inicializace ------------------------------------------------------------
#srcline 112 ;      fss_Init :
#srcline 113 ;        busy        := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 114 ;        state       := fss_Idle;
 LD   udint 1  ; TFtpStoreState#fss_Idle
 WRX  state
#debug_left usint state
#srcline 115 ;        // nenavazovat spojeni
#srcline 116 ;        CloseTCPconnection(chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 117 ;        CloseTCPconnection(chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 118 ;        IF h <> INVALID_HANDLE_VALUE THEN
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbRetriveFromFtp_L15
#srcline 119 ;          FileClose(hFile := h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 120 ;          h := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  h
#debug_left udint h
#srcline 121 ;        END_IF;
fbRetriveFromFtp_L15:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L14:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L17
#srcline 122 ;      // cekani na start ---------------------------------------------------------
#srcline 123 ;      fss_Idle :
#srcline 124 ;        if Retrieve then
 LDX  Retrieve
#debug bool Retrieve
 JMC  fbRetriveFromFtp_L18
#srcline 125 ;          // vycistime prijimaci a vysilaci buffer
#srcline 126 ;          Recv_From_Com.getMes  := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 127 ;          //Send_To_Com.rq    := 0;
#srcline 128 ;          Send_To_Com.lenTx := 0;
 LD   uint 0
 WRX  Send_To_Com~lenTx
#debug_left uint Send_To_Com.lenTx
#srcline 129 ;          state             := fss_IpCom;
 LD   udint 3  ; TFtpStoreState#fss_IpCom
 WRX  state
#debug_left usint state
#srcline 130 ;          busy              := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 131 ;          ErrId             := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 132 ;          eErrId            := 0;
 LD   usint 0
 WRX  eErrId
#debug_left usint eErrId
#srcline 133 ;          ReplyCode         := 0;
 LD   uint 0
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 134 ;          lRemotName        := RemotName;   //ulozit vzdalene jmeno
 LD   0   ; null string
 LEAX lRemotName
 WRI  
 LEAX lRemotName
 LD   80
 DST    ; Level 1
 LDX  RemotName
#debug string RemotName
 SCON 
#debug_left string lRemotName
 PDST   ; Level 1
#srcline 135 ;          idPos             := 0;
 LD   udint 0
 WRX  idPos
#debug_left udint idPos
#srcline 136 ;          //Progress          := 0;
#srcline 137 ;          _FindNextPathSeparator(In := lRemotName, Pos := idPos);
 NXT
 LEAX lRemotName
 WR   __Instance___FindNextPathSeparator~In
#debug_left pointer __Instance___FindNextPathSeparator.In
 LEAX idPos
 WR   __Instance___FindNextPathSeparator~Pos
#debug_left pointer __Instance___FindNextPathSeparator.Pos
 PRV
 LEA  __Instance___FindNextPathSeparator
 CAL  _FindNextPathSeparator_L0
#srcline 138 ;        end_if;
fbRetriveFromFtp_L18:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L17:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L20
#srcline 139 ;      // nastavit IP
#srcline 140 ;      fss_IpCom :
#srcline 141 ;        IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbRetriveFromFtp_L21
#srcline 142 ;          Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 143 ;          ErrId  := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 144 ;          state  := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
#srcline 145 ;        ELSE
 JMP  fbRetriveFromFtp_L22
fbRetriveFromFtp_L21:
#srcline 146 ;          rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAX rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 147 ;          rea.remotePort := port;
 LDX  port
#debug uint port
 WRX  rea~remotePort
#debug_left uint rea.remotePort
#srcline 148 ;          rea.localPort  := 0;
 LD   uint 0
 WRX  rea~localPort
#debug_left uint rea.localPort
#srcline 149 ;          IF SetRemoteIPaddress(rq := 1, chanCode := chanCodeCom, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbRetriveFromFtp_L23
#srcline 150 ;            state := fss_Connect;
 LD   udint 4  ; TFtpStoreState#fss_Connect
 WRX  state
#debug_left usint state
#srcline 151 ;          END_IF;
fbRetriveFromFtp_L23:
#srcline 152 ;        END_IF;
fbRetriveFromFtp_L22:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L20:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L25
#srcline 153 ;      fss_Connect :
#srcline 154 ;        EstabTCPconnection(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 155 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 156 ;        IF IsEstabTCPconnection(chanCode := chanCodeCom) THEN
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbRetriveFromFtp_L26
#srcline 157 ;          state := fss_Rx220;
 LD   udint 5  ; TFtpStoreState#fss_Rx220
 WRX  state
#debug_left usint state
#srcline 158 ;        END_IF;
fbRetriveFromFtp_L26:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L25:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L28
#srcline 159 ;      fss_Rx220 :
#srcline 160 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L29
#srcline 161 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 162 ;          IF tmpReplyCode = 220 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 220
 EQ
 JMC  fbRetriveFromFtp_L31
#srcline 163 ;            state := fss_TxUser;
 LD   udint 6  ; TFtpStoreState#fss_TxUser
 WRX  state
#debug_left usint state
#srcline 164 ;          ELSE
 JMP  fbRetriveFromFtp_L32
fbRetriveFromFtp_L31:
#srcline 165 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 166 ;          END_IF;
fbRetriveFromFtp_L32:
#srcline 167 ;        END_IF;
fbRetriveFromFtp_L29:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L28:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L33
#srcline 168 ;      fss_TxUser:
#srcline 169 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 170 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 171 ;        cmdCom := 'USER ' + User + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_0
 SCON 
 LDX  User
#debug string User
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 172 ;        state := fss_RxUser;
 LD   udint 7  ; TFtpStoreState#fss_RxUser
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L33:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L34
#srcline 173 ;      fss_RxUser:
#srcline 174 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L35
#srcline 175 ;          IF tmpReplyCode = 331 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 331
 EQ
 JMC  fbRetriveFromFtp_L37
#srcline 176 ;            Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 177 ;            state := fss_TxPass;
 LD   udint 8  ; TFtpStoreState#fss_TxPass
 WRX  state
#debug_left usint state
#srcline 178 ;          ELSIF tmpReplyCode <> 220 THEN
 JMP  fbRetriveFromFtp_L38
fbRetriveFromFtp_L37:
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 220
 EQ
 NEG
 JMC  fbRetriveFromFtp_L39
#srcline 179 ;            Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 180 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 181 ;          END_IF;
 JMP  fbRetriveFromFtp_L38
fbRetriveFromFtp_L39:
fbRetriveFromFtp_L38:
#srcline 182 ;        END_IF;
fbRetriveFromFtp_L35:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L34:
 LD   8
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L40
#srcline 183 ;      fss_TxPass:
#srcline 184 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 185 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 186 ;        cmdCom := 'PASS ' + Pass + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_1
 SCON 
 LDX  Pass
#debug string Pass
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 187 ;        state := fss_RxPass;
 LD   udint 9  ; TFtpStoreState#fss_RxPass
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L40:
 LD   9
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L41
#srcline 188 ;      fss_RxPass:
#srcline 189 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L42
#srcline 190 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 191 ;          IF tmpReplyCode = 230 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 230
 EQ
 JMC  fbRetriveFromFtp_L44
#srcline 192 ;            state := fss_TxType;
 LD   udint 10  ; TFtpStoreState#fss_TxType
 WRX  state
#debug_left usint state
#srcline 193 ;          ELSE
 JMP  fbRetriveFromFtp_L45
fbRetriveFromFtp_L44:
#srcline 194 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 195 ;          END_IF;
fbRetriveFromFtp_L45:
#srcline 196 ;        END_IF;
fbRetriveFromFtp_L42:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L41:
 LD   10
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L46
#srcline 197 ;      fss_TxType:
#srcline 198 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 199 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 200 ;        cmdCom := 'TYPE I' + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_2
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 201 ;        state := fss_RxType;
 LD   udint 11  ; TFtpStoreState#fss_RxType
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L46:
 LD   11
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L47
#srcline 202 ;      fss_RxType:
#srcline 203 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L48
#srcline 204 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 205 ;          IF tmpReplyCode = 200 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 200
 EQ
 JMC  fbRetriveFromFtp_L50
#srcline 206 ;            state := fss_TxPasv;
 LD   udint 12  ; TFtpStoreState#fss_TxPasv
 WRX  state
#debug_left usint state
#srcline 207 ;          ELSE
 JMP  fbRetriveFromFtp_L51
fbRetriveFromFtp_L50:
#srcline 208 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 209 ;          END_IF;
fbRetriveFromFtp_L51:
#srcline 210 ;        END_IF;
fbRetriveFromFtp_L48:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L47:
 LD   12
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L52
#srcline 211 ;      fss_TxPasv:
#srcline 212 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 213 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 214 ;        cmdCom := 'PASV$r$l';
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_3
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 215 ;        state := fss_RxPasv;
 LD   udint 13  ; TFtpStoreState#fss_RxPasv
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L52:
 LD   13
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L53
#srcline 216 ;      fss_RxPasv:
#srcline 217 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L54
#srcline 218 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 219 ;          IF tmpReplyCode = 227 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 227
 EQ
 JMC  fbRetriveFromFtp_L56
#srcline 220 ;            iPos := FIND(IN1 := cmdCom, IN2 := '(');
 LEAX cmdCom
#debug string cmdCom
 LEA  _str_fbRetriveFromFtp_4
 SFND 
 WRY  iPos
#debug_left uint iPos
#srcline 221 ;            pStr := ADR(cmdCom);
 LEAX cmdCom
#debug pointer cmdCom
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 222 ;            WHILE iPos > 0 & iIdx < 6 DO
fbRetriveFromFtp_L58:
 LDY  iPos
#debug uint iPos
 LD   uint 0
 GT
 LDY  iIdx
#debug uint iIdx
 LD   uint 6
 LT
 AND
 JMC  fbRetriveFromFtp_L59
 DBG 
#srcline 223 ;              pStr := pStr + UINT_TO_UDINT(iPos);
 LEAY pStr
 LDIL 
#debug pointer pStr
 LDY  iPos
#debug uint iPos
 ADD
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 224 ;              pasvDat[iIdx] := STRING_TO_USINT(pStr^);
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 LEAX pasvDat
 LDY  iIdx
#debug uint iIdx
 RCHK 5   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint pasvDat[iIdx]
#srcline 225 ;              iIdx := iIdx + 1;
 LDY  iIdx
#debug uint iIdx
 LD   uint 1
 ADD
 AND  $FFFF
 WRY  iIdx
#debug_left uint iIdx
#srcline 226 ;              iPos := FIND(IN1 := pStr^, IN2 := ',');
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 LEA  _str_fbRetriveFromFtp_5
 SFND 
 WRY  iPos
#debug_left uint iPos
#srcline 227 ;            END_WHILE;
 JMP  fbRetriveFromFtp_L58
fbRetriveFromFtp_L59:
 NOP  -1
#srcline 228 ;            state := fss_TxSize;
 LD   udint 29  ; TFtpStoreState#fss_TxSize
 WRX  state
#debug_left usint state
#srcline 229 ;          ELSE
 JMP  fbRetriveFromFtp_L57
fbRetriveFromFtp_L56:
#srcline 230 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 231 ;          END_IF;
fbRetriveFromFtp_L57:
#srcline 232 ;        END_IF;
fbRetriveFromFtp_L54:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L53:
 LD   29
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L60
#srcline 233 ;      fss_TxSize:
#srcline 234 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 235 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 236 ;        cmdCom := 'SIZE ' + lRemotName + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_6
 SCON 
 LEAX lRemotName
#debug string lRemotName
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 237 ;        state := fss_RxSize;
 LD   udint 30  ; TFtpStoreState#fss_RxSize
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L60:
 LD   30
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L61
#srcline 238 ;      fss_RxSize:
#srcline 239 ;        lSize := 0;
 LD   udint 0
 WRX  lSize
#debug_left udint lSize
#srcline 240 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L62
#srcline 241 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 242 ;          IF tmpReplyCode = 213 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 213
 EQ
 JMC  fbRetriveFromFtp_L64
#srcline 243 ;            pStr := ADR(cmdCom) + 4;
 LEAX cmdCom
#debug pointer cmdCom
 LD   udint 4
 ADD
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 244 ;            lSize := STRING_TO_UDINT(pStr^);
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 SCNV $300C;  IEC_STRING _TO_ IEC_UDINT
 WRX  lSize
#debug_left udint lSize
#srcline 245 ;(*          ELSE                              //kdyz to nevyjde budeme to ignorovat?
#srcline 246 ;            state := fss_UnexpectedReply;*)
#srcline 247 ;          END_IF;
fbRetriveFromFtp_L64:
#srcline 248 ;          state := fss_TxRetr;
 LD   udint 27  ; TFtpStoreState#fss_TxRetr
 WRX  state
#debug_left usint state
#srcline 249 ;        END_IF;
fbRetriveFromFtp_L62:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L61:
 LD   27
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L66
#srcline 250 ;      fss_TxRetr:
#srcline 251 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 252 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 253 ;        cmdCom := 'RETR ' + lRemotName + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_7
 SCON 
 LEAX lRemotName
#debug string lRemotName
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 254 ;        data   := 0;
 LD   udint 0
 WRX  data
#debug_left udint data
#srcline 255 ;        state  := fss_IpDat;
 LD   udint 15  ; TFtpStoreState#fss_IpDat
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L66:
 LD   15
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L67
#srcline 256 ;      fss_IpDat:
#srcline 257 ;        rea.remoteIP[0]   := pasvDat[0];
 LDX  pasvDat[0]
#debug usint pasvDat[0]
 WRX  rea~remoteIP[0]
#debug_left usint rea.remoteIP[0]
#srcline 258 ;        rea.remoteIP[1]   := pasvDat[1];
 LDX  pasvDat[1]
#debug usint pasvDat[1]
 WRX  rea~remoteIP[1]
#debug_left usint rea.remoteIP[1]
#srcline 259 ;        rea.remoteIP[2]   := pasvDat[2];
 LDX  pasvDat[2]
#debug usint pasvDat[2]
 WRX  rea~remoteIP[2]
#debug_left usint rea.remoteIP[2]
#srcline 260 ;        rea.remoteIP[3]   := pasvDat[3];
 LDX  pasvDat[3]
#debug usint pasvDat[3]
 WRX  rea~remoteIP[3]
#debug_left usint rea.remoteIP[3]
#srcline 261 ;        rea.remotePort    := USINT_TO_UINT(pasvDat[4])*256+USINT_TO_UINT(pasvDat[5]);
 LDX  pasvDat[4]
#debug usint pasvDat[4]
 AND  $FFFF
 LD   uint 256
 MUL
 AND  $FFFF
 LDX  pasvDat[5]
#debug usint pasvDat[5]
 AND  $FFFF
 ADD
 AND  $FFFF
 WRX  rea~remotePort
#debug_left uint rea.remotePort
#srcline 262 ;        rea.localPort  := 0;
 LD   uint 0
 WRX  rea~localPort
#debug_left uint rea.localPort
#srcline 263 ;        IF SetRemoteIPaddress(rq := 1, chanCode := chanCodeDat, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbRetriveFromFtp_L68
#srcline 264 ;          EstabTCPconnection(chanCode := chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 265 ;          Recv_From_Dat.rq   := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Dat~rq
#debug_left bool Recv_From_Dat.rq
#srcline 266 ;          lTrans := 0;
 LD   udint 0
 WRX  lTrans
#debug_left udint lTrans
#srcline 267 ;          state := fss_RxData;
 LD   udint 28  ; TFtpStoreState#fss_RxData
 WRX  state
#debug_left usint state
#srcline 268 ;        END_IF;
fbRetriveFromFtp_L68:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L67:
 LD   28
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L70
#srcline 269 ;      (*
#srcline 270 ;      fss_WaitForOpen:
#srcline 271 ;        EstabTCPconnection(chanCode := chanCodeDat);
#srcline 272 ;        Recv_From_Dat.rq   := 1;
#srcline 273 ;        IF mesRec THEN
#srcline 274 ;          IF ReplyCode = 150 OR ReplyCode = 125 THEN
#srcline 275 ;            lTrans := 0;
#srcline 276 ;            state := fss_RxData;
#srcline 277 ;          ELSE
#srcline 278 ;            state := fss_UnexpectedReply;
#srcline 279 ;          END_IF;
#srcline 280 ;        END_IF;
#srcline 281 ;      *)
#srcline 282 ;      fss_RxData:
#srcline 283 ;        IF mesRec THEN //prijmout info o connection
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L71
#srcline 284 ;          IF ReplyCode <> 150 AND ReplyCode <> 125 AND ReplyCode <> 226 THEN
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 150
 EQ
 NEG
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 125
 EQ
 NEG
 AND
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 226
 EQ
 NEG
 AND
 JMC  fbRetriveFromFtp_L73
#srcline 285 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 286 ;            CloseTCPconnection(chanCodeDat); //nastala chyba zavreme
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 287 ;          END_IF;
fbRetriveFromFtp_L73:
#srcline 288 ;        END_IF;
fbRetriveFromFtp_L71:
#srcline 289 ;        IF lSize > 0 THEN Progress := REAL_TO_USINT(UDINT_TO_REAL(lTrans)*100.0/UDINT_TO_REAL(lSize)); END_IF;
 LDX  lSize
#debug udint lSize
 LD   udint 0
 GT
 JMC  fbRetriveFromFtp_L75
 LDX  lTrans
#debug udint lTrans
 ULF
 LD   real 100.0
 MUF
 LDX  lSize
#debug udint lSize
 ULF
 DIF
 RND
 UFW
 AND  $FF
 WRX  Progress
#debug_left usint Progress
fbRetriveFromFtp_L75:
#srcline 290 ;        IF ReplyCode = 226 AND NOT Recv_From_Dat.mesRec AND NOT IsEstabTCPconnection(chanCode := chanCodeDat) THEN
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 226
 EQ
 LDX  Recv_From_Dat~mesRec
#debug bool Recv_From_Dat.mesRec
 NEG
 AND
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 NEG
 AND
 JMC  fbRetriveFromFtp_L77
#srcline 291 ;          state := fss_TxQuit;
 LD   udint 19  ; TFtpStoreState#fss_TxQuit
 WRX  state
#debug_left usint state
#srcline 292 ;          Recv_From_Dat.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Dat~rq
#debug_left bool Recv_From_Dat.rq
#srcline 293 ;          CloseTCPconnection(chanCodeDat); //aby se zbytecne neotevrelo znovu
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 294 ;        END_IF;
fbRetriveFromFtp_L77:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L70:
 LD   19
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L79
#srcline 295 ;      fss_TxQuit:
#srcline 296 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 297 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 298 ;        cmdCom := 'QUIT' + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_8
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 299 ;        state := fss_RxQuit;
 LD   udint 20  ; TFtpStoreState#fss_RxQuit
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L79:
 LD   20
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L80
#srcline 300 ;      fss_RxQuit:
#srcline 301 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L81
#srcline 302 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 303 ;          IF tmpReplyCode = 221 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 221
 EQ
 JMC  fbRetriveFromFtp_L83
#srcline 304 ;            state := fss_Close;
 LD   udint 21  ; TFtpStoreState#fss_Close
 WRX  state
#debug_left usint state
#srcline 305 ;          ELSE
 JMP  fbRetriveFromFtp_L84
fbRetriveFromFtp_L83:
#srcline 306 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 307 ;          END_IF;
fbRetriveFromFtp_L84:
#srcline 308 ;        END_IF;
fbRetriveFromFtp_L81:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L80:
 LD   21
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L85
#srcline 309 ;      fss_Close:
#srcline 310 ;        CloseTCPconnection(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 311 ;        IF IsEstabTCPconnection(chanCode := chanCodeCom) = false THEN
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbRetriveFromFtp_L86
#srcline 312 ;          Done := true;
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 313 ;          state := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
#srcline 314 ;        END_IF;
fbRetriveFromFtp_L86:
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L85:
 LD   23
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L88
#srcline 315 ;      fss_UnexpectedReply:
#srcline 316 ;        eErrId := 2;
 LD   usint 2
 WRX  eErrId
#debug_left usint eErrId
#srcline 317 ;        state := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L88:
 LD   22
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L89
#srcline 318 ;      fss_Error :
#srcline 319 ;        Recv_From_Dat.rq := 0; //tohle zavre prijem pro pripad kdyz nastane chyba
 LD   bool 0       ; false
 WRX  Recv_From_Dat~rq
#debug_left bool Recv_From_Dat.rq
#srcline 320 ;        Err := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 321 ;        ErrId := eErrId;
 LDX  eErrId
#debug usint eErrId
 WRX  ErrId
#debug_left usint ErrId
#srcline 322 ;        Recv_From_Com.getMes  := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 323 ;        state := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L13
fbRetriveFromFtp_L89:
fbRetriveFromFtp_L13:
#srcline 325 ;  END_IF;
fbRetriveFromFtp_L7:
#srcline 327 ;  timeoutCom.IN := Recv_From_Com.getMes & NOT Recv_From_Com.getMes;
 LDX  Recv_From_Com~getMes
#debug bool Recv_From_Com.getMes
 LDX  Recv_From_Com~getMes
#debug bool Recv_From_Com.getMes
 NEG
 AND
 WRX  timeoutCom~IN
#debug_left bool timeoutCom.IN
#srcline 329 ;  Send_To_Com   (lenTx := len(cmdCom), chanCode := chanCodeCom, data := void(cmdCom));
 LEAX cmdCom
#debug string cmdCom
 SLEN 
 WRX  Send_To_Com~lenTx
#debug_left uint Send_To_Com~lenTx
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  Send_To_Com~chanCode
#debug_left uint Send_To_Com~chanCode
 LEAX cmdCom
 WRX  Send_To_Com~data
#debug_left pointer Send_To_Com.data
 LEAX Send_To_Com
 CAL  fbSendTo_L0
#srcline 331 ;  //Recv_From_Com (lenRx := 255, chanCode := chanCodeCom, data := void(cmdCom), mesRec => mesRec);
#srcline 332 ;  Recv_From_Com(chanCode := chanCodeCom, lenBuf := 255, lenTxt := 255, buffer := void(cmdBuffer), txtMes := void(cmdCom));
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  Recv_From_Com~chanCode
#debug_left uint Recv_From_Com~chanCode
 LD   uint 255
 WRX  Recv_From_Com~lenBuf
#debug_left uint Recv_From_Com~lenBuf
 LD   uint 255
 WRX  Recv_From_Com~lenTxt
#debug_left uint Recv_From_Com~lenTxt
 LEAX cmdBuffer
 WRX  Recv_From_Com~buffer
#debug_left pointer Recv_From_Com.buffer
 LEAX cmdCom
 WRX  Recv_From_Com~txtMes
#debug_left pointer Recv_From_Com.txtMes
 LEAX Recv_From_Com
 CAL  fbRecvTxt_L0
#srcline 333 ;  mesRec := Recv_From_Com.lenMes > 0;
 LDX  Recv_From_Com~lenMes
#debug uint Recv_From_Com.lenMes
 LD   uint 0
 GT
 WRX  mesRec
#debug_left bool mesRec
#srcline 334 ;  
#srcline 335 ;  Recv_From_Dat(lenRx := 255, chanCode := chanCodeDat, data := void(cmdDat));
 LD   uint 255
 WRX  Recv_From_Dat~lenRx
#debug_left uint Recv_From_Dat~lenRx
 LDX  chanCodeDat
#debug uint chanCodeDat
 WRX  Recv_From_Dat~chanCode
#debug_left uint Recv_From_Dat~chanCode
 LEAX cmdDat
 WRX  Recv_From_Dat~data
#debug_left pointer Recv_From_Dat.data
 LEAX Recv_From_Dat
 CAL  fbRecvFrom_L0
#srcline 336 ;  
#srcline 337 ;  lTrans := lTrans + UINT_TO_UDINT(Recv_From_Dat.lenData);
 LDX  lTrans
#debug udint lTrans
 LDX  Recv_From_Dat~lenData
#debug uint Recv_From_Dat.lenData
 ADD
 WRX  lTrans
#debug_left udint lTrans
#srcline 338 ;  WTFS(fileName := LocalName, srcVar := void(cmdDat), write := Recv_From_Dat.mesRec, close := NOT Recv_From_Dat.rq, size := UINT_TO_UDINT(Recv_From_Dat.lenData));
 LDX  LocalName
 WRX  WTFS~fileName
#debug_left pointer WTFS.fileName
 LEAX cmdDat
 WRX  WTFS~srcVar
#debug_left pointer WTFS.srcVar
 LDX  Recv_From_Dat~mesRec
#debug bool Recv_From_Dat.mesRec
 WRX  WTFS~write
#debug_left bool WTFS~write
 LDX  Recv_From_Dat~rq
#debug bool Recv_From_Dat.rq
 NEG
 WRX  WTFS~close
#debug_left bool WTFS~close
 LDX  Recv_From_Dat~lenData
#debug uint Recv_From_Dat.lenData
 WRX  WTFS~size
#debug_left udint WTFS~size
 LEAX WTFS
 CAL  WriteToFileSeq_L0
#srcline 339 ;  IF WTFS.err AND WTFS.write THEN
 LDX  WTFS~err
#debug bool WTFS.err
 LDX  WTFS~write
#debug bool WTFS.write
 AND
 JMC  fbRetriveFromFtp_L90
#srcline 340 ;    state  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
#srcline 341 ;    eErrId := 3; //chyba souboru
 LD   usint 3
 WRX  eErrId
#debug_left usint eErrId
#srcline 342 ;  END_IF;
fbRetriveFromFtp_L90:
#srcline 343 ;//  TRO_dat := Send_To_Dat.error = 5; //buffer is full wait
#srcline 344 ;  TRO_com := Send_To_Com.error = 5;
 LDX  Send_To_Com~error
#debug usint Send_To_Com.error
 LD   usint 5
 EQ
 WRX  TRO_com
#debug_left bool TRO_com
#srcline 345 ;  TRO := TRO_com OR TRO_dat;
 LDX  TRO_com
#debug bool TRO_com
 LDX  TRO_dat
#debug bool TRO_dat
 OR  
 WRX  TRO
#debug_left bool TRO
#srcline 347 ;  Send_To_Com.rq := Send_To_Com.rq AND TRO_com;
 LDX  Send_To_Com~rq
#debug bool Send_To_Com.rq
 LDX  TRO_com
#debug bool TRO_com
 AND
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 348 ;//  Send_To_Dat.rq := Send_To_Dat.rq  AND TRO_dat;
#srcline 350 ;END_FUNCTION_BLOCK
fbRetriveFromFtp_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbRetriveFromFtp__InstanceInit__:
 LINK 0
 LD   uint 21
 WRX  port
 LEAX Send_To_Com
 CAL  fbSendTo__InstanceInit__
 LEAX Recv_From_Com
 CAL  fbRecvTxt__InstanceInit__
 LEAX Recv_From_Dat
 CAL  fbRecvFrom__InstanceInit__
 LD   0
 SRC  byte __Init___fbRetriveFromFtp_h
 LEAX byte h
 LD   4
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBSENDPING.ST'
#pou fbPingIP
#srcline 14 ;FUNCTION_BLOCK fbPingIP

#struct fbPingIP__temp__
  dint tmp,
  dword[4] myEthAdr,  ; TLocalEthAdr ... myEthAdr[0] = myIP, myEthAdr[1] = myIM, myEthAdr[2] = myGW
  dword hisIP,
  string[82] PS0__st__
#data byte _str_fbPingIP_0 = 
  'C','a','n','n','o','t',' ','r','e','s','o','l','v','e',' ','h','o','s','t',$27,
  's',' ','h','a','r','d','w','a','r','e',' ','a','d','d','r','e','s','s','!',0
#data byte _str_fbPingIP_1 = 
  'I','P',' ','a','d','d','r','e','s','s',' ','o','f',' ','g','a','t','e','w','a',
  'y',' ','i','n',' ','P','L','C',' ','i','s',' ','w','r','o','n','g','!',0
#data byte _str_fbPingIP_2 = 
  'N','o',' ','a','n','s','w','e','r','!',0
P     61
fbPingIP_L0:
 LINK __SizeOf(fbPingIP__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  rqPing
 LETX __EDGE_R__rqPing
 WRX  rqPing
#srcline 44 ;  Done := 0;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 45 ;  timeout( PT := timeLimit);
 LDX  timeLimit
#debug time timeLimit
 WRX  timeout~PT
#debug_left time timeout~PT
 LEAX timeout
 CAL  TON_L0
#srcline 46 ;  IF (rqPing AND NOT busy) OR waitArp THEN
 LDX  rqPing
#debug bool rqPing
 LDX  busy
#debug bool busy
 NEG
 AND
 LDX  waitArp
#debug bool waitArp
 OR  
 JMC  fbPingIP_L1
#srcline 47 ;    busy := 1; err := 0;
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 48 ;    timeout.IN := 1;
 LD   bool -1      ; true
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 49 ;    IF rqPing THEN
 LDX  rqPing
#debug bool rqPing
 JMC  fbPingIP_L3
#srcline 50 ;      waitArp := 0;
 LD   bool 0       ; false
 WRX  waitArp
#debug_left bool waitArp
#srcline 51 ;    END_IF;
fbPingIP_L3:
#srcline 52 ;    {asm}
#srcline 53
      LDX    long hostIP ; IP address of host
#srcline 54
      LDX    ttl         ; time to live
#srcline 55
      LDX    timeLimit   ; timeout
#srcline 56
      LDX    dataLen     ; length of data
#srcline 57
      LDX    pingInfo    ; struct for result
#srcline 58
      LD     1           ; subcode 1 ... send_ping
#srcline 59
      SYS    88          ; internet service
#srcline 60
      WRY    tmp
#srcline 61 ;    {end_asm}
#srcline 62 ;    IF tmp = -2 THEN      // nedopadla sluzba _arp_resolve
 LDY  tmp
#debug dint tmp
 LD   dint -2
 EQ
 JMC  fbPingIP_L5
#srcline 63 ;      IF timeout.Q  THEN
 LDX  timeout~Q
#debug bool timeout.Q
 JMC  fbPingIP_L7
#srcline 64 ;        waitArp := 0;
 LD   bool 0       ; false
 WRX  waitArp
#debug_left bool waitArp
#srcline 65 ;        pingInfo.result := -1;
 LD   dint -1
 LDX  pingInfo
 WRIL 
#debug_left dint pingInfo.result
#srcline 66 ;        pingInfo.hostIP := hostIP;
 LEAX hostIP
#debug pointer hostIP
 SRC  %IB0
 LDX  pingInfo
 ADD  4  ; + offset 
#debug_left pointer pingInfo.hostIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 67 ;        // zkontrolovat, jestli je dobre nastavena brana site
#srcline 68 ;        IF CheckGatewayIP( ethChan := ETH1) THEN
 NXT
 LD   usint 225
 WR   __Instance__CheckGatewayIP~ethChan
#debug_left usint __Instance__CheckGatewayIP~ethChan
 PRV
 LEA  __Instance__CheckGatewayIP
 CAL  CheckGatewayIP_L0
 JMC  fbPingIP_L9
#srcline 69 ;          pingInfo.errMsg := 'Cannot resolve host$'s hardware address!';   // neni odezva na ARP dotaz
 LD   0   ; null string
 LDX  pingInfo
 ADD  21  ; + offset 
 WRI  
 LDX  pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPingIP_0
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 70 ;        ELSE
 JMP  fbPingIP_L10
fbPingIP_L9:
#srcline 71 ;          pingInfo.errMsg := 'IP address of gateway in PLC is wrong!';     // chybne nastavena brana site
 LD   0   ; null string
 LDX  pingInfo
 ADD  21  ; + offset 
 WRI  
 LDX  pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPingIP_1
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 72 ;        END_IF;
fbPingIP_L10:
#srcline 73 ;      ELSE
 JMP  fbPingIP_L8
fbPingIP_L7:
#srcline 74 ;        waitArp := 1;
 LD   bool -1      ; true
 WRX  waitArp
#debug_left bool waitArp
#srcline 75 ;        return;          // cekat na vyrizeni ARP dotazu
 JMP  fbPingIP_RET
#srcline 76 ;      END_IF;
fbPingIP_L8:
#srcline 77 ;    ELSE
 JMP  fbPingIP_L6
fbPingIP_L5:
#srcline 78 ;      waitArp := 0;
 LD   bool 0       ; false
 WRX  waitArp
#debug_left bool waitArp
#srcline 79 ;    END_IF;
fbPingIP_L6:
#srcline 80 ;  END_IF;
fbPingIP_L1:
#srcline 81 ;  IF busy THEN
 LDX  busy
#debug bool busy
 JMC  fbPingIP_L11
#srcline 82 ;    IF pingInfo.result = 1 THEN
 LDX  pingInfo
 LDIL 
#debug dint pingInfo.result
 LD   dint 1
 EQ
 JMC  fbPingIP_L13
#srcline 83 ;      done := 1; busy := 0; err := 0; timeout.IN := 0;
 LD   bool -1      ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 84 ;    ELSIF pingInfo.result < 0 THEN
 JMP  fbPingIP_L14
fbPingIP_L13:
 LDX  pingInfo
 LDIL 
#debug dint pingInfo.result
 LD   dint 0
 LTS
 JMC  fbPingIP_L15
#srcline 85 ;      done := 0; busy := 0; err := 1; timeout.IN := 0;
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 86 ;    ELSE
 JMP  fbPingIP_L14
fbPingIP_L15:
#srcline 87 ;      // kontrolni casovac
#srcline 88 ;      IF timeout.Q THEN
 LDX  timeout~Q
#debug bool timeout.Q
 JMC  fbPingIP_L16
#srcline 89 ;        busy := 0; err := 1; timeout.IN := 0;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 90 ;        pingInfo.result := -1;
 LD   dint -1
 LDX  pingInfo
 WRIL 
#debug_left dint pingInfo.result
#srcline 91 ;        pingInfo.hostIP := hostIP;
 LEAX hostIP
#debug pointer hostIP
 SRC  %IB0
 LDX  pingInfo
 ADD  4  ; + offset 
#debug_left pointer pingInfo.hostIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 92 ;        pingInfo.errMsg := 'No answer!';
 LD   0   ; null string
 LDX  pingInfo
 ADD  21  ; + offset 
 WRI  
 LDX  pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPingIP_2
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 93 ;      END_IF;
fbPingIP_L16:
#srcline 94 ;    END_IF;
fbPingIP_L14:
#srcline 95 ;  END_IF;
fbPingIP_L11:
#srcline 96 ;END_FUNCTION_BLOCK
fbPingIP_RET:
 ULNK
RET
E     61
#endpou 

#pou fbPing
#srcline 99 ;FUNCTION_BLOCK fbPing

#struct fbPing__temp__
  udint P0__st__,
  string[82] PS0__st__,
  string[257] PSC__st__
#data byte _str_fbPing_0 = 
  'D','N','S',' ','s','e','r','v','e','r',' ','f','a','i','l','u','r','e','!',0
#data byte _str_fbPing_1 = 
  'H','o','s','t',' ','n','a','m','e',' ','f','a','i','l','e','d',' ','t','o',' ',
  'f','i','n','d','!',0
#data byte _str_fbPing_2 = 
  'H','o','s','t',' ','n','a','m','e',' ','i','s',' ','e','m','p','t','y',' ','o',
  'r',' ','i','n','v','a','l','i','d','!',0
#data byte _str_fbPing_3 = 
  'f','b','N','s','L','o','o','k','U','p','E','x',' ','e','r','r','o','r',':',' ',0
#data byte _str_fbPing_4 = 
  'I','P',' ','a','d','d','r','e','s','s',' ','o','f',' ','g','a','t','e','w','a',
  'y',' ','i','n',' ','P','L','C',' ','i','s',' ','w','r','o','n','g','!',0
P     61
fbPing_L0:
 LINK __SizeOf(fbPing__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  rqPing
 LETX __EDGE_R__rqPing
 WRX  rqPing
#srcline 124 ;  done := 0;
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
#srcline 125 ;  IF rqPing THEN
 LDX  rqPing
#debug bool rqPing
 JMC  fbPing_L1
#srcline 126 ;    busy := 1; err := 0; rqSplit := 1;
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   bool -1      ; true
 WRX  rqSplit
#debug_left bool rqSplit
#srcline 127 ;    Memset( val := 0, length := sizeof(T_PING_INFO), dest := void( pingInfo));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   102  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX pingInfo
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 128 ;  END_IF;
fbPing_L1:
#srcline 130 ;  SplitUrlAdr( split := rqSplit, urlAddress := hostName, host := host, action := action, ipAdr := ipAdr, port := port);
 LDX  rqSplit
#debug bool rqSplit
 WRX  SplitUrlAdr~split
#debug_left bool SplitUrlAdr~split
 LEAX hostName
 WRX  SplitUrlAdr~urlAddress
#debug_left pointer SplitUrlAdr.urlAddress
 LEAX host
 WRX  SplitUrlAdr~host
#debug_left pointer SplitUrlAdr.host
 LEAX action
 WRX  SplitUrlAdr~action
#debug_left pointer SplitUrlAdr.action
 LEAX ipAdr
 WRX  SplitUrlAdr~ipAdr
#debug_left pointer SplitUrlAdr.ipAdr
 LEAX port
 WRX  SplitUrlAdr~port
#debug_left pointer SplitUrlAdr.port
 LEAX SplitUrlAdr
 CAL  fbSplitUrlAddress_L0
#srcline 131 ;  IF rqSplit AND SplitUrlAdr.err THEN
 LDX  rqSplit
#debug bool rqSplit
 LDX  SplitUrlAdr~err
#debug bool SplitUrlAdr.err
 AND
 JMC  fbPing_L3
#srcline 132 ;    err := 1; busy := 0; rqSplit := 0;
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  rqSplit
#debug_left bool rqSplit
#srcline 133 ;    pingInfo.result := -1;
 LD   dint -1
 WRX  pingInfo~result
#debug_left dint pingInfo.result
#srcline 134 ;    // zkontrolovat, jestli je dobre nastavena brana site
#srcline 135 ;    IF CheckGatewayIP(ethChan := ETH1) THEN
 NXT
 LD   usint 225
 WR   __Instance__CheckGatewayIP~ethChan
#debug_left usint __Instance__CheckGatewayIP~ethChan
 PRV
 LEA  __Instance__CheckGatewayIP
 CAL  CheckGatewayIP_L0
 JMC  fbPing_L5
#srcline 136 ;      CASE SplitUrlAdr.errId OF
 LDX  SplitUrlAdr~errId
#debug usint SplitUrlAdr.errId
 WRY  P0__st__
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbPing_L8
#srcline 137 ;        3  : pingInfo.errMsg := 'DNS server failure!';
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_0
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
 JMP  fbPing_L7
fbPing_L8:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbPing_L9
#srcline 138 ;        4  : pingInfo.errMsg := 'Host name failed to find!';
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_1
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
 JMP  fbPing_L7
fbPing_L9:
 LD   17
 LDY  P0__st__
 EQ  
 JMC  fbPing_L10
#srcline 139 ;        17 : pingInfo.errMsg := 'Host name is empty or invalid!';
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_2
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
 JMP  fbPing_L7
fbPing_L10:
#srcline 140 ;      ELSE
#srcline 141 ;        pingInfo.errMsg := 'fbNsLookUpEx error: ' + USINT_TO_STRING( SplitUrlAdr.errId);  // chyba v NsLookUpEx
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_3
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   80
 DST    ; Level 2
 LDX  SplitUrlAdr~errId
#debug usint SplitUrlAdr.errId
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 142 ;      END_CASE;
fbPing_L7:
#srcline 143 ;    ELSE
 JMP  fbPing_L6
fbPing_L5:
#srcline 144 ;      pingInfo.errMsg := 'IP address of gateway in PLC is wrong!';     // chybne nastavena brana site
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_4
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 145 ;    END_IF;
fbPing_L6:
#srcline 146 ;  ELSIF SplitUrlAdr.done THEN
 JMP  fbPing_L4
fbPing_L3:
 LDX  SplitUrlAdr~done
#debug bool SplitUrlAdr.done
 JMC  fbPing_L11
#srcline 147 ;    rqSplit := 0;
 LD   bool 0       ; false
 WRX  rqSplit
#debug_left bool rqSplit
#srcline 148 ;  END_IF;
 JMP  fbPing_L4
fbPing_L11:
fbPing_L4:
#srcline 150 ;  PingIP( rqPing := SplitUrlAdr.Done, hostIP := ipAdr, ttl := 60, timeLimit := T#3s, dataLen := 32, pingInfo := pingInfo);
 LDX  SplitUrlAdr~Done
#debug bool SplitUrlAdr.Done
 WRX  PingIP~rqPing
#debug_left bool PingIP~rqPing
 LEAX ipAdr
#debug pointer ipAdr
 SRC  %IB0
 LEAX PingIP~hostIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LD   usint 60
 WRX  PingIP~ttl
#debug_left usint PingIP~ttl
 LD   time 3000
 WRX  PingIP~timeLimit
#debug_left time PingIP~timeLimit
 LD   uint 32
 WRX  PingIP~dataLen
#debug_left uint PingIP~dataLen
 LEAX pingInfo
 WRX  PingIP~pingInfo
#debug_left pointer PingIP.pingInfo
 LEAX PingIP
 CAL  fbPingIP_L0
#srcline 151 ;  IF PingIP.done THEN
 LDX  PingIP~done
#debug bool PingIP.done
 JMC  fbPing_L12
#srcline 152 ;    busy := 0; done := 1; err := 0;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 153 ;  ELSIF busy AND PingIP.err THEN
 JMP  fbPing_L13
fbPing_L12:
 LDX  busy
#debug bool busy
 LDX  PingIP~err
#debug bool PingIP.err
 AND
 JMC  fbPing_L14
#srcline 154 ;    busy := 0; err := 1;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 155 ;  END_IF;
 JMP  fbPing_L13
fbPing_L14:
fbPing_L13:
#srcline 156 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbPing__InstanceInit__:
 LINK 0
 LEAX SplitUrlAdr
 CAL  fbSplitUrlAddress__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
ó´  ò  j