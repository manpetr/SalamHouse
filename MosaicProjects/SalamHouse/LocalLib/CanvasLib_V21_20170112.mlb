(*` {CSY}Knihovna vývojového systému Mosaic{ENU}Mosaic IDE library *)
(*` {CSY}Jméno souboru{ENU}File name{} : D:\TecoUserLibs\CanvasLib_V21_20170112.mlb *)
(*` {CSY}Knihovna : CanvasLib{ENU}Library : CanvasLib{} 2.1 *)
(*` {CSY}Autor{ENU}Author{} : Teco a.s. *)
(*` {CSY}Autorská práva{ENU}Copyright{} : (c)2014 - 2017 Teco a.s. *)
(*` {CSY}Verze IEC pøekladaèe{ENU}IEC compiler version{} : 3.11.10.0 *)
(*` {CSY}Verze assembleru{ENU}Assembler version{} : 4.3.00 *)

//{Knihovna : CanvasLib 2.1  }
(*` {CSY}Historie{ENU}History{}: *)
(*`
{CSY}
v1.6 19.12.2010 Byd První vydání knihovny
v1.7 06.01.2011 Byd Pøidány funkce GC_GraphLineRealArray
v1.8 12.08.2015 Byd Pøidány barvy z palety Material Design
                    Opravena konstanta GLSCALE_HORIZONTAL
v1.9 02.02.2016 Byd Pøidána výchozí hodnota stylu èáry
                    Upravena funkce GC_BEGIN, aby byla bezpeènì aktualizována hodnota velikosti grafického bufferu
v2.0 06.10.2016 Byd Pøidán blok GC_GraphPolygonRealArray
v2.1 12.01.2017 Byd Pøidán blok GC_GraphLineXYRealArray
{ENU}
v1.6 12/19/2010 Byd First release of library
v1.7 01/06/2011 Byd Added function GC_GraphLineRealArray
v1.8 08/12/2015 Byd Adding color from a palette Material Design
                    Fixed constant GLSCALE_HORIZONTAL
v1.9 02/02/2016 Byd Added default line style
                    Customized features GC_BEGIN to be safely updated value of the buffer size graphic
v2.0 10/06/2016 Byd Added block GC_GraphPolygonRealArray
v2.1 01/12/2016 Byd Added block GC_GraphLineXYRealArray
*)

(*----------------------------------------------------------------------------*)
{LIBRARY="LOCALLIB\SYSLIB_V38_20170104.MLB"}
{LIBRARY="LOCALLIB\CRCLIB_V12_20100902.MLB"}

TYPE TCanvasInfo :
  STRUCT  (*`{CSY}informace o kreslícím plátnu{ENU}information about canvas*)
    ver              : usint :=  2;  (*`{CSY}verze struktury bufferu{ENU}buffer structure version*)
    flags            : usint;  (*`{CSY}pøíznaky (.0 = 1 buffer je otevøen pro zápis){ENU}flags (.0 = 1 buffer is open to write)*)
    maxLen           : uint;  (*`{CSY}maximalní délka bufferu (o 1 byte menší, aby se do bufferu vždy vešla znaèka konec bufferu){ENU}maximal length bufferu (1 byte less to make sure there is always space for end of buffer marker)*)
    actLen           : uint;  (*`{CSY}aktualní délka bufferu (rozpracovaná){ENU}current length of buffer (progress)*)
    macroptr         : uint;  (*`{CSY}pomocná promìnná pro definici makra{ENU}auxiliary variable for macro definition*)
  END_STRUCT;
END_TYPE

TYPE TCanvasPoint :
  STRUCT  (*`{CSY}bod na kreslícím plátnu{ENU}point at canvas*)
    x                : int;  (*`{CSY}souøadnice X{ENU}X coordinate*)
    y                : int;  (*`{CSY}souøadnice Y{ENU}Y coordinate*)
  END_STRUCT;
END_TYPE

TYPE TCanvasTouch :
  STRUCT  (*`{CSY}pozice dotyku/kliknutí na kreslícím plátnu a barva, na kterou ukazuje{ENU}position of touch/click at canvas and color, that it is pointing to*)
    x                : int :=  -32767;  (*`{CSY}X souøadnice místa dotyku/kliknutí (-32767 bez dotyku/kliknutí){ENU}X coordinate of touch/click (-32767 without touch/click)*)
    y                : int :=  -32767;  (*`{CSY}Y souøadnice místa dotyku/kliknutí (-32767 bez dotyku/kliknutí){ENU}Y coordinate of touch/click (-32767 without touch/click)*)
    color            : udint;  (*`{CSY}barva v místì dotyku/kliknutí{ENU}color at the point of touch/click*)
  END_STRUCT;
END_TYPE

TYPE TCanvasHeadBuf :
  STRUCT  (*`{CSY}hlavièka bufferu kreslícího plátna{ENU}header of canvas buffer*)
    dataChg          : uint;  (*`{CSY}unikátní èíslo indikující zmìnu dat{ENU}unique number indicating change of data*)
    dataLen          : uint;  (*`{CSY}celková delka dat v bufferu{ENU}total length of data in buffer*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData64 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 64 bytù{ENU}data structure for canvas, 64 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 63);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..63] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData128 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 128 bytù{ENU}data structure for canvas, 128 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 127);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..127] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData256 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 256 bytù{ENU}data structure for canvas, 256 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 255);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..255] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData384 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 384 bytù{ENU}data structure for canvas, 256 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 383);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..383] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData512 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 512 bytù{ENU}data structure for canvas, 512 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 511);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..511] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData768 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 768 bytù{ENU}data structure for canvas, 768 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 767);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..767] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData1024 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 1024 bytù{ENU}data structure for canvas, 1024 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 1023);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..1023] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData1536 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 1536 bytù{ENU}data structure for canvas, 1536 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 1535);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..1535] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData2048 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 2048 bytù{ENU}data structure for canvas, 2048 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 2047);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..2047] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData3072 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 3072 bytù{ENU}data structure for canvas, 3072 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 3071);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..3071] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData4096 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 4095 bytù{ENU}data structure for canvas, 4096 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 4095);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..4095] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData6144 :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, 6144 bytù{ENU}data structure for canvas, 6144 bytes*)
    info             : TCanvasInfo :=  ( maxLen := 6143);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..6143] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData :
  STRUCT  (*`{CSY}datová struktura pro kreslící plátno, maximální velikost{ENU}data structure for canvas, maximum size*)
    info             : TCanvasInfo :=  ( maxLen := 8191);  (*`{CSY}informace o bufferu{ENU}information about buffer*)
    touch            : TCanvasTouch;  (*`{CSY}informace o dotyku/kliknutí{ENU}information about touch/click*)
    bufHead          : TCanvasHeadBuf;  (*`{CSY}hlavièka bufferu{ENU}header of buffer*)
    buf              : ARRAY [0..8191] OF usint;  (*`{CSY}data{ENU}data*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 GPRIMITIVE_BEGIN {HIDDEN} : usint :=  16#01;  (*`zacatek bufferu*)
 GPRIMITIVE_END {HIDDEN} : usint :=  16#02;  (*`konec bufferu, vykreslit vsechna primitiva*)
 GPRIMITIVE_SETLINEWIDTH {HIDDEN} : usint :=  16#03;  (*`zmena tloustky cary*)
 GPRIMITIVE_SETLINESTYLE {HIDDEN} : usint :=  16#04;  (*`zmena stylu cary*)
 GPRIMITIVE_SETFGCOLOR {HIDDEN} : usint :=  16#05;  (*`zmena barvy popredi (car, pisma)*)
 GPRIMITIVE_SETBGCOLOR {HIDDEN} : usint :=  16#06;  (*`zmena barvy pozadi (vyplne, podkladu)*)
 GPRIMITIVE_SETTEXTSIZE {HIDDEN} : usint :=  16#07;  (*`zmena velikosti pisma*)
 GPRIMITIVE_SETTEXTSTYLE {HIDDEN} : usint :=  16#08;  (*`zmena stylu pisma*)
 GPRIMITIVE_SETGRADIENTSTYLE {HIDDEN} : usint :=  16#09;  (*`zmena stylu gradientu*)
 GPRIMITIVE_SETORIGIN {HIDDEN} : usint :=  16#0A;  (*`presune pocatek souradnic do pozice kresliciho pera*)
 GPRIMITIVE_RESETORIGIN {HIDDEN} : usint :=  16#0B;  (*`presune pocatek souradnic do vychozi pozice*)
 GPRIMITIVE_SETVIRTSIZE {HIDDEN} : usint :=  16#0C;  (*`nastavi virtualni rozmer kreslici plochy, pri zobrazeni se prepocita na skutecny rozmer canvasu*)
 GPRIMITIVE_SETFILLSTYLE {HIDDEN} : usint :=  16#0D;  (*`zmena stylu vyplne*)
 GPRIMITIVE_POINT {HIDDEN} : usint :=  16#10;  (*`bod*)
 GPRIMITIVE_LINE {HIDDEN} : usint :=  16#11;  (*`cara x1,y1 -> x2,y2*)
 GPRIMITIVE_MOVETO {HIDDEN} : usint :=  16#12;  (*`nastaveni nove souradnice kresliciho pera*)
 GPRIMITIVE_LINETO {HIDDEN} : usint :=  16#13;  (*`cara z minuleho bodu do x,y*)
 GPRIMITIVE_BOX {HIDDEN} : usint :=  16#14;  (*`obdelnik*)
 GPRIMITIVE_FILLBOX {HIDDEN} : usint :=  16#15;  (*`vyplneny obdelnik*)
 GPRIMITIVE_POLYGON {HIDDEN} : usint :=  16#16;  (*`polygon*)
 GPRIMITIVE_FILLPOLYGON {HIDDEN} : usint :=  16#17;  (*`vyplneny polygon*)
 GPRIMITIVE_CIRCLE {HIDDEN} : usint :=  16#18;  (*`kruznice*)
 GPRIMITIVE_FILLCIRCLE {HIDDEN} : usint :=  16#19;  (*`kruh*)
 GPRIMITIVE_ARC {HIDDEN} : usint :=  16#1A;  (*`oblouk*)
 GPRIMITIVE_FILLARC {HIDDEN} : usint :=  16#1B;  (*`vyplneny oblouk*)
 GPRIMITIVE_WRITETEXT {HIDDEN} : usint :=  16#1C;  (*`vypis textu ppravo od pozice kresliciho pera*)
 GPRIMITIVE_IMAGE {HIDDEN} : usint :=  16#1D;  (*`zobrazeni obrazku*)
 GPRIMITIVE_MOVE {HIDDEN} : usint :=  16#20;  (*`relativni zmena souradnice kresliciho pera*)
 GPRIMITIVE_CBOX {HIDDEN} : usint :=  16#21;  (*`centrovany obdelnik*)
 GPRIMITIVE_CFILLBOX {HIDDEN} : usint :=  16#22;  (*`centrovany vyplneny obdelnik*)
 GPRIMITIVE_CFILLARC {HIDDEN} : usint :=  16#23;  (*`vyplneny oblouk se stredem na pozici kresliciho pera*)
 GPRIMITIVE_CWRITETEXT {HIDDEN} : usint :=  16#24;  (*`centrovany vypis textu*)
 GPRIMITIVE_CIMAGE {HIDDEN} : usint :=  16#25;  (*`centrovane zobrazeni obrazku*)
 GPRIMITIVE_CCIRCLE {HIDDEN} : usint :=  16#26;  (*`centrovana kruznice*)
 GPRIMITIVE_CFILLCIRCLE {HIDDEN} : usint :=  16#27;  (*`centrovany kruh*)
 GPRIMITIVE_HEADING {HIDDEN} : usint :=  16#28;  (*`nastaveni uhlu kresliciho pera*)
 GPRIMITIVE_TURN {HIDDEN} : usint :=  16#29;  (*`zmena uhlu kresliciho pera (+=doprava, -=doleva)*)
 GPRIMITIVE_LINEFWD {HIDDEN} : usint :=  16#2A;  (*`posun kresliciho pera podle jeho uhlu (kresli caru)*)
 GPRIMITIVE_MOVEFWD {HIDDEN} : usint :=  16#2B;  (*`posun kresliciho pera podle jeho uhlu (nekresli caru)*)
 GPRIMITIVE_PUSHPOSITION {HIDDEN} : usint :=  16#2C;  (*`ulozi aktualni pozici kresliciho pera*)
 GPRIMITIVE_POPPOSITION {HIDDEN} : usint :=  16#2D;  (*`obnovi aktualni pozici kresliciho pera*)
 GPRIMITIVE_CPOLYGON {HIDDEN} : usint :=  16#2E;  (*`polygon, natoceny podle uhlu kresliciho pera, souradnice jsou relativni k pozici kresliciho pera pri uhlu 0st*)
 GPRIMITIVE_CFILLPOLYGON {HIDDEN} : usint :=  16#2F;  (*`vyplneny polygon, natoceny podle uhlu kresliciho pera, souradnice jsou relativni k pozici kresliciho pera pri uhlu 0st*)
 GPRIMITIVE_GRAPHLINE {HIDDEN} : usint :=  16#30;  (*`vykresli data pro carovy graf*)
 GPRIMITIVE_GRAPHBARS {HIDDEN} : usint :=  16#31;  (*`vykresli data pro sloupcovy graf*)
 GPRIMITIVE_PUSHHEADING {HIDDEN} : usint :=  16#32;  (*`ulozi aktualni uhel kresliciho pera*)
 GPRIMITIVE_POPHEADING {HIDDEN} : usint :=  16#33;  (*`obnovi aktualni uhel kresliciho pera*)
 GPRIMITIVE_MACROBEGIN {HIDDEN} : usint :=  16#34;  (*`zacatek definice marka*)
 GPRIMITIVE_MACROEND {HIDDEN} : usint :=  16#35;  (*`konec definice marka*)
 GPRIMITIVE_MACRORUN {HIDDEN} : usint :=  16#36;  (*`volani marka*)
 GPRIMITIVE_RADIALSCALE {HIDDEN} : usint :=  16#37;  (*`kruhová stupnice*)
 GPRIMITIVE_LINEARSCALE {HIDDEN} : usint :=  16#38;  (*`lineární stupnice*)
 GPRIMITIVE_ROUNDBOX {HIDDEN} : usint :=  16#39;  (*`obdélník se zaoblenými rohy*)
 GPRIMITIVE_ROUNDFILLBOX {HIDDEN} : usint :=  16#3A;  (*`vyplnìný obdélník se zaoblenými rohy*)
 GPRIMITIVE_CROUNDBOX {HIDDEN} : usint :=  16#3B;  (*`centrovaný obdélník se zaoblenými rohy*)
 GPRIMITIVE_CROUNDFILLBOX {HIDDEN} : usint :=  16#3C;  (*`centrovaný vyplnìný obdélník se zaoblenými rohy*)
 GPRIMITIVE_CARC {HIDDEN} : usint :=  16#3D;  (*`oblouk se stredem na pozici kresliciho pera*)
 GTEXT_STYLE_NORMAL : uint :=  16#0000;  (*`{CSY} normalní písmo                               {ENU}normal font*)
 GTEXT_STYLE_BOLD : uint :=  16#0001;  (*`{CSY} tuèné písmo                                  {ENU}boldface*)
 GTEXT_STYLE_ITALIC : uint :=  16#0002;  (*`{CSY} kurzíva                                      {ENU}italics*)
 GTEXT_STYLE_FILLBG : uint :=  16#0004;  (*`{CSY} vyplnit pod textem podklad                   {ENU}fill text background*)
 GTEXT_STYLE_ALIGN_LEFT : uint :=  16#0000;  (*`{CSY} víceøadkový text - zarovnat øádky vlevo      {ENU}multiline text - align lines to the left*)
 GTEXT_STYLE_ALIGN_RIGHT : uint :=  16#0010;  (*`{CSY} víceøadkový text - zarovnat øádky vpravo     {ENU}multiline text - align lines to the right*)
 GTEXT_STYLE_ALIGN_CENTER : uint :=  16#0020;  (*`{CSY} víceøadkový text - zarovnat øádky doprostøed {ENU}multiline text - align lines in the middle*)
 GTEXT_STYLE_HRIGHT : uint :=  16#0000;  (*`{CSY} výpis textu vpravo od pozice kreslícího pera {ENU}print text from positions drawing pen to the right*)
 GTEXT_STYLE_HLEFT : uint :=  16#0040;  (*`{CSY} výpis textu vlevo od pozice kreslícího pera  {ENU}print text from position drawing pen to the left*)
 GTEXT_STYLE_HCENTER : uint :=  16#0080;  (*`{CSY} pozice kreslicího pera je ve støedu øádky    {ENU}drawing pen position is at the center of line*)
 GTEXT_STYLE_VDOWN : uint :=  16#0000;  (*`{CSY} výpis textu od pozice kreslíciho pera dolù   {ENU}print text from position drawing pen down*)
 GTEXT_STYLE_VUP : uint :=  16#0100;  (*`{CSY} výpis textu od pozice kreslíciho pera nahoru {ENU}print text from position drawing pen up*)
 GTEXT_STYLE_VCENTER : uint :=  16#0200;  (*`{CSY} pozice kreslícího pera je ve støedu          {ENU}drawing pen position is in the middle of line*)
 GLINE_STYLE_SOLID : usint :=  16#00;  (*`{CSY} plná èára                                         {ENU}solid line*)
 GLINE_STYLE_DASH : usint :=  16#01;  (*`{CSY} èarkovana èára                                    {ENU}dashed line*)
 GLINE_STYLE_DOTDASH : usint :=  16#02;  (*`{CSY} èerchovana èára                                   {ENU}dot-and-dash line*)
 GLINE_STYLE_DOT : usint :=  16#03;  (*`{CSY} teèkovana èára                                    {ENU}dotted line*)
 GLINE_CAP_BUTT : usint :=  16#00;  (*`{CSY} normalní konec èáry v koncovém bodì               {ENU}default end of the line at the end point*)
 GLINE_CAP_ROUND : usint :=  16#10;  (*`{CSY} zakulacený konec èáry se støedem v koncovém bodì  {ENU}a rounded end cap is added to each end of the line*)
 GLINE_CAP_SQUARE : usint :=  16#20;  (*`{CSY} hranatý konec èáry se støedem v koncovém bodì     {ENU}a square end cap is added to each end of the line*)
 GLINE_JOIN_MITTER : usint :=  16#00;  (*`{CSY} normalní napojení èar s ostrým rohem              {ENU}default join of lines creates sharp corner*)
 GLINE_JOIN_ROUND : usint :=  16#40;  (*`{CSY} napojení èar se zakulaceným rohem                 {ENU}join of lines creates a rounded corner*)
 GLINE_JOIN_BEVEL : usint :=  16#80;  (*`{CSY} napojení èar se zkoseným rohem                    {ENU}join of lines creates a beveled corner*)
 GFILL_STYLE_BGCOLOR : usint :=  16#00;  (*`{CSY} výplò barvou pozadí                                {ENU} fill with background color*)
 GFILL_STYLE_FRAME : usint :=  16#01;  (*`{CSY} výplò vèetnì obrysu (obrys kreslit barvou popøedí) {ENU} fill including frame (frame is drawn by foreground color)*)
 GFILL_STYLE_GRADIENT : usint :=  16#02;  (*`{CSY} výplò gradientem                                   {ENU} fill with gradient*)
 GGRADIENT_STYLE_LINEAR : usint :=  16#00;  (*`{CSY} lineární gradient                                            {ENU} linear gradient*)
 GGRADIENT_STYLE_BAR1_3 : usint :=  16#02;  (*`{CSY} dva opaèné linearní gradienty vedle sebe o širce 1/3 a 2/3   {ENU} two reverse linear gradients side by side with a width of 1/3 and 2/3*)
 GGRADIENT_STYLE_RADIAL : usint :=  16#01;  (*`{CSY} kruhový gradient, první barva je ve støedu                   {ENU} circular gradient, first color at the center*)
 GGRADIENT_STYLE_RADIAL1_3 : usint :=  16#03;  (*`{CSY} kruhový gradient, první barva je posunuta o 1/3 vlevo nahoru {ENU} circular gradient, first color is moved by 1/3 to the left top*)
 GGRADIENT_STYLE_HORIZONTAL : usint :=  16#80;  (*`{CSY} gradient zleva doprava (místo shora dolù)                    {ENU} gradient from left to right (instead of from top to bottom)*)
 GPOS_TYPE_PCT : int :=  16#4000;  (*`{CSY} pøíznak, že souøadnice není v bodech ale v procentech {ENU} flag that coordinates are not in pixels but in percents*)
 GGRAPH_LINE_DEFAULT : usint :=  16#00;  (*`{CSY} základní styl èáry               {ENU} default line style*)
 GGRAPH_LINE_SHOWDOT : usint :=  16#01;  (*`{CSY} zobrazit datové znaèky (koleèka) {ENU} show data points (circles)*)
 GGRAPH_LINE_SHOWCROSS : usint :=  16#02;  (*`{CSY} zobrazit datové znaèky (køížky)  {ENU} show data points (crosses)*)
 GGRAPH_LINE_NOLINES : usint :=  16#08;  (*`{CSY} nekreslit èáry (jen bodovy graf) {ENU} do not draw lines (only points)*)
 GGRAPH_LINE_INTERPOLATE : usint :=  16#10;  (*`{CSY} interpolace dat                  {ENU} data interpolation*)
 GGRAPH_LINE_FILL : usint :=  16#20;  (*`{CSY} vyplnit plochu pod èarou k ose x {ENU} fill area between line and X axis*)
 GCOLOR_TRANSPARENT : udint :=  16#FF000000;  (*`{CSY}zcela prùhledná          {ENU}fully transparent*)
 GCOLOR_TRANSPARENT3_4 : udint :=  16#C0000000;  (*`{CSY}ze 3/4 prùhledná         {ENU}3/4 transparent*)
 GCOLOR_TRANSPARENT1_2 : udint :=  16#80000000;  (*`{CSY}ze 1/2 prùhledná         {ENU}half transparent*)
 GCOLOR_TRANSPARENT1_4 : udint :=  16#40000000;  (*`{CSY}z  1/4 prùhledná         {ENU}1/4 transparent*)
 GCOLOR_WHITE : udint :=  16#00FFFFFF;  (*`{CSY}bílá                     {ENU}white*)
 GCOLOR_BLACK : udint :=  16#00000001;  (*`{CSY}èerná                    {ENU}black*)
 GCOLOR_RED : udint :=  16#000000FF;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_ORANGE : udint :=  16#000080FF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_YELLOW : udint :=  16#0000FFFF;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_CHARTREUSE : udint :=  16#0000FF80;  (*`{CSY}chertreuse               {ENU}chartreuse*)
 GCOLOR_GREEN : udint :=  16#0000FF00;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_SPRINGGREEN : udint :=  16#0080FF00;  (*`{CSY}jarní zelená             {ENU}spring green*)
 GCOLOR_CYAN : udint :=  16#00FFFF00;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_AZURE : udint :=  16#00FF8000;  (*`{CSY}blankytná                {ENU}azure*)
 GCOLOR_BLUE : udint :=  16#00FF0000;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_VIOLET : udint :=  16#00FF0080;  (*`{CSY}fialová                  {ENU}violet*)
 GCOLOR_MAGENTA : udint :=  16#00FF00FF;  (*`{CSY}purpurová                {ENU}magenta*)
 GCOLOR_ROSE : udint :=  16#008000FF;  (*`{CSY}rùžová                   {ENU}rose*)
 GCOLOR_LTGRAY : udint :=  16#00C0C0C0;  (*`{CSY}svìtle šedá              {ENU}light gray*)
 GCOLOR_GRAY : udint :=  16#00808080;  (*`{CSY}šedá                     {ENU}gray*)
 GCOLOR_DKGRAY : udint :=  16#00404040;  (*`{CSY}tmavì šedá               {ENU}dark gray*)
 GCOLOR_RED_50 : udint :=    16#EEEBFF;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_100 : udint :=   16#D2CDFF;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_200 : udint :=   16#9A9AEF;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_300 : udint :=   16#7373E5;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_400 : udint :=   16#5053EF;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_500 : udint :=   16#3643F4;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_600 : udint :=   16#3539E5;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_700 : udint :=   16#2F2FD3;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_800 : udint :=   16#2828C6;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_900 : udint :=   16#1C1CB7;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_A100 : udint :=  16#808AFF;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_A200 : udint :=  16#5252FF;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_A400 : udint :=  16#4417FF;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_RED_A700 : udint :=  16#0000D5;  (*`{CSY}èervená                  {ENU}red*)
 GCOLOR_PINK_50 : udint :=    16#ECE4FC;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_100 : udint :=   16#D0BBF8;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_200 : udint :=   16#B18FF4;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_300 : udint :=   16#9262F0;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_400 : udint :=   16#7A40EC;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_500 : udint :=   16#631EE9;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_600 : udint :=   16#601BD8;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_700 : udint :=   16#5B18C2;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_800 : udint :=   16#5714AD;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_900 : udint :=   16#4F0E88;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_A100 : udint :=  16#AB80FF;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_A200 : udint :=  16#8140FF;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_A400 : udint :=  16#5700F5;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PINK_A700 : udint :=  16#6211C5;  (*`{CSY}rùžová                  {ENU}pink*)
 GCOLOR_PURPLE_50 : udint :=    16#F5E5F3;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_100 : udint :=   16#E7BEE1;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_200 : udint :=   16#D893CE;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_300 : udint :=   16#C868BA;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_400 : udint :=   16#BC47AB;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_500 : udint :=   16#B0279C;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_600 : udint :=   16#AA248E;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_700 : udint :=   16#A21F7B;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_800 : udint :=   16#9A1B6A;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_900 : udint :=   16#8C144A;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_A100 : udint :=  16#FC80EA;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_A200 : udint :=  16#FB40E0;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_A400 : udint :=  16#F900D5;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_PURPLE_A700 : udint :=  16#FF00AA;  (*`{CSY}nachová                  {ENU}purple*)
 GCOLOR_DEEP_PURPLE_50 : udint :=    16#F6E7ED;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_100 : udint :=   16#E9C4D1;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_200 : udint :=   16#DB9DB3;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_300 : udint :=   16#CD7595;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_400 : udint :=   16#C2577E;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_500 : udint :=   16#B73A67;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_600 : udint :=   16#B1355E;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_700 : udint :=   16#A82D51;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_800 : udint :=   16#A02745;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_900 : udint :=   16#921B31;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_A100 : udint :=  16#FF88B3;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_A200 : udint :=  16#FF4D7C;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_A400 : udint :=  16#FF1F65;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_DEEP_PURPLE_A700 : udint :=  16#EA0062;  (*`{CSY}tmavì nachová       {ENU}deep purple*)
 GCOLOR_INDIGO_50 : udint :=    16#F6EAE8;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_100 : udint :=   16#E9CAC5;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_200 : udint :=   16#DAA89F;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_300 : udint :=   16#CB8679;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_400 : udint :=   16#C06B5C;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_500 : udint :=   16#B5513F;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_600 : udint :=   16#AB4939;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_700 : udint :=   16#9F3F30;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_800 : udint :=   16#933528;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_900 : udint :=   16#7E231A;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_A100 : udint :=  16#FF9E8C;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_A200 : udint :=  16#FE6D53;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_A400 : udint :=  16#FE5A3D;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_INDIGO_A700 : udint :=  16#FE4F30;  (*`{CSY}indigo              {ENU}indigo*)
 GCOLOR_BLUE_50 : udint :=    16#FDF2E3;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_100 : udint :=   16#FBDEBB;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_200 : udint :=   16#F9CA90;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_300 : udint :=   16#F6B564;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_400 : udint :=   16#F5A542;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_500 : udint :=   16#F39621;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_600 : udint :=   16#E5881E;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_700 : udint :=   16#D27619;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_800 : udint :=   16#C06515;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_900 : udint :=   16#A1470D;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_A100 : udint :=  16#FFB182;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_A200 : udint :=  16#FF8A44;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_A400 : udint :=  16#FF7929;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_BLUE_A700 : udint :=  16#FF6229;  (*`{CSY}modrá                    {ENU}blue*)
 GCOLOR_LIGHT_BLUE_50 : udint :=    16#FEF5E1;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_100 : udint :=   16#FCE5B3;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_200 : udint :=   16#FAD481;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_300 : udint :=   16#F7C34F;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_400 : udint :=   16#F6B629;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_500 : udint :=   16#F4A903;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_600 : udint :=   16#E59B03;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_700 : udint :=   16#D18802;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_800 : udint :=   16#BD7702;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_900 : udint :=   16#9B5701;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_A100 : udint :=  16#FFD880;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_A200 : udint :=  16#FFC440;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_A400 : udint :=  16#FFB000;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_LIGHT_BLUE_A700 : udint :=  16#EA9100;  (*`{CSY}svìtle modrá          {ENU}light blue*)
 GCOLOR_CYAN_50 : udint :=    16#FAF7E0;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_100 : udint :=   16#F2EBB2;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_200 : udint :=   16#EADE80;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_300 : udint :=   16#E1D04D;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_400 : udint :=   16#DAC626;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_500 : udint :=   16#D4BC00;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_600 : udint :=   16#C1AC00;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_700 : udint :=   16#A79700;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_800 : udint :=   16#8F8300;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_900 : udint :=   16#646000;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_A100 : udint :=  16#FFFF84;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_A200 : udint :=  16#FFFF18;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_A400 : udint :=  16#FFE500;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_CYAN_A700 : udint :=  16#D4B800;  (*`{CSY}azurová                  {ENU}cyan*)
 GCOLOR_TEAL_50 : udint :=    16#F1F2E0;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_100 : udint :=   16#DBDFB2;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_200 : udint :=   16#C4CB80;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_300 : udint :=   16#ACB64D;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_400 : udint :=   16#9AA626;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_500 : udint :=   16#889600;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_600 : udint :=   16#7B8900;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_700 : udint :=   16#6B7900;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_800 : udint :=   16#5C6900;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_900 : udint :=   16#404D00;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_A100 : udint :=  16#EBFFA7;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_A200 : udint :=  16#DAFF64;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_A400 : udint :=  16#B6E91D;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_TEAL_A700 : udint :=  16#A5BF00;  (*`{CSY}modrozelená              {ENU}teal*)
 GCOLOR_GREEN_50 : udint :=    16#E9F5E8;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_100 : udint :=   16#C9E6C8;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_200 : udint :=   16#A7D6A5;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_300 : udint :=   16#84C781;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_400 : udint :=   16#6ABB66;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_500 : udint :=   16#50AF4C;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_600 : udint :=   16#47A043;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_700 : udint :=   16#3C8E38;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_800 : udint :=   16#327D2E;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_900 : udint :=   16#205E1B;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_A100 : udint :=  16#CAF6B9;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_A200 : udint :=  16#AEF069;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_A400 : udint :=  16#76E600;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_GREEN_A700 : udint :=  16#53C800;  (*`{CSY}zelená                   {ENU}green*)
 GCOLOR_LIGHT_GREEN_50 : udint :=    16#E9F8F1;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_100 : udint :=   16#C8EDDC;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_200 : udint :=   16#A5E1C5;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_300 : udint :=   16#81D5AE;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_400 : udint :=   16#65CC9C;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_500 : udint :=   16#4AC38B;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_600 : udint :=   16#42B37C;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_700 : udint :=   16#389F68;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_800 : udint :=   16#2F8B55;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_900 : udint :=   16#1E6933;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_A100 : udint :=  16#90FFCC;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_A200 : udint :=  16#59FFB2;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_A400 : udint :=  16#03FF76;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIGHT_GREEN_A700 : udint :=  16#17DD64;  (*`{CSY}svìtle zelená      {ENU}light green*)
 GCOLOR_LIME_50 : udint :=    16#E7FBF9;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_100 : udint :=   16#C3F4F0;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_200 : udint :=   16#9CEEE6;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_300 : udint :=   16#75E7DC;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_400 : udint :=   16#57E1D4;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_500 : udint :=   16#39DCCD;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_600 : udint :=   16#33CAC0;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_700 : udint :=   16#2BB4AF;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_800 : udint :=   16#249D9E;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_900 : udint :=   16#177782;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_A100 : udint :=  16#81FFF4;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_A200 : udint :=  16#41FFEE;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_A400 : udint :=  16#00FFC6;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_LIME_A700 : udint :=  16#00EAAE;  (*`{CSY}žlutozelená      {ENU}lime*)
 GCOLOR_YELLOW_50 : udint :=  16#E7FDFF;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_100 : udint :=  16#C4F9FF;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_200 : udint :=  16#9DF5FF;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_300 : udint :=  16#76F1FF;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_400 : udint :=  16#58EEFF;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_500 : udint :=  16#3BEBFF;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_600 : udint :=  16#35D8FD;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_700 : udint :=  16#2DC0FB;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_800 : udint :=  16#25A8F9;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_900 : udint :=  16#177FF5;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_A100 : udint :=  16#8DFFFF;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_A200 : udint :=  16#00FFFF;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_A400 : udint :=  16#00EAFF;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_YELLOW_A700 : udint :=  16#00D6FF;  (*`{CSY}žlutá                    {ENU}yellow*)
 GCOLOR_AMBER_50 : udint :=  16#E1F8FF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_100 : udint :=  16#B3ECFF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_200 : udint :=  16#82E0FF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_300 : udint :=  16#4FD5FF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_400 : udint :=  16#28CAFF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_500 : udint :=  16#07C1FF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_600 : udint :=  16#00B3FF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_700 : udint :=  16#00A0FF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_800 : udint :=  16#008FFF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_900 : udint :=  16#006FFF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_A100 : udint :=  16#7FE5FF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_A200 : udint :=  16#40D7FF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_A400 : udint :=  16#00C4FF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_AMBER_A700 : udint :=  16#00ABFF;  (*`{CSY}jantarová                {ENU}amber*)
 GCOLOR_ORANGE_50 : udint :=  16#E0F3FF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_100 : udint :=  16#B2E0FF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_200 : udint :=  16#80CCFF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_300 : udint :=  16#4DB7FF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_400 : udint :=  16#26A7FF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_500 : udint :=  16#0098FF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_600 : udint :=  16#008CFB;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_700 : udint :=  16#007CF5;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_800 : udint :=  16#006CEF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_900 : udint :=  16#0051E6;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_A100 : udint :=  16#80D1FF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_A200 : udint :=  16#40ABFF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_A400 : udint :=  16#0091FF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_ORANGE_A700 : udint :=  16#006DFF;  (*`{CSY}oranžová                 {ENU}orange*)
 GCOLOR_DEEP_ORANGE_50 : udint :=  16#E7E9FB;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_100 : udint :=  16#BCCCFF;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_200 : udint :=  16#91ABFF;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_300 : udint :=  16#658AFF;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_400 : udint :=  16#4370FF;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_500 : udint :=  16#2257FF;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_600 : udint :=  16#1E51F4;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_700 : udint :=  16#194AE6;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_800 : udint :=  16#1543D8;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_900 : udint :=  16#0C36BF;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_A100 : udint :=  16#809EFF;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_A200 : udint :=  16#406EFF;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_A400 : udint :=  16#003DFF;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_DEEP_ORANGE_A700 : udint :=  16#002CDD;  (*`{CSY}tmavì oranžová      {ENU}deep orange*)
 GCOLOR_BROWN_50 : udint :=  16#E9EBEF;  (*`{CSY}hnìdá      {ENU}brown*)
 GCOLOR_BROWN_100 : udint :=  16#C8CCD7;  (*`{CSY}hnìdá      {ENU}brown*)
 GCOLOR_BROWN_200 : udint :=  16#A4AABC;  (*`{CSY}hnìdá      {ENU}brown*)
 GCOLOR_BROWN_300 : udint :=  16#7F88A1;  (*`{CSY}hnìdá      {ENU}brown*)
 GCOLOR_BROWN_400 : udint :=  16#636E8D;  (*`{CSY}hnìdá      {ENU}brown*)
 GCOLOR_BROWN_500 : udint :=  16#485579;  (*`{CSY}hnìdá      {ENU}brown*)
 GCOLOR_BROWN_600 : udint :=  16#414C6D;  (*`{CSY}hnìdá      {ENU}brown*)
 GCOLOR_BROWN_700 : udint :=  16#37405D;  (*`{CSY}hnìdá      {ENU}brown*)
 GCOLOR_BROWN_800 : udint :=  16#2E344E;  (*`{CSY}hnìdá      {ENU}brown*)
 GCOLOR_BROWN_900 : udint :=  16#23273E;  (*`{CSY}hnìdá      {ENU}brown*)
 GCOLOR_GREY_50 : udint :=  16#FAFAFA;  (*`{CSY}šedá      {ENU}grey*)
 GCOLOR_GREY_100 : udint :=  16#F5F5F5;  (*`{CSY}šedá      {ENU}grey*)
 GCOLOR_GREY_200 : udint :=  16#EEEEEE;  (*`{CSY}šedá      {ENU}grey*)
 GCOLOR_GREY_300 : udint :=  16#E0E0E0;  (*`{CSY}šedá      {ENU}grey*)
 GCOLOR_GREY_400 : udint :=  16#BDBDBD;  (*`{CSY}šedá      {ENU}grey*)
 GCOLOR_GREY_500 : udint :=  16#9E9E9E;  (*`{CSY}šedá      {ENU}grey*)
 GCOLOR_GREY_600 : udint :=  16#757575;  (*`{CSY}šedá      {ENU}grey*)
 GCOLOR_GREY_700 : udint :=  16#616161;  (*`{CSY}šedá      {ENU}grey*)
 GCOLOR_GREY_800 : udint :=  16#424242;  (*`{CSY}šedá      {ENU}grey*)
 GCOLOR_GREY_900 : udint :=  16#212121;  (*`{CSY}šedá      {ENU}grey*)
 GCOLOR_BLUE_GREY_50 : udint :=  16#F1EFEC;  (*`{CSY}modrošedá      {ENU}blue grey*)
 GCOLOR_BLUE_GREY_100 : udint :=  16#DCD8CF;  (*`{CSY}modrošedá      {ENU}blue grey*)
 GCOLOR_BLUE_GREY_200 : udint :=  16#C5BEB0;  (*`{CSY}modrošedá      {ENU}blue grey*)
 GCOLOR_BLUE_GREY_300 : udint :=  16#AEA490;  (*`{CSY}modrošedá      {ENU}blue grey*)
 GCOLOR_BLUE_GREY_400 : udint :=  16#9C9078;  (*`{CSY}modrošedá      {ENU}blue grey*)
 GCOLOR_BLUE_GREY_500 : udint :=  16#8B7D60;  (*`{CSY}modrošedá      {ENU}blue grey*)
 GCOLOR_BLUE_GREY_600 : udint :=  16#7A6E54;  (*`{CSY}modrošedá      {ENU}blue grey*)
 GCOLOR_BLUE_GREY_700 : udint :=  16#645A45;  (*`{CSY}modrošedá      {ENU}blue grey*)
 GCOLOR_BLUE_GREY_800 : udint :=  16#4F4737;  (*`{CSY}modrošedá      {ENU}blue grey*)
 GCOLOR_BLUE_GREY_900 : udint :=  16#383226;  (*`{CSY}modrošedá      {ENU}blue grey*)
 GRSCALE_NO_FIRST : int :=  16#01;  (*`{CSY}nekreslit první znaèku{ENU}don't draw first tick*)
 GRSCALE_NO_LAST : int :=  16#02;  (*`{CSY}nekreslit poslední znaèku{ENU}don't draw last tick*)
 GRSCALE_NO_LABELS : int :=  16#04;  (*`{CSY}nekreslit textové popisy{ENU}don't draw text labels*)
 GRSCALE_BOLD_TICK : int :=  16#08;  (*`{CSY}hlavní znaèky tuènì{ENU}bold major tick*)
 GRSCALE_CIRCULAR_TICK : int :=  16#10;  (*`{CSY}kruhové hlavní znaèky{ENU}circular major tick*)
 GRSCALE_OUTLINE : int :=  16#20;  (*`{CSY}vykreslit oblouk spojující znaèky{ENU}draw arc connecting tick*)
 GLSCALE_HORIZONTAL : int :=  16#00;  (*`{CSY}vodorovná stupnice{ENU}horizontal scale*)
 GLSCALE_VERTICAL : int :=  16#01;  (*`{CSY}svislá stupnice{ENU}vertical scale*)
 GLSCALE_NO_BASELINE : int :=  16#02;  (*`{CSY}nekreslit základní èáru (pouze znaèky) {ENU}don't draw base line (only ticks)*)
 GLSCALE_NO_LABELS : int :=  16#04;  (*`{CSY}nekreslit textové popisy{ENU}don't draw text labels*)
 GLSCALE_BOLD_TICK : int :=  16#08;  (*`{CSY}hlavní znaèky tuènì{ENU}bold major tick*)

END_VAR

__DECL FUNCTION GC_TestSpace {HIDDEN} : bool
  VAR_INPUT
    rqLen            : uint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveByte {HIDDEN} : bool
  VAR_INPUT
    data             : usint;  (*`{CSY}BYTE k uložení{ENU}BYTE to save*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveWord {HIDDEN} : bool
  VAR_INPUT
    data             : int;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveDword {HIDDEN} : bool
  VAR_INPUT
    data             : udint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveWordArray {HIDDEN} : bool
  VAR_INPUT
    n                : int;  (*`number of items*)
  END_VAR
  VAR_IN_OUT
    data             : int;  (*`first item*)
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveDwordArray {HIDDEN} : bool
  VAR_INPUT
    n                : usint;  (*`number of items*)
  END_VAR
  VAR_IN_OUT
    data             : udint;  (*`first item*)
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SavePos {HIDDEN} : bool
  VAR_INPUT
    x                : int;
    y                : int;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveAngle {HIDDEN} : bool
  VAR_INPUT
    angle            : real;  (*`uhel ve stupnich*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveReal {HIDDEN} : bool
  VAR_INPUT
    data             : real;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveString {HIDDEN} : bool
  VAR_IN_OUT
    in               : string [80];
    GrData           : TCanvasData;
  END_VAR
  VAR
    l                : uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveArray {HIDDEN} : bool
  VAR_IN_OUT
    in               : usint;
  END_VAR
  VAR_INPUT
    lenIn            : usint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_DataLen : uint
(*`{CSY}vrací poèet bytù uložených v grafickém bufferu kreslícího plátna{ENU}returns number of bytes saved in the canvas buffer*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Begin : bool
(*`{CSY}zaèátek kreslení, vynuluje buffer a odemkne jej pro zápis{ENU}beginning of drawing, resets the buffer and unlocks it for writing*)
  VAR_INPUT
    SizeOfGrData     : udint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_End : bool
(*`{CSY}Konec kreslení, zamkne buffer pro zápis a povolí jeho vykreslení.
Vrací TRUE pokud se všechny grafické operace uložily úspìšnì.
{ENU}End of drawing, locks buffer for writing and enable its drawing
Returns TRUE if all graphical operations were successfully stored.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
  VAR
    w                : PTR_TO uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MacroBegin : bool
(*`{CSY}Funkce oznaèuje zaèátek bloku grafických operací, které lze potom opakovanì spouštìt jako makro.
Toto je výhodné pro snížení obsazeného místa v grafickém bufferu, pokud se nìkteré sekvence grafických operací opakují.
Parametrem funkce je index makra (1-10), pøes tuto hodnotu potom mùžeme makro spustit. Konec makra oznaèuje funkce GC_MacroEnd.
Pøi zpracování dat v grafickém bufferu se všechny pøíkazy od GC_MacroBegin do GC_MacroEnd pøeskoèí, provedou se až pøi spuštìní makra funkcí GC_MacroRun.
{ENU}Function marks the beginning of block of graphics operations, which can then be re-run as a macro.
it can be used for reducing of occupied space in the graphics buffer if some sequences of graphics operations are repeated.
Index of macro (1-10) is parameter of function, its value is used to run the macro. Function GC_MacroEnd indicates end of macro.
All operations from GC_MacroBegin to GC_MacroEnd are skiped during graphics buffer data processing. They are processed only after macro is executed by function GC_MacroRun.*)
  VAR_INPUT
    index            : usint;  (*`{CSY}index makra{ENU}index of macro{} (1-10)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MacroEnd : bool
(*`{CSY}Funkce oznaèuje konec definice makra.
{CSY}Function indicates the end of macro definition.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MacroRun : bool
(*`{CSY}Funkce spustí pøedem nadefinované makro.
Po jeho ukonèení se pokraèuje následujícím grafickým povelem.
{ENU}Function executes a predefined macro.
After its completion continues with following graphic operation.*)
  VAR_INPUT
    index            : usint;  (*`{CSY}index makra{ENU}index of macro{} (1-10)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetLineWidth : bool
(*`{CSY}Funkce nastavuje šíøku èáry v pixelech.
{ENU}Function sets line width in pixels.*)
  VAR_INPUT
    width            : usint;  (*`{CSY}šíøka èáry v pixelech{ENU}line width in pixels*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetLineStyle : bool
(*`{CSY}Funkce nastavuje styl èáry, jejího zakonèení a napojení.
{ENU}Function sets style of line, its termination and connection.*)
  VAR_INPUT
    style            : usint;  (*`{CSY}styl definovaný konstantami{ENU}style defined by constants {} GLINE_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetFillStyle : bool
(*`{CSY}Funkce nastavuje styl výplnì.
{ENU}Fucntion sets fill style.*)
  VAR_INPUT
    style            : usint;  (*`{CSY}styl definovaný konstantami{ENU}style defined by constants {} GFILL_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetFgColor : bool
(*`{CSY}Funkce nastavuje barvu èar a písma (popøedí).
{ENU}Function sets color of lines and text (foreground).*)
  VAR_INPUT
    color            : udint;  (*`{CSY}barva uložené ve formátu {ENU}color stored in format {}UDINT (16#AABBGGRR)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetBgColor : bool
(*`{CSY}Funkce nastavuje barvu výplnì (pozadí).
{ENU}Function sets fill color (background).*)
  VAR_INPUT
    color            : udint;  (*`{CSY}barva uložené ve formátu {ENU}color stored in format {}UDINT (16#AABBGGRR)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetTextSize : bool
(*`{CSY}Funkce nastavuje výšku písma v pixelech.
{ENU}Function sets the font height in pixels.*)
  VAR_INPUT
    size             : usint;  (*`{CSY}výška písma v pixelech{ENU}font height in pixels*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetTextStyle : bool
(*`{CSY}Funkce umožòuje zmìnit styl písma, zarovnání øádek ve víceøádkovém textu a zpùsob umístìní textu vzhledem k souøadnici, od které se má text vykreslit.
{ENU}Function allows to change font style, aligment of lines in multiline text and the way text is positioned relative to coordinates from which it should be printed.*)
  VAR_INPUT
    style            : uint;  (*`{CSY}styl definovaný konstantami{ENU}style defined by constants {} GTEXT_STYLE_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetGradientStyle : bool
(*`{CSY}Funkce nastavuje barvy a styl barevného pøechodu (gradientu).
Aby se zobrazoval ve výplni gradient místo barvy pozadí, musí se funkcí GC_SetFillStyle zmìnit styl výplnì na GFILL_STYLE_GRADIENT.
{ENU}Function sets colors and style of color transition (gradient).
Fill style must be set to GFILL_STYLE_GRADIENT by function GC_SetFillStyle for gradient to be used instead of background color.*)
  VAR_INPUT
    color1           : udint;  (*`{CSY}poèáteèní barva uložené ve formátu {ENU}begin color stored in format {}UDINT (16#AABBGGRR)*)
    color2           : udint;  (*`{CSY}koncová barva uložené ve formátu {ENU}end color stored in format {}UDINT (16#AABBGGRR)*)
    style            : usint;  (*`{CSY}styl definovaný konstantami{ENU}style defined by constants {} GGRADIENT_STYLE_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetOrigin : bool
(*`{CSY}Funkce pøesune poèátek souøadnic (bod 0, 0) na pozici kreslicího pera. Všechny souøadnice jsou potom chápány relativnì k této pozici.
 {ENU}Function moves of the origin of coordinates (point 0, 0) to position of drawing pens. All coordinates are then understood as relative to this position.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_ResetOrigin : bool
(*`{CSY}Funkce pøesune poèátek souøadnic do levého horního rohu kreslicí plochy.
{ENU}Function moves the origin of coordinates in the top left corner of the drawing area.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetVirtSize : bool
(*`{CSY}Funkce nastaví rozmìr virtuální kreslicí plochy.
Virtuální plocha se umístí na kreslící plátno tak, aby mìla maximální rozmìr pøi zachování pomìru stran a její støed byl shodný se støedem kreslícího plátna.
V nastaveném rozmìru virtuální plochy jsou zadávány souøadnice a rozmìry následujících grafických operací. Také souøadnice dotyku se øídí naposledy zadaným rozmìrem virtuální plochy. Díky této funkci je možné kreslit nezávisle na rozmìru kreslícího plátna.
Pokud jsou zadány oba rozmìry na nulu dojde k obnovení výchozího rozmìru kreslícího plátna.
{ENU}Function sets the size of the virtual drawing area.
Virtual area is placed on the canvas so that it has a maximum size while maintaining the aspect ratio and its center is identical with the center of the canvas.
Coordinates and dimensions of following graphics operations are set according to dimension of virtal area. Coordinates of touch/click are converted using the last entered dimension of virtual are. This feature allows to draw independently of the canvas size.
If both parameters are set to zero, default dimmesion of the canvas is restored.*)
  VAR_INPUT
    width            : int;  (*`{CSY}šíøka virtuální kreslící plochy{ENU}width of the virtual drawing area*)
    height           : int;  (*`{CSY}výška virtuální kreslící plochy{ENU}height of the virtual drawing area*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MoveTo : bool
(*`{CSY}Funkce mìní pozici kreslicího pera (bez kreslení).
{ENU}Function changes position of the drawing pen (without drawing).*)
  VAR_INPUT
    x                : int;  (*`{CSY}nová souøadnice X kreslícího pera{ENU}new coordinate X of the drawing pen*)
    y                : int;  (*`{CSY}nová souøadnice Y kreslícího pera{ENU}new coordinate Y of the drawing pen*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Move : bool
(*`{CSY}Funkce mìní pozice kreslicího pera relativnì k pùvodnímu umístìní (bez kreslení).
{ENU}Function changes position of the drawing pen relative to its original location (without drawing).*)
  VAR_INPUT
    x                : int;  (*`{CSY}relativní zmìna pozice v ose X{ENU}relative change of the position on the X axis*)
    y                : int;  (*`{CSY}relativní zmìna pozice v ose Y{ENU}relative change of the position on the Y axis*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Point : bool
(*`{CSY}Funkce vykreslí bod na zadaných souøadnicích. Na stejné souøadnice nastaví i pozici kreslícího pera.
{ENU}{ENU}Function draws a point on set coordinates. Position of the drawing pen is set to the same coordinates.*)
  VAR_INPUT
    x                : int;  (*`{CSY}souøadnice X{ENU}coordinate X*)
    y                : int;  (*`{CSY}souøadnice Y{ENU}coordinate Y*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_LineTo : bool
(*`{CSY}Funkce kreslí èáru od souèasné pozice kreslicího pera do bodu zadaného souøadnicemi. Pozice kreslicího pera se pøesune do koncového bodu èáry.
{ENU}Function draws line from current position of drawing pen to the point set by coordinates. Position of the drawing pen is moved to the end point.*)
  VAR_INPUT
    x                : int;  (*`{CSY}souøadnice X koncového bodu{ENU}coordinate X of the end point*)
    y                : int;  (*`{CSY}souøadnice Y koncového bodu {ENU}coordinate Y of the end point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Line : bool
(*`{CSY}Funkce vykreslí èáru mezi dvìma body. Pozice kreslicího pera se pøesune do koncového bodu èáry.
{ENU}Function draws line between two points. Position of the drawing pen is set to the end point.*)
  VAR_INPUT
    x1               : int;  (*`{CSY}souøadnice X poèáteèního bodu{ENU}coordinate X of the start point*)
    y1               : int;  (*`{CSY}souøadnice Y poèáteèního bodu{ENU}coordinate Y of the start point*)
    x2               : int;  (*`{CSY}souøadnice X koncového bodu{ENU}coordinate X of the end point*)
    y2               : int;  (*`{CSY}souøadnice Y koncového bodu{ENU}coordinate Y of the end point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Box : bool
(*`{CSY}Vykreslí obdélník.
        Kreslící pero posune do støedu obdélníku.
   {ENU}Draws rectangle.
        Drawing pen is moved to the center of the rectangle.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    x                : int;  (*`{CSY}souøadnice X levého horního rohu{ENU}X coordinate of the top left corner*)
    y                : int;  (*`{CSY}souøadnice Y levého horního rohu{ENU}Y coordinate of the top left corner*)
    width            : int;  (*`{CSY}šíøka obdélníku{ENU}rectangle width*)
    height           : int;  (*`{CSY}výška obdélníku{ENU}rectangle height*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CBox : bool
(*`{CSY}Vykreslí obdélník se støedem na pozici kreslícího pera.
Obdélník je otoèen o úhel nastavený smìrem kreslícího pera.
   {ENU}Draws rectangle with center at drawing pen position.
Rectangle is rotated by the angle set by the heading of the drawing pen.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    width            : int;  (*`{CSY}šíøka obdélníku{ENU}rectangle width*)
    height           : int;  (*`{CSY}výška obdélníku{ENU}rectangle height*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_RoundBox : bool
(*`{CSY}Vykreslí obdélník se zakulacenými rohy.
        Kreslící pero posune do støedu obdélníku.
   {ENU}Draws rectangle with rounded corners.
        Drawing pen is moved to the center of the rectangle.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    x                : int;  (*`{CSY}souøadnice X levého horního rohu{ENU}X coordinate of the top left corner*)
    y                : int;  (*`{CSY}souøadnice Y levého horního rohu{ENU}Y coordinate of the top left corner*)
    width            : int;  (*`{CSY}šíøka obdélníku{ENU}rectangle width*)
    height           : int;  (*`{CSY}výška obdélníku{ENU}rectangle height*)
    r                : int;  (*`{CSY}polomìr rohu{ENU}corner radius*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer  //{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CRoundBox : bool
(*`{CSY}Vykreslí obdélník se zakulacenými rohy se støedem na pozici kreslícího pera.
Obdélník je otoèen o úhel nastavený smìrem kreslícího pera.
   {ENU}Draws rectangle with rounded corners with center at drawing pen position.
Rectangle is rotated by the angle set by the heading of the drawing pen.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    width            : int;  (*`{CSY}šíøka obdélníku{ENU}rectangle width*)
    height           : int;  (*`{CSY}výška obdélníku{ENU}rectangle height*)
    r                : int;  (*`{CSY}polomìr rohu{ENU}corner radius*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Triangle : bool
(*`{CSY}Vykreslí trojúhelník zadaný tøemi body.
        Pozice kreslícího pera se nemìní.
   {ENU}Draws a triangle defined by three points.
        Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    x1               : int;  (*`{CSY}souøadnice X prvního bodu{ENU}X coordinate of the first point*)
    y1               : int;  (*`{CSY}souøadnice Y prvního bodu{ENU}Y coordinate of the first point*)
    x2               : int;  (*`{CSY}souøadnice X druhého bodu{ENU}X coordinate of the second point*)
    y2               : int;  (*`{CSY}souøadnice Y druhého bodu{ENU}Y coordinate of the second point*)
    x3               : int;  (*`{CSY}souøadnice X tøetího bodu{ENU}X coordinate of the third point*)
    y3               : int;  (*`{CSY}souøadnice Y tøetího bodu{ENU}Y coordinate of the third point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Polygon4 : bool
(*`{CSY}Vykreslí ètyøúhelník zadaný ètyømi body.
        Pozice kreslícího pera se nemìní.
   {ENU}Draws a quadrilateral defined by four points.
        Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    x1               : int;  (*`{CSY}souøadnice X prvního bodu{ENU}X coordinate of the first point*)
    y1               : int;  (*`{CSY}souøadnice Y prvního bodu{ENU}Y coordinate of the first point*)
    x2               : int;  (*`{CSY}souøadnice X druhého bodu{ENU}X coordinate of the second point*)
    y2               : int;  (*`{CSY}souøadnice Y druhého bodu{ENU}Y coordinate of the second point*)
    x3               : int;  (*`{CSY}souøadnice X tøetího bodu{ENU}X coordinate of the third point*)
    y3               : int;  (*`{CSY}souøadnice Y tøetího bodu{ENU}Y coordinate of the third point*)
    x4               : int;  (*`{CSY}souøadnice X ètvrtého bodu{ENU}X coordinate of the fourth point*)
    y4               : int;  (*`{CSY}souøadnice Y ètvrtého bodu{ENU}Y coordinate of the fourth point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Polygon : bool
(*`{CSY}Vykreslí mnohoúhelník. Souøadnice jednotlivých bodù se pøidávají pomocí funkce GC_AddPoint.
        Pozice kreslícího pera se nemìní.
   {ENU}Draws a polygon. The coordinates of individual points are added by function GC_AddPoint.
        Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    numPoints        : usint;  (*`{CSY}poèet bodù{ENU}number of points*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PolygonArray : bool
(*`{CSY}Vykreslí mnohoúhelník. Souøadnice jednotlivých bodù se pøedávají jako pole.
        Pozice kreslícího pera se nemìní.
   {ENU}Draws a polygon. The coordinates of individual points are passed as array.
        Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    numPoints        : usint;  (*`{CSY}poèet bodù{ENU}number of points*)
  END_VAR
  VAR_IN_OUT
    points           : TCanvasPoint;  (*`{CSY}první bod v poli bodù{ENU}first point in array of points*)
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Arc : bool
(*`{CSY}Funkce nakreslí oblouk / eliptickou výseè. Pozice kreslicího pera se pøesune do støedu.
{ENU}Function draws an arc / elliptical sector. Drawing pen is moved to the center.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    x                : int;  (*`{CSY}souøadnice X støedového bodu{ENU}X coordinate of the center point*)
    y                : int;  (*`{CSY}souøadnice Y støedového bodu{ENU}Y coordinate of the center point*)
    rx               : int;  (*`{CSY}polomìr v ose X{ENU}radius on axis X*)
    ry               : int;  (*`{CSY}polomìr v ose Y{ENU}radius on axis Y*)
    angle            : real;  (*`{CSY}poèáteèní úhel oblouku ve stupních{ENU}starting angle in degrees*)
    dangle           : real;  (*`{CSY}délka oblouku ve stupních{ENU}length of arc in degrees*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CArc : bool
(*`{CSY}Funkce nakreslí oblouk / eliptickou výseè se støedem na pozici kreslícího pera.
{ENU}Function draws an arc / elliptical sector with center at position of the drawing pen.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    rx               : int;  (*`{CSY}polomìr v ose X{ENU}radius on axis X*)
    ry               : int;  (*`{CSY}polomìr v ose Y{ENU}radius on axis Y*)
    angle            : real;  (*`{CSY}poèáteèní úhel oblouku ve stupních{ENU}starting angle in degrees*)
    dangle           : real;  (*`{CSY}délka oblouku ve stupních{ENU}length of arc in degrees*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Circle : bool
(*`{CSY}Funkce nakreslí kružnici. Pozice kreslicího pera se pøesune do støedu.
{ENU}Function draws a circle. Drawing pen is moved to the center.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    x                : int;  (*`{CSY}souøadnice X støedového bodu{ENU}X coordinate of the center point*)
    y                : int;  (*`{CSY}souøadnice Y støedového bodu{ENU}X coordinate of the center point*)
    r                : int;  (*`{CSY}polomìr{ENU}radius*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CCircle : bool
(*`{CSY}Funkce nakreslí kružnici se støedem na pozici kreslícího pera.
{ENU}Function draws a circle with center at position of the drawing pen.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    r                : int;  (*`{CSY}polomìr{ENU}radius*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CTriangle : bool
(*`{CSY}Funkce vykreslí trojúhelník zadaný tøemi body kolem pozice kreslicího pera natoèený o úhel kreslicího pera.
Souøadnice jednotlivých bodù jsou relativní k pozici kreslicího pera. Pozice kreslicího pera se nemìní.
{ENU}Function draws a triangle defined by three points around the position of the drawing pen rotated by the angle of the drawing pen.
The coordinates of individual points are relative to the position of the drawing pen. Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    x1               : int;  (*`{CSY}souøadnice X prvního bodu{ENU}X coordinate of the first point*)
    y1               : int;  (*`{CSY}souøadnice Y prvního bodu{ENU}Y coordinate of the first point*)
    x2               : int;  (*`{CSY}souøadnice X druhého bodu{ENU}X coordinate of the second point*)
    y2               : int;  (*`{CSY}souøadnice Y druhého bodu{ENU}Y coordinate of the second point*)
    x3               : int;  (*`{CSY}souøadnice X tøetího bodu{ENU}X coordinate of the third point*)
    y3               : int;  (*`{CSY}souøadnice Y tøetího bodu{ENU}Y coordinate of the third point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CPolygon4 : bool
(*`{CSY}Funkce vykreslí ètyøúhelník zadaný ètyømi body kolem pozice kreslicího pera natoèený o úhel kreslicího pera.
Souøadnice jednotlivých bodù jsou relativní k pozici kreslicího pera. Pozice kreslicího pera se nemìní.
{ENU}Function draws a quadrilateral defined by four points around the position of the drawing pen rotated by the angle of the drawing pen.
The coordinates of individual points are relative to the position of the drawing pen. Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    x1               : int;  (*`{CSY}souøadnice X prvního bodu{ENU}X coordinate of the first point*)
    y1               : int;  (*`{CSY}souøadnice Y prvního bodu{ENU}Y coordinate of the first point*)
    x2               : int;  (*`{CSY}souøadnice X druhého bodu{ENU}X coordinate of the second point*)
    y2               : int;  (*`{CSY}souøadnice Y druhého bodu{ENU}Y coordinate of the second point*)
    x3               : int;  (*`{CSY}souøadnice X tøetího bodu{ENU}X coordinate of the third point*)
    y3               : int;  (*`{CSY}souøadnice Y tøetího bodu{ENU}Y coordinate of the third point*)
    x4               : int;  (*`{CSY}souøadnice X ètvrtého bodu{ENU}X coordinate of the fourth point*)
    y4               : int;  (*`{CSY}souøadnice Y ètvrtého bodu{ENU}Y coordinate of the fourth point*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CPolygon : bool
(*`{CSY}Funkce nakreslí mnohoúhelník kolem pozice kreslicího pera natoèený o úhel kreslicího pera.
Souøadnice jednotlivých bodù jsou relativní k pozici kreslicího pera. Body se pøidávají pomocí funkce GC_AddPoint. Pozice kreslicího pera se nemìní.
{ENU}The function draws a polygon around the position of the drawing pen rotated by the angle of the drawing pen.
The coordinates of individual points are relative to the position of the drawing pen. The points are added using GC_AddPoint. Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    numPoints        : usint;  (*`{CSY}poèet bodù{ENU}number of points*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CPolygonArray : bool
(*`{CSY}Funkce nakreslí mnohoúhelník kolem pozice kreslicího pera natoèený o úhel kreslicího pera.
Souøadnice jednotlivých bodù jsou relativní k pozici kreslicího pera. Body se pøedávají jako pole. Pozice kreslicího pera se nemìní.
{ENU}The function draws a polygon around the position of the drawing pen rotated by the angle of the drawing pen.
The coordinates of individual points are relative to the position of the drawing pen. The points are passed as array. Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    numPoints        : usint;  (*`{CSY}poèet bodù{ENU}number of points*)
  END_VAR
  VAR_IN_OUT
    points           : TCanvasPoint;  (*`{CSY}první bod v poli bodù{ENU}first point in array of points*)
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_AddPoint : bool
(*`{CSY}Funkce slouží pro pøidání souøadnic jednotlivých bodù polygonu, používá se po funkcích GC_CPolygon a GC_Polygon.
{ENU}Function is used to add coordinates of individual point of a polygon. Function is called after functions GC_CPolygon and GC_Polygon.*)
  VAR_INPUT
    x                : int;  (*`{CSY}souøadnice X{ENU}X coordinate*)
    y                : int;  (*`{CSY}souøadnice Y{ENU}Y coordinate*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_WriteText : bool
(*`{CSY}Funkce vypíše text od pozice kreslicího pera. Text mùže být i víceøádkový, jednotlivé øádky se oddìlují znakem $n.
Velikost písma je možné zmìnit funkcí GC_SetTextSize, pomocí funkce GC_SetTextStyle lze zmìnit styl písma a zpùsob zarovnání jednotlivých øádek textu.
Pozice kreslícího pera se mìní v závislosti na tom, zda se text vypisuje doleva, na støed èi doprava od jeho pozice.
{ENU}Function displays text from the position of the drawing pen. Text can also be multi-line, each line are separated by $n.
Font size can be set by function GC_SetTextSize functions, font style and how each line is aligned can be changed by function GC_SetTextStyle.
Change of drawing pen position varies depending on whether the text is displayed to the left, centered, or right from its position.*)
  VAR_INPUT
    text             : string [80];  (*`{CSY}text, který se má zobrazit{ENU}text to be displayed*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CWriteText : bool
(*`{CSY}Funkce vypíše text centrovaný kolem pozice kreslicího pera. Text mùže být i víceøádkový, jednotlivé øádky se oddìlují znakem $n.
Velikost písma je možné zmìnit funkcí GC_SetTextSize, pomocí funkce GC_SetTextStyle lze zmìnit styl písma a zpùsob zarovnání jednotlivých øádek textu.
Pozice kreslícího pera se nemìní.
{ENU}Function displays text centered at the position of the drawing pen. Text can also be multi-line, each line are separated by $n.
Font size can be set by function GC_SetTextSize functions, font style and how each line is aligned can be changed by function GC_SetTextStyle.
Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    text             : string [80];  (*`{CSY}text, který se má zobrazit{ENU}text to be displayed*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Image : bool
(*`{CSY}Funkce zobrazí obrázek, levý horní roh bude umístìn na pozici kreslicího pera. Pozice kreslicího pera se pøesune do støedu obrázku.
Obrázek musí být asociovaný s objektem kreslícího plátna.
{ENU}Function displays an image, the upper left corner will be at the position of the drawing pen. The position of the drawing pen is moved to the center of the image.
The image must be associated with the canvas object.*)
  VAR_INPUT
    width            : int;  (*`{CSY}šíøka vykresleného obrázku (0 pùvodní velikost){ENU}width of the displayed image (0 original size)*)
    height           : int;  (*`{CSY}výška vykresleného obrázku (0 pùvodní velikost){ENU}height of the displayed image (0 original size)*)
    fileName         : string [80];  (*`{CSY}jméno obrázku{ENU}image name*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CImage : bool
(*`{CSY}Funkce zobrazí obrázek vystøedìný na pozici kreslicího pera. Pozice kreslícího pera se nemìní.
Obrázek musí být asociovaný s objektem kreslícího plátna.
{ENU}Function displays an image with center at the position of the drawing pen. Position of the drawing pen stays unchanged.
The image must be associated with the canvas object.*)
  VAR_INPUT
    width            : int;  (*`{CSY}šíøka vykresleného obrázku (0 pùvodní velikost){ENU}width of the displayed image (0 original size)*)
    height           : int;  (*`{CSY}výška vykresleného obrázku (0 pùvodní velikost){ENU}height of the displayed image (0 original size)*)
    fileName         : string [80];  (*`{CSY}dlouhé jméno obrázku pøiøazené ke kreslicímu plátnu{ENU}long name of image associated with the canvas*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Heading : bool
(*`{CSY}Funkce nastavuje úhel kreslicího pera ve stupních. Hodnota 0 odpovídá smìru doprava, hodnota 90 smìru dolù.
{ENU}Function set the angle of the drawing pen in degrees. A value of 0 corresponds to the rightward direction to the right, value of 90 downward direction.*)
  VAR_INPUT
    angle            : real;  (*`{CSY}nový úhel kreslícího pera ve stupních{ENU}new angle of the drawing pen in degrees*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Turn : bool
(*`{CSY}Funkce pootoèí úhel kreslicího pera o hodnotu zadanou ve stupních. Kladné hodnoty otáèí perem ve smìru hodinových ruèièek, záporné v proti smìru.
{ENU}Function rotates angle of the drawing pen by the value specified in degrees. Positive values rotates pen clockwise, negative counterclockwise.*)
  VAR_INPUT
    angle            : real;  (*`{CSY}úhel pootoèení kreslicího pera ve stupních{ENU}angle of rotation of pen in degrees*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_LineFwd : bool
(*`{CSY}Funkce vykreslí èáru zadané délky od pozice kreslicího pera pod úhlem kreslicího pera. Pozice kreslicího pera se pøesune do koncového bodu èáry.
{ENU}Function draws a line of specified length from the position of the drawing pen using heading of the drawing pen. The position of the drawing pen moves to the end point of the line.*)
  VAR_INPUT
    length           : int;  (*`{CSY}délka èáry{ENU}length of line*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MoveFwd : bool
(*`{CSY}Funkce pøesune pozici kreslicího pera o zadanou vzdálenost pod úhlem kreslicího pera.
{ENU}Function moves position of the drawing pen by specified distance using heading of the drawing pen.*)
  VAR_INPUT
    length           : int;  (*`{CSY}vzdálenost mezi starou a novou pozicí kreslícího pera{ENU}distance between old and new position of the drawing pen*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PushPosition : bool
(*`{CSY}Funkce uloží do pomocného zásobníku aktuální umístìní kreslicího pera.
Parametrem funkce je index pozice v zásobníku. Pokud je index 1 – 10, hodnota se uloží pøímo na tuto pozici.
Pokud je index 0, posune se obsah zásobníku (data z pozic 1 – 9 se pøesunou do pozic 2 – 10) a nová hodnota se zapíše do pozice 1 (vrchol zásobníku).
{ENU}Function stores current location of the drawing pen to the auxiliary stack.
Index of position in the stack is parameter of function. If the index is greater than 0 and less or equal to 10, the location is stored to this position.
If the index is equal to 0, old locations are shifted (data from index 1 - 9 is moved to indexes 2 - 10) and new location is stored to position with index 1 (top of the stack)*)
  VAR_INPUT
    index            : usint;  (*`{CSY}index pozice v zásobníku (1 – 10) nebo vrchol zásobníku (0){ENU}index of position in the stack (1 - 10) or the top of stack 0*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PopPosition : bool
(*`{CSY}Funkce obnoví pozici kreslicího pera uloženou funkcí GC_PushPosition.
Parametrem je index pozice v zásobníku. Pokud je index 1 – 10, použije se pøímo hodnota na této pozici.
Pokud je index 0, použije se hodnota z vrcholu zásobníku (pozice 1), obsah zbylých pozic se pøesune (data z pozic 2 – 10 se pøesunou do pozic 1 – 9).
{ENU}Function restores location of the drawing pen stored by function GC_PushPosition.
Index of position in the stack is parameter of function. If the index is greater than 0 and less or equal to 10, the location is restored from this position.
If the index is equal to 0, the location is restored from the top of stack (index 1) and old locations are shifted (data from index 2 - 10 is moved to indexes 1 - 9)*)
  VAR_INPUT
    index            : usint;  (*`{CSY}index pozice v zásobníku (1 – 10) nebo vrchol zásobníku (0){ENU}index of position in the stack (1 - 10) or the top of stack 0*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PushHeading : bool
(*`{CSY}Funkce uloží do pomocného zásobníku aktuální úhel kreslicího pera.
Parametrem funkce je index pozice v zásobníku. Pokud je index 1 – 10, hodnota se uloží pøímo na tuto pozici.
Pokud je index 0, posune se obsah zásobníku (data z pozic 1 – 9 se pøesunou do pozic 2 – 10) a nová hodnota se zapíše do pozice 1 (vrchol zásobníku).
{ENU}Function stores current heading of the drawing pen to the auxiliary stack.
Index of position in the stack is parameter of function. If the index is greater than 0 and less or equal to 10, the heading is stored to this position.
If the index is equal to 0, old headings are shifted (data from index 1 - 9 is moved to indexes 2 - 10) and new heading is stored to position with index 1 (top of the stack)*)
  VAR_INPUT
    index            : usint;  (*`{CSY}index pozice v zásobníku (1 – 10) nebo vrchol zásobníku (0){ENU}index of position in the stack (1 - 10) or the top of stack 0*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PopHeading : bool
(*`{CSY}Funkce obnoví úhel kreslicího pera uložený funkcí GC_PushHeading.
Parametrem je index pozice v pomocném zásobníku. Pokud je index 1 – 10, použije se pøímo hodnota na této pozici.
Pokud je index 0, použije se hodnota z vrcholu zásobníku (pozice 1), obsah zbylých pozic se pøesune (data z pozic 2 – 10 se pøesunou do pozic 1 – 9).
{ENU}Function restores heading of the drawing pen stored by function GC_PushHeading.
Index of position in the stack is parameter of function. If the index is greater than 0 and less or equal to 10, the heading is restored from this position.
If the index is equal to 0, the heading is restored from the top of stack (index 1) and old headings are shifted (data from index 2 - 10 is moved to indexes 1 - 9)*)
  VAR_INPUT
    index            : usint;  (*`{CSY}index pozice v zásobníku (1 – 10) nebo vrchol zásobníku (0){ENU}index of position in the stack (1 - 10) or the top of stack 0*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLineArray : bool
(*`{CSY}Funkce vykreslí data pro èárový graf.
Kreslení probíhá od pozice kreslicího pera, souøadnice Y jednotlivých datových bodù jsou relativní k pozici kreslicího pera.
Jednotlivé souøadnice se pøedávají jako pole hodnot typu INT.
Pozice kreslicího pera se nemìní.
{ENU}Function draws data for a line graph.
Drawing starts at position of the drawing pen, Y coordinates of individual data points are relative to the position of the drawing pen.
Coordinates of individual points are passed as array of INT values.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*`{CSY}volitelné parametry, které upravují zobrazení grafu (konstanty GGRAPH_LINE_...){ENU}optional parameters, that modify graph presentation (constants GGRAPH_LINE_...)*)
    length           : int;  (*`{CSY}délka èáry grafu v pixelech{ENU}length of the graph line in pixels*)
    numPoints        : int;  (*`{CSY}poèet datových bodù{ENU}number of data points*)
  END_VAR
  VAR_IN_OUT
    data             : int;  (*`{CSY}první prvek pole souøadnic Y relativnì k pozici kreslicího pera{ENU}first element of the array of Y coordinates relative to position of the drawing pen*)
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLineRealArray : bool
(*`{CSY}Funkce vykreslí data pro èárový graf.
Kreslení probíhá od pozice kreslicího pera. Tento bod odpovídá minimu os X a Y.
Jednotlivé souøadnice se pøedávají jako pole hodnot typu REAL a jsou mìøítkovány dle minY a maxY.
Pozice kreslicího pera se nemìní.
{ENU}Function draws data for a line graph.
Drawing starts at position of the drawing pen. This point is identical with the minimum of axes X and Y.
Coordinates of individual points are passed as array of REAL values. Coordinates are scaled according to minY and maxY.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*`{CSY}volitelné parametry, které upravují zobrazení grafu (konstanty GGRAPH_LINE_...){ENU}optional parameters, that modify graph presentation (constants GGRAPH_LINE_...)*)
    length           : int;  (*`{CSY}délka èáry grafu v pixelech{ENU}length of the graph line in pixels*)
    numPoints        : int;  (*`{CSY}poèet datových bodù{ENU}number of data points*)
    height           : int;  (*`{CSY}výška grafu v pixelech{ENU}height of graph in pixels*)
    minY             : real;  (*`{CSY}hodnota odpovídající minimu grafu{ENU}value of graph minimum*)
    maxY             : real;  (*`{CSY}hodnota odpovídající maximu grafu{ENU}value of graph maximum*)
  END_VAR
  VAR_IN_OUT
    data             : real;  (*`{CSY}první prvek pole souøadnic Y{ENU}first element of the array of Y coordinates*)
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
  VAR
    a                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLine : bool
(*`{CSY}Funkce vykreslí data pro èárový graf.
Kreslení probíhá od pozice kreslicího pera, souøadnice Y jednotlivých datových bodù jsou relativní k pozici kreslicího pera.
Jednotlivé souøadnice se pøidávají pomocí funkce GC_GraphAddData.
Pozice kreslicího pera se nemìní.
{ENU}Function draws data for a line graph.
Drawing starts at position of the drawing pen, Y coordinates of individual data points are relative to the position of the drawing pen.
Coordinates of individual points are added using GC_GraphAddData.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*`{CSY}volitelné parametry, které upravují zobrazení grafu (konstanty GGRAPH_LINE_...){ENU}optional parameters, that modify graph presentation (constants GGRAPH_LINE_...)*)
    length           : int;  (*`{CSY}délka èáry grafu v pixelech{ENU}length of the graph line in pixels*)
    numPoints        : int;  (*`{CSY}poèet datových bodù{ENU}number of data points*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphBarsArray : bool
(*`{CSY}Funkce vykreslí data pro sloupcový graf.
Kreslení probíhá od pozice kreslicího pera, souøadnice Y jednotlivých datových bodù jsou relativní k pozici kreslicího pera.
Jednotlivé souøadnice se pøedávají jako pole hodnot typu INT.
Pozice kreslicího pera se nemìní.
{ENU}Function draws data for a bars graph.
Drawing starts at position of the drawing pen, Y coordinates of individual data points are relative to the position of the drawing pen.
Coordinates of individual points are passed as array of INT values.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*`{CSY}volitelné parametry, které upravují zobrazení grafu{ENU}optional parameters, that modify graph presentation*)
    length           : int;  (*`{CSY}vzdálenost mezi støedy prvního a posledního sloupce v pixelech{ENU}distance between centers of the first and the last bar in pixels*)
    barWidth         : int;  (*`{CSY}šíøka sloupcù{ENU}width of bars*)
    numPoints        : int;  (*`{CSY}poèet datových bodù{ENU}number of data points*)
  END_VAR
  VAR_IN_OUT
    data             : int;  (*`{CSY}první prvek pole souøadnic Y relativnì k pozici kreslicího pera{ENU}first element of the array of Y coordinates relative to position of the drawing pen*)
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphBarsRealArray : bool
(*`{CSY}Funkce vykreslí data pro sloupcový graf.
Kreslení probíhá od pozice kreslicího pera. Tento bod odpovídá minimu os X a Y.
Jednotlivé souøadnice se pøedávají jako pole hodnot typu REAL a jsou mìøítkovány dle minY a maxY.
Pozice kreslicího pera se nemìní.
{ENU}Function draws data for a bars graph.
Drawing starts at position of the drawing pen. This point is identical with the minimum of axes X and Y.
Coordinates of individual points are passed as array of REAL values. Coordinates are scaled according to minY and maxY.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*`{CSY}volitelné parametry, které upravují zobrazení grafu{ENU}optional parameters, that modify graph presentation*)
    length           : int;  (*`{CSY}vzdálenost mezi støedy prvního a posledního sloupce v pixelech{ENU}distance between centers of the first and the last bar in pixels*)
    barWidth         : int;  (*`{CSY}šíøka sloupcù{ENU}width of bars*)
    numPoints        : int;  (*`{CSY}poèet datových bodù{ENU}number of data points*)
    height           : int;  (*`{CSY}výška grafu v pixelech{ENU}height of graph in pixels*)
    minY             : real;  (*`{CSY}hodnota odpovídající minimu grafu{ENU}value of graph minimum*)
    maxY             : real;  (*`{CSY}hodnota odpovídající maximu grafu{ENU}value of graph maximum*)
  END_VAR
  VAR_IN_OUT
    data             : real;  (*`{CSY}první prvek pole souøadnic Y{ENU}first element of the array of Y coordinates*)
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
  VAR
    a                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphBars : bool
(*`{CSY}Funkce vykreslí data pro sloupcový graf.
Kreslení probíhá od pozice kreslicího pera, souøadnice Y jednotlivých datových bodù jsou relativní k pozici kreslicího pera.
Jednotlivé souøadnice se pøidávají pomocí funkce GC_GraphAddData.
Pozice kreslicího pera se nemìní.
{ENU}Function draws data for a bars graph.
Drawing starts at position of the drawing pen, Y coordinates of individual data points are relative to the position of the drawing pen.
Coordinates of individual points are added using GC_GraphAddData.
The position of the drawing pen stays unchanged.*)
  VAR_INPUT
    params           : usint;  (*`{CSY}volitelné parametry, které upravují zobrazení grafu{ENU}optional parameters, that modify graph presentation*)
    length           : int;  (*`{CSY}vzdálenost mezi støedy prvního a posledního sloupce v pixelech{ENU}distance between centers of the first and the last bar in pixels*)
    barWidth         : int;  (*`{CSY}šíøka sloupcù{ENU}width of bars*)
    numPoints        : int;  (*`{CSY}poèet datových bodù{ENU}number of data points*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphAddData : bool
(*`{CSY}Pøidá jeden datový bod do grafu. Tato funkce se používá po funkcích GC_GraphBars a GC_GraphLine.
{ENU}Adds one data point to a graph. This function is used with functions GC_GraphBars and GC_GraphLine.*)
  VAR_INPUT
    data             : int;  (*`{CSY}Souøadnice Y datového bodu v pixelech relativnì k pozici kreslícího pera{ENU}Coordinate Y in pixels of the data point relative to the drawing pen position*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_RadialScale : bool
(*`{CSY}Funkce vykreslí stupnici kruhového mìøidla
{ENU}Function draws circular gauge scale*)
  VAR_INPUT
    radius           : int;  (*`{CSY}polomìr                                                          {ENU}radius*)
    sAngle           : real;  (*`{CSY}poèáteèní úhel - odpovídá minimální hodnotì                      {ENU}start angle - corresponds to the minimum value*)
    eAngle           : real;  (*`{CSY}koncový úhel - odpovídá maximální hodnotì                        {ENU}end angle - corresponds to the maximum value*)
    majorTickLen     : int;  (*`{CSY}délka hlavní znaèky s popisem (kladné se kreslí smìrem do støedu){ENU}length of the major tick with label (positive is drawn toward the center)*)
    minorTickLen     : int;  (*`{CSY}délka vedlejší znaèky                                            {ENU}length of minor tick*)
    labelOffset      : usint;  (*`{CSY}odstup textu od znaèky                                           {ENU}space between label and tick*)
    labelDec         : usint;  (*`{CSY}poèet desetinných míst popisu                                    {ENU}number of label decimal places*)
    sVal             : real;  (*`{CSY}poèáteèní hodnota                                                {ENU}start value*)
    eVal             : real;  (*`{CSY}koncová hodnota                                                  {ENU}end value*)
    majorStep        : real;  (*`{CSY}krok po kterém budou vykresleny hlavní znaèky                    {ENU}step after which render major ticks*)
    labelAt          : real;  (*`{CSY}hodnota na které bude znaèka s popiskou                          {ENU}value with label*)
    labelStep        : usint;  (*`{CSY}krok po kterém je vykreslena popiska                             {ENU}step after which render labels*)
    stepDiv          : usint;  (*`{CSY}dìlení kroku hlavních znaèek pro kreslení vedlejší znaèek        {ENU}division step of major ticks for drawing minor ticks*)
    params           : int;  (*`{CSY}další parametry (konstanty GRSCALE...)                           {ENU}other parameters (constants GRSCALE ...)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_LinearScale : bool
(*`{CSY}Funkce vykreslí lineární stupnici
{ENU}Function draws a linear scale*)
  VAR_INPUT
    length           : int;  (*`{CSY}délka                                                       {ENU}length*)
    majorTickLen     : int;  (*`{CSY}délka hlavní znaèky s popisem (kladné se kreslí doleva/dolu){ENU}length of major tick with label (positive is drawn to the left/bottom)*)
    minorTickLen     : int;  (*`{CSY}délka vedlejší znaèky                                       {ENU}length of minor tick*)
    gridLength       : int;  (*`{CSY}délka èáry møížky                                           {ENU}length of grid line*)
    labelOffset      : usint;  (*`{CSY}odstup textu od znaèky                                      {ENU}space between label and tick*)
    labelDec         : usint;  (*`{CSY}poèet desetiných míst popisu                                {ENU}number of label decimal places*)
    sVal             : real;  (*`{CSY}poèáteèní hodnota                                           {ENU}start value*)
    eVal             : real;  (*`{CSY}koncová hodnota                                             {ENU}end value*)
    majorStep        : real;  (*`{CSY}krok po kterém budou vykresleny hlavní znaèky               {ENU}step after which render major ticks*)
    labelAt          : real;  (*`{CSY}hodnota na které bude znaèka s popiskou                     {ENU}value with label*)
    labelStep        : usint;  (*`{CSY}krok po kterém je vykreslena popiska                        {ENU}step after which render labels*)
    stepDiv          : usint;  (*`{CSY}dìlení kroku hlavních znaèek pro kreslení vedlejší znaèek   {ENU}division step of major ticks for drawing minor ticks*)
    params           : int;  (*`{CSY}další parametry (konstanty GLSCALE...)                      {ENU}other parameters (constants GLSCALE ...)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION

__DECL FUNCTION RGBA_TO_Color : udint
(*`{CSY}Složí barvu z jednotlivých složek RGB a prùhlednosti do formátu UDINT (16#AABBGGRR)
{ENU}Compose color from individual RGB components and transparency to UDINT format (16#AABBGGRR)*)
  VAR_INPUT
    R                : usint;  (*`{CSY}Èervená složka{ENU}Red component{} (0-255)*)
    G                : usint;  (*`{CSY}Zelená složka{ENU}Green component{} (0-255)*)
    B                : usint;  (*`{CSY}Modrá složka{ENU}Blue component{} (0-255)*)
    A                : usint;  (*`{CSY}Prùhlednost (0 - neprùhledné, 255 - prùhledné){ENU}Transparency (0 - opaque, 255 - transparent)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Color_TO_RGBA : bool
(*`{CSY}Rozloží barvu ve formátu UDINT (16#AABBGGRR) na jednotlivé složky RGB a prùhlednost
{ENU}Decompose color in UDINT format (16#AABBGGRR) to individual RGB components and transparency*)
  VAR_INPUT
    color            : udint;  (*`{CSY}barva uložené ve formátu {ENU}color stored in format {}UDINT (16#AABBGGRR)*)
  END_VAR
  VAR_IN_OUT
    R                : usint;  (*`{CSY}Èervená složka{ENU}Red component{} (0-255)*)
    G                : usint;  (*`{CSY}Zelená složka{ENU}Green component{} (0-255)*)
    B                : usint;  (*`{CSY}Modrá složka{ENU}Blue component{} (0-255)*)
    A                : usint;  (*`{CSY}Prùhlednost (0 - neprùhledné, 255 - prùhledné){ENU}Transparency (0 - opaque, 255 - transparent)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Alpha_TO_Color : udint
(*`{CSY}Nastaví barvì uložené ve formátu UDINT (16#AABBGGRR) prùhlednost (0 - neprùhledné, 255 - prùhledné)
{ENU}Sets transparency to a color stored in format UDINT (16#AABBGGRR) (0 - opaque, 255 - transparent)*)
  VAR_INPUT
    color            : udint;  (*`{CSY}barva uložené ve formátu {ENU}color stored in format {}UDINT (16#AABBGGRR)*)
    alpha            : usint;  (*`{CSY}prùhlednost (0 - neprùhledné, 255 - prùhledné){ENU}transparency (0 - opaque, 255 - transparent)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphPolygonRealArray : bool
(*`{CSY}Vykreslí mnohoúhelník jako XY graf. Souøadnice jednotlivých bodù se pøedávají jako pole souøadnic X a Y.
Pozice kreslícího pera se nemìní.
   {ENU}Draws a polygon as an XY graph. The coordinates of individual points are passed as array of coordinates X and Y.
Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    fill             : bool;  (*`{CSY}kreslit vyplnìný{ENU}draw filled*)
    numPoints        : usint;  (*`{CSY}poèet bodù{ENU}number of points*)
    length           : int;  (*`{CSY}délka osy X v pixelech{ENU}length of X axis in pixels*)
    height           : int;  (*`{CSY}délka osy Y v pixelech{ENU}lenght of Y axis in pixels*)
    minX             : real;  (*`{CSY}hodnota odpovídající minimu osy X{ENU}value of graph minimum on X axis*)
    maxX             : real;  (*`{CSY}hodnota odpovídající maximu osy X{ENU}value of graph maximum on X axis*)
    minY             : real;  (*`{CSY}hodnota odpovídající minimu osy Y{ENU}value of graph minimum on Y axis*)
    maxY             : real;  (*`{CSY}hodnota odpovídající maximu osy Y{ENU}value of graph maximum on Y axis*)
  END_VAR
  VAR_IN_OUT
    pointsX          : real;  (*`{CSY}první bod v poli souøadnic X{ENU}first point in array of X coordinates*)
    pointsY          : real;  (*`{CSY}první bod v poli souøadnic Y{ENU}first point in array of Y coordinates*)
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
  VAR
    a                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLineXYRealArray : bool
(*`{CSY}Vykreslí èáru jako XY graf. Souøadnice jednotlivých bodù se pøedávají jako pole souøadnic X a Y.
Pozice kreslícího pera se nemìní.
   {ENU}Draws a line as an XY graph. The coordinates of individual points are passed as array of coordinates X and Y.
Position of the drawing pen stays unchanged.*)
  VAR_INPUT
    x                : int;  (*`{CSY}souøadnice X poèáteèního bodu{ENU}coordinate X of the start point*)
    y                : int;  (*`{CSY}souøadnice Y poèáteèního bodu{ENU}coordinate Y of the start point*)
    numPoints        : usint;  (*`{CSY}poèet bodù{ENU}number of points*)
    length           : int;  (*`{CSY}délka osy X v pixelech{ENU}length of X axis in pixels*)
    height           : int;  (*`{CSY}délka osy Y v pixelech{ENU}lenght of Y axis in pixels*)
    minX             : real;  (*`{CSY}hodnota odpovídající minimu osy X{ENU}value of graph minimum on X axis*)
    maxX             : real;  (*`{CSY}hodnota odpovídající maximu osy X{ENU}value of graph maximum on X axis*)
    minY             : real;  (*`{CSY}hodnota odpovídající minimu osy Y{ENU}value of graph minimum on Y axis*)
    maxY             : real;  (*`{CSY}hodnota odpovídající maximu osy Y{ENU}value of graph maximum on Y axis*)
  END_VAR
  VAR_IN_OUT
    pointsX          : real;  (*`{CSY}první bod v poli souøadnic X{ENU}first point in array of X coordinates*)
    pointsY          : real;  (*`{CSY}první bod v poli souøadnic Y{ENU}first point in array of Y coordinates*)
    GrData           : TCanvasData;  (*`{CSY}odkaz na buffer kreslícího plátna{ENU}reference to the canvas buffer*)
  END_VAR
END_FUNCTION



{USES=GC_SaveWordArray:MemcpyEx}
{USES=GC_SaveDwordArray:MemcpyEx}
{USES=GC_SaveString:Memcpy}
{USES=GC_SaveArray:Memcpy}
{USES=GC_Begin:GC_SaveByte,GC_SaveWord}
{USES=GC_End:GC_SaveByte,CheckCRC_16}
{USES=GC_MacroBegin:GC_SaveWord}
{USES=GC_MacroEnd:GC_SaveByte}
{USES=GC_SetOrigin:GC_SaveByte}
{USES=GC_ResetOrigin:GC_SaveByte}
{USES=GC_PolygonArray:GC_SaveByte,GC_SaveDwordArray}
{USES=GC_CCircle:GC_SaveByte,GC_SaveWord}
{USES=GC_CPolygon:GC_SaveByte}
{USES=GC_CPolygonArray:GC_SaveByte,GC_SaveDwordArray}
{USES=GC_GraphLineRealArray:GC_Move}
{USES=GC_GraphBarsRealArray:GC_Move}
{USES=GC_GraphAddData:GC_SaveWord}
{USES=GC_GraphPolygonRealArray:GC_Move,GC_TestSpace,GC_SaveByte}
{USES=GC_GraphLineXYRealArray:GC_LineTo,GC_MoveTo}
#srcfile 'C:\TECOLIBSRC\CANVASLIB\CANVASLIB\GRCANVAS_TYPES.ST'


 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\CANVASLIB\CANVASLIB\GRCANVAS_SAVEVAL.ST'
#pou GC_TestSpace
#srcline 3 ;FUNCTION GC_TestSpace {$IFNDEF PR_DEBUG} {HIDDEN} {$END_IF} : BOOL // otestuje volne misto v bufferu
P     61
GC_TestSpace_L0:
 LINK 0
 NXT
#srcline 11 ;  IF GrData.info.flags.0 THEN
 LDX  GrData
 ADD  1  ; + offset 
 MUL  8   ; -> bool pointer 
 LDIB 
#debug bool GrData.info.flags.0
 JMC  GC_TestSpace_L1
#srcline 12 ;    GrData.info.flags.0 := GrData.info.actLen + rqLen < GrData.info.maxLen;
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LDX  rqLen
#debug uint rqLen
 ADD
 AND  $FFFF
 LDX  GrData
 ADD  2  ; + offset 
 LDIW 
#debug uint GrData.info.maxLen
 LT
 LDX  GrData
 ADD  1  ; + offset 
 MUL  8   ; -> bool pointer 
 WRIB 
#debug_left bool GrData.info.flags.0
#srcline 13 ;  END_IF;
GC_TestSpace_L1:
#srcline 14 ;  GC_TestSpace := GrData.info.flags.0;
 LDX  GrData
 ADD  1  ; + offset 
 MUL  8   ; -> bool pointer 
 LDIB 
#debug bool GrData.info.flags.0
 WRX  __fc__GC_TestSpace
#debug_left bool GC_TestSpace
#srcline 15 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_TestSpace
 ULNK
RET
E     61
#endpou 

#pou GC_SaveByte
#srcline 18 ;FUNCTION GC_SaveByte {$IFNDEF PR_DEBUG} {HIDDEN} {$END_IF} : BOOL // ulozi do bufferu USINT

#struct GC_SaveByte__temp__
  udint addr
P     61
GC_SaveByte_L0:
 LINK __SizeOf(GC_SaveByte__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 32 ;  BEGIN
#srcline 33 ;  {ASM}
#srcline 34
   LDX  data
#srcline 35
   LDX  GrData
#srcline 36
   ADD  __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 37
   LDX  GrData
#srcline 38
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 39
   WRY  addr
#srcline 40
   LDIW
#srcline 41
   ADD     ; + offset
#srcline 42
   WRI
#srcline 43
   LDY  addr
#srcline 44
   LDIW
#srcline 45
   ADD  __sizeof(BYTE)
#srcline 46
   LDY  addr
#srcline 47
   WRIW
#srcline 48 ;   {END_ASM}
#srcline 49 ;  (**)
#srcline 50 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SaveByte
 ULNK
RET
E     61
#endpou 

#pou GC_SaveWord
#srcline 53 ;FUNCTION GC_SaveWord {$IFNDEF PR_DEBUG} {HIDDEN} {$END_IF} : BOOL // ulozi do bufferu UINT

#struct GC_SaveWord__temp__
  udint w,
  udint addr
P     61
GC_SaveWord_L0:
 LINK __SizeOf(GC_SaveWord__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 70 ;  BEGIN
#srcline 71 ;  {ASM}
#srcline 72
  LDX  GrData
#srcline 73
  ADD __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 74
  LDX  GrData
#srcline 75
  ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 76
  WRY  addr
#srcline 77
  LDIW
#srcline 78
  ADD
#srcline 79
  WRY w
#srcline 80
  LDX  data
#srcline 81
  LDY w
#srcline 82
  WRIW
#srcline 83
  LDY  addr
#srcline 84
  LDIW
#srcline 85
  ADD __sizeof(WORD)
#srcline 86
  LDY  addr
#srcline 87
  WRIW
#srcline 88 ;  {END_ASM}
#srcline 89 ;  (**)
#srcline 90 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SaveWord
 ULNK
RET
E     61
#endpou 

#pou GC_SaveDword
#srcline 92 ;FUNCTION GC_SaveDword {$IFNDEF PR_DEBUG} {HIDDEN} {$END_IF} : BOOL // ulozi do bufferu UDINT (napr Color)

#struct GC_SaveDword__temp__
  udint d,
  udint addr
P     61
GC_SaveDword_L0:
 LINK __SizeOf(GC_SaveDword__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 109 ;  BEGIN
#srcline 110 ;  {ASM}
#srcline 111
  LDX  GrData
#srcline 112
  ADD __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 113
  LDX  GrData
#srcline 114
  ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 115
  WRY  addr
#srcline 116
  LDIW
#srcline 117
  ADD
#srcline 118
  WRY d
#srcline 119
  LDX  data
#srcline 120
  LDY d
#srcline 121
  WRIL
#srcline 122
  LDY  addr
#srcline 123
  LDIW
#srcline 124
  ADD __sizeof(DWORD)
#srcline 125
  LDY  addr
#srcline 126
  WRIW
#srcline 127 ;  {END_ASM}
#srcline 128 ;  (**)
#srcline 129 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SaveDword
 ULNK
RET
E     61
#endpou 

#pou GC_SaveWordArray
#srcline 131 ;FUNCTION GC_SaveWordArray {$IFNDEF PR_DEBUG} {HIDDEN} {$END_IF} : BOOL // ulozi do bufferu pole UINT s wordowym udajem o poctu

#struct GC_SaveWordArray__temp__
  pointer w
P     61
GC_SaveWordArray_L0:
 LINK __SizeOf(GC_SaveWordArray__temp__)
 NXT
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  w
; End initialize - dynamic variables
#srcline 143 ;  w  := ADR(GrData.Buf) + UINT_TO_UDINT(GrData.info.actLen);
 LDX  GrData
 ADD  20  ; + offset 
#debug pointer GrData.Buf
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 ADD
 LEAY w
 WRIL 
#debug_left pointer w
#srcline 144 ;  w^ := n;
 LDX  n
#debug int n
 EXTW 
 LEAY w
 LDIL    ; dereference 
 WRIW 
#debug_left int w^
#srcline 145 ;  MemcpyEx(length := INT_TO_UDINT(n)*2, offSource := 0, offDest := UINT_TO_UDINT(GrData.info.actLen)+2, source := void(data), dest := void(GrData.Buf));
 NXT
 LDX  n
#debug int n
 EXTW 
 LD   udint 2
 MUL
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LD   udint 0
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LD   udint 2
 ADD
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
 LDX  data
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LDX  GrData
 ADD  20  ; + offset 
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 146 ;  GrData.info.actLen := GrData.info.actLen + (INT_TO_UINT(n)+1)*2;
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LDX  n
#debug int n
 EXTW 
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 LD   uint 2
 MUL
 AND  $FFFF
 ADD
 AND  $FFFF
 LDX  GrData
 ADD  4  ; + offset 
 WRIW 
#debug_left uint GrData.info.actLen
#srcline 147 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SaveWordArray
 ULNK
RET
E     61
#endpou 

#pou GC_SaveDwordArray
#srcline 149 ;FUNCTION GC_SaveDwordArray {$IFNDEF PR_DEBUG} {HIDDEN} {$END_IF} : BOOL // ulozi do bufferu pole UDINT s bytovym udajem o poctu

#struct GC_SaveDwordArray__temp__
  pointer d
P     61
GC_SaveDwordArray_L0:
 LINK __SizeOf(GC_SaveDwordArray__temp__)
 NXT
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  d
; End initialize - dynamic variables
#srcline 161 ;  GrData.Buf[GrData.info.actLen] := n;
 LDX  n
#debug usint n
 LDX  GrData
 ADD  20  ; + offset 
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 RCHK 8191   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint GrData.Buf[GrData.info.actLen]
#srcline 162 ;  MemcpyEx(length := USINT_TO_UDINT(n)*4, offSource := 0, offDest := UINT_TO_UDINT(GrData.info.actLen)+1, source := void(data), dest := void(GrData.Buf));
 NXT
 LDX  n
#debug usint n
 LD   udint 4
 MUL
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LD   udint 0
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LD   udint 1
 ADD
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
 LDX  data
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LDX  GrData
 ADD  20  ; + offset 
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 163 ;  GrData.info.actLen := GrData.info.actLen + USINT_TO_UINT(n)*4 + 1;
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LDX  n
#debug usint n
 AND  $FFFF
 LD   uint 4
 MUL
 AND  $FFFF
 ADD
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 LDX  GrData
 ADD  4  ; + offset 
 WRIW 
#debug_left uint GrData.info.actLen
#srcline 165 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SaveDwordArray
 ULNK
RET
E     61
#endpou 

#pou GC_SavePos
#srcline 168 ;FUNCTION GC_SavePos {$IFNDEF PR_DEBUG} {HIDDEN} {$END_IF} : BOOL // ulozi do bufferu souradnice x,y

#struct GC_SavePos__temp__
  pointer w
P     61
GC_SavePos_L0:
 LINK __SizeOf(GC_SavePos__temp__)
 NXT
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  w
; End initialize - dynamic variables
#srcline 179 ;  w  := ADR(GrData.Buf) + UINT_TO_UDINT(GrData.info.actLen);
 LDX  GrData
 ADD  20  ; + offset 
#debug pointer GrData.Buf
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 ADD
 LEAY w
 WRIL 
#debug_left pointer w
#srcline 180 ;  w^ := x;
 LDX  x
#debug int x
 EXTW 
 LEAY w
 LDIL    ; dereference 
 WRIW 
#debug_left int w^
#srcline 181 ;  w  := w + 2;
 LEAY w
 LDIL 
#debug pointer w
 LD   udint 2
 ADD
 LEAY w
 WRIL 
#debug_left pointer w
#srcline 182 ;  w^ := y;
 LDX  y
#debug int y
 EXTW 
 LEAY w
 LDIL    ; dereference 
 WRIW 
#debug_left int w^
#srcline 183 ;  GrData.info.actLen := GrData.info.actLen + 4;
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LD   uint 4
 ADD
 AND  $FFFF
 LDX  GrData
 ADD  4  ; + offset 
 WRIW 
#debug_left uint GrData.info.actLen
#srcline 184 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SavePos
 ULNK
RET
E     61
#endpou 

#pou GC_SaveAngle
#srcline 187 ;FUNCTION GC_SaveAngle {$IFNDEF PR_DEBUG} {HIDDEN} {$END_IF} : BOOL // ulozi do bufferu uhel

#struct GC_SaveAngle__temp__
  udint d,
  udint addr
P     61
GC_SaveAngle_L0:
 LINK __SizeOf(GC_SaveAngle__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 212 ;  BEGIN
#srcline 213 ;  {ASM}
#srcline 214
  LDX  GrData
#srcline 215
  ADD __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 216
  LDX  GrData
#srcline 217
  ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 218
  WRY  addr
#srcline 219
  LDIW
#srcline 220
  ADD
#srcline 221
  WRY d
#srcline 222
  LDX  angle
#srcline 223
  LDY d
#srcline 224
  WRIL
#srcline 225
  LDY  addr
#srcline 226
  LDIW
#srcline 227
  ADD __sizeof(DWORD)
#srcline 228
  LDY  addr
#srcline 229
  WRIW
#srcline 230 ;  {END_ASM}
#srcline 231 ;  (**)
#srcline 232 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SaveAngle
 ULNK
RET
E     61
#endpou 

#pou GC_SaveReal
#srcline 234 ;FUNCTION GC_SaveReal {$IFNDEF PR_DEBUG} {HIDDEN} {$END_IF} : BOOL // ulozi REAL do bufferu

#struct GC_SaveReal__temp__
  udint d,
  udint addr
P     61
GC_SaveReal_L0:
 LINK __SizeOf(GC_SaveReal__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 251 ;  BEGIN
#srcline 252 ;  {ASM}
#srcline 253
  LDX  GrData
#srcline 254
  ADD __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 255
  LDX  GrData
#srcline 256
  ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 257
  WRY  addr
#srcline 258
  LDIW
#srcline 259
  ADD
#srcline 260
  WRY d
#srcline 261
  LDX  data
#srcline 262
  LDY d
#srcline 263
  WRIL
#srcline 264
  LDY  addr
#srcline 265
  LDIW
#srcline 266
  ADD __sizeof(DWORD)
#srcline 267
  LDY  addr
#srcline 268
  WRIW
#srcline 269 ;  {END_ASM}
#srcline 270 ;  (**)
#srcline 271 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SaveReal
 ULNK
RET
E     61
#endpou 

#pou GC_SaveString
#srcline 274 ;FUNCTION GC_SaveString {$IFNDEF PR_DEBUG} {HIDDEN} {$END_IF} : BOOL // ulozi do bufferu textovy retezec
P     61
GC_SaveString_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__GC_SaveString
 WRX  l
; End initialize - variables
#srcline 283 ;  l := LEN(in);
 LDX  in
#debug string in
 SLEN 
 WRX  l
#debug_left uint l
#srcline 284 ;  GrData.Buf[GrData.info.actLen] := UINT_TO_USINT(l);
 LDX  l
#debug uint l
 AND  $FF
 LDX  GrData
 ADD  20  ; + offset 
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 RCHK 8191   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint GrData.Buf[GrData.info.actLen]
#srcline 285 ;  Memcpy(length := l, source := void(in), dest := void(GrData.Buf[GrData.info.actLen+1]));
 NXT
 LDX  l
#debug uint l
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LDX  in
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LDX  GrData
 ADD  20  ; + offset 
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 8191   ; Range Check
 ADD     ; + offset 
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 286 ;  GrData.info.actLen := GrData.info.actLen + l + 1;
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LDX  l
#debug uint l
 ADD
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 LDX  GrData
 ADD  4  ; + offset 
 WRIW 
#debug_left uint GrData.info.actLen
#srcline 287 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SaveString
 ULNK
RET
E     61
#endpou 

#pou GC_SaveArray
#srcline 290 ;FUNCTION GC_SaveArray {$IFNDEF PR_DEBUG} {HIDDEN} {$END_IF} : BOOL // ulozi do bufferu pole bytu (max. 255 bytu)
P     61
GC_SaveArray_L0:
 LINK 0
 NXT
#srcline 301 ;  GrData.Buf[GrData.info.actLen] := lenIn;
 LDX  lenIn
#debug usint lenIn
 LDX  GrData
 ADD  20  ; + offset 
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 RCHK 8191   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint GrData.Buf[GrData.info.actLen]
#srcline 302 ;  Memcpy(length := USINT_TO_UINT(lenIn), source := void(in), dest := void(GrData.Buf[GrData.info.actLen+1]));
 NXT
 LDX  lenIn
#debug usint lenIn
 AND  $FFFF
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LDX  in
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LDX  GrData
 ADD  20  ; + offset 
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 8191   ; Range Check
 ADD     ; + offset 
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 303 ;  GrData.info.actLen := GrData.info.actLen + USINT_TO_UINT(lenIn) + 1;
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LDX  lenIn
#debug usint lenIn
 AND  $FFFF
 ADD
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 LDX  GrData
 ADD  4  ; + offset 
 WRIW 
#debug_left uint GrData.info.actLen
#srcline 304 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SaveArray
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\CANVASLIB\CANVASLIB\GRCANVAS_FCE.ST'
#pou GC_DataLen
#srcline 2 ;FUNCTION GC_DataLen : UINT
P     61
GC_DataLen_L0:
 LINK 0
 NXT
#srcline 7 ;  GC_DataLen := GrData.info.actLen;
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 WRX  __fc__GC_DataLen
#debug_left uint GC_DataLen
#srcline 8 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_DataLen
 ULNK
RET
E     61
#endpou 

#pou GC_Begin
#srcline 11 ;FUNCTION GC_Begin : BOOL
P     61
GC_Begin_L0:
 LINK 0
 NXT
#srcline 19 ;  BEGIN
#srcline 20 ;  {ASM}
#srcline 21
#ifndef GC_SaveFcPosMacro
#srcline 24
#macro GC_TestSpaceMacro (_rqLen, _GrData)
#srcline 25
 LDX  _GrData
#srcline 26
 ADD  1                                  ; + offset
#srcline 27
 MUL  8                                  ; -> bool pointer
#srcline 28
 WRY  addr
#srcline 29
 LDIB                                    ;GrData.info.flags.0
#srcline 30
 JMC  MacroReturn                        ;je nula jdeme pryc
#srcline 31
 LDX  _GrData
#srcline 32
 ADD  4                                  ; + offset
#srcline 33
 LDIW                                    ;GrData.info.actLen
#srcline 34
 ADD   _rqLen
#srcline 35
 LDX  _GrData
#srcline 36
 ADD  2                                  ; + offset
#srcline 37
 LDIW                                    ;GrData.info.maxLen
#srcline 38
 LT
#srcline 39
 JMD  MacroContinue                      ;je jedna pokracujeme
#srcline 40
 LDY addr
#srcline 41
 WRIB                                    ;GrData.info.flags.0
#srcline 42
MacroReturn:
#srcline 43
 ULNK
#srcline 44
 RET
#srcline 45
MacroContinue:
#srcline 46
#endm
#srcline 48
#macro GC_TestSpaceMacro2 (_rqLen, _GrData) ;rqLen jako V4R_TEMP
#srcline 49
 LDX  _GrData
#srcline 50
 ADD  1                                  ; + offset
#srcline 51
 MUL  8                                  ; -> bool pointer
#srcline 52
 WRY  addr
#srcline 53
 LDIB                                    ;GrData.info.flags.0
#srcline 54
 JMC  MacroReturn                        ;je nula jdeme pryc
#srcline 55
 LDX  _GrData
#srcline 56
 ADD  4                                  ; + offset
#srcline 57
 LDIW                                    ;GrData.info.actLen
#srcline 58
 LDY   _rqLen
#srcline 59
 ADD
#srcline 60
 LDX  _GrData
#srcline 61
 ADD  2                                  ; + offset
#srcline 62
 LDIW                                    ;GrData.info.maxLen
#srcline 63
 LT
#srcline 64
 JMD  MacroContinue                      ;je jedna pokracujeme
#srcline 65
 LDY addr
#srcline 66
 WRIB                                    ;GrData.info.flags.0
#srcline 67
MacroReturn:
#srcline 68
 ULNK
#srcline 69
 RET
#srcline 70
MacroContinue:
#srcline 71
#endm
#srcline 73
#macro GC_TestSpaceMacro3 (_rqLen, _addLen, _GrData) ;rqLen jako V4R_TEMP
#srcline 74
 LDX  _GrData
#srcline 75
 ADD  1                                  ; + offset
#srcline 76
 MUL  8                                  ; -> bool pointer
#srcline 77
 WRY  addr
#srcline 78
 LDIB                                    ;GrData.info.flags.0
#srcline 79
 JMC  MacroReturn                        ;je nula jdeme pryc
#srcline 80
 LDX  _GrData
#srcline 81
 ADD  4                                  ; + offset
#srcline 82
 LDIW                                    ;GrData.info.actLen
#srcline 83
 LDY   _rqLen
#srcline 84
 ADD  _addLen
#srcline 85
 ADD
#srcline 86
 LDX  _GrData
#srcline 87
 ADD  2                                  ; + offset
#srcline 88
 LDIW                                    ;GrData.info.maxLen
#srcline 89
 LT
#srcline 90
 JMD  MacroContinue                      ;je jedna pokracujeme
#srcline 91
 LDY addr
#srcline 92
 WRIB                                    ;GrData.info.flags.0
#srcline 93
MacroReturn:
#srcline 94
 ULNK
#srcline 95
 RET
#srcline 96
MacroContinue:
#srcline 97
#endm
#srcline 100
#macro GC_SaveFcByteMacro (_fcCode, _x, _GrData)
#srcline 101
   LD   _fcCode
#srcline 102
   LDX  _GrData
#srcline 103
   ADD  __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 104
   ;ADR(GrData.buf)
#srcline 105
   LDX  _GrData
#srcline 106
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 107
   ;ADR(GrData.info.actLen)
#srcline 108
   LDIW
#srcline 109
   ;GrData.info.actLen
#srcline 110
   ADD     ; + offset
#srcline 111
   ;ADR(GrData.buf) + GrData.info.actLen
#srcline 112
   WRY  addr
#srcline 113
   WRI
#srcline 115
   LDX _x
#srcline 116
   LDY addr
#srcline 117
   INR
#srcline 118
   WRI
#srcline 120
   ; GrData.info.actLen += 2*sizeof(USINT)
#srcline 121
   LDX  _GrData
#srcline 122
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 123
   WRY  addr
#srcline 124
   LDY  addr
#srcline 125
   LDIW
#srcline 126
   ADD  __sizeof(USINT)+__sizeof(USINT)
#srcline 127
   LDY  addr
#srcline 128
   WRIW
#srcline 129
#endm
#srcline 131
#macro GC_SaveFcWordMacro (_fcCode, _x, _GrData)
#srcline 132
   LD   _fcCode
#srcline 133
   LDX  _GrData
#srcline 134
   ADD  __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 135
   ;ADR(GrData.buf)
#srcline 136
   LDX  _GrData
#srcline 137
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 138
   ;ADR(GrData.info.actLen)
#srcline 139
   LDIW
#srcline 140
   ;GrData.info.actLen
#srcline 141
   ADD     ; + offset
#srcline 142
   ;ADR(GrData.buf) + GrData.info.actLen
#srcline 143
   WRY  addr
#srcline 144
   WRI
#srcline 146
   LDX _x
#srcline 147
   LDY addr
#srcline 148
   INR
#srcline 149
   WRIW
#srcline 151
   ; GrData.info.actLen += 2*sizeof(USINT)
#srcline 152
   LDX  _GrData
#srcline 153
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 154
   WRY  addr
#srcline 155
   LDY  addr
#srcline 156
   LDIW
#srcline 157
   ADD  __sizeof(USINT)+__sizeof(UINT)
#srcline 158
   LDY  addr
#srcline 159
   WRIW
#srcline 160
#endm
#srcline 162
#macro GC_SaveFcConstLenBlockMacro (_fcCode, _b, _l, _GrData)
#srcline 163
   LD   _fcCode
#srcline 164
   LDX  _GrData
#srcline 165
   ADD  __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 166
   ;ADR(GrData.buf)
#srcline 167
   LDX  _GrData
#srcline 168
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 169
   ;ADR(GrData.info.actLen)
#srcline 170
   LDIW
#srcline 171
   ;GrData.info.actLen
#srcline 172
   ADD     ; + offset
#srcline 173
   ;ADR(GrData.buf) + GrData.info.actLen
#srcline 174
   WRY  addr
#srcline 175
   WRI
#srcline 177
   LEAX _b  ;source
#srcline 178
   SRC  %X0
#srcline 180
   LDY  addr ;dest
#srcline 181
   INR
#srcline 182
   LD   _l
#srcline 183
   MOV  %X0
#srcline 185
   ; GrData.info.actLen += _l
#srcline 186
   LDX  _GrData
#srcline 187
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 188
   WRY  addr
#srcline 189
   LDY  addr
#srcline 190
   LDIW
#srcline 191
   ADD  _l+1
#srcline 192
   LDY  addr
#srcline 193
   WRIW
#srcline 194
#endm
#srcline 196
#macro GC_SaveFcConstLenBlockMacro2 (_fcCode, _n, _b, _l, _GrData)
#srcline 197
   LD   _fcCode
#srcline 198
   ADD  _n*256
#srcline 199
   LDX  _GrData
#srcline 200
   ADD  __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 201
   ;ADR(GrData.buf)
#srcline 202
   LDX  _GrData
#srcline 203
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 204
   ;ADR(GrData.info.actLen)
#srcline 205
   LDIW
#srcline 206
   ;GrData.info.actLen
#srcline 207
   ADD     ; + offset
#srcline 208
   ;ADR(GrData.buf) + GrData.info.actLen
#srcline 209
   WRY  addr
#srcline 210
   WRIW
#srcline 212
   LEAX _b  ;source
#srcline 213
   SRC  %X0
#srcline 215
   LDY  addr ;dest
#srcline 216
   ADD  2
#srcline 217
   LD   _l
#srcline 218
   MOV  %X0
#srcline 220
   ; GrData.info.actLen += _l
#srcline 221
   LDX  _GrData
#srcline 222
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 223
   WRY  addr
#srcline 224
   LDY  addr
#srcline 225
   LDIW
#srcline 226
   ADD  _l+2
#srcline 227
   LDY  addr
#srcline 228
   WRIW
#srcline 229
#endm
#srcline 231
#macro GC_SaveFcTempLenBlockMacro (_fcCode, _b, _l, _GrData)
#srcline 232
   LD   _fcCode
#srcline 233
   LDY  _l
#srcline 234
   MUL  256
#srcline 235
   OR
#srcline 236
   LDX  _GrData
#srcline 237
   ADD  __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 238
   ;ADR(GrData.buf)
#srcline 239
   LDX  _GrData
#srcline 240
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 241
   ;ADR(GrData.info.actLen)
#srcline 242
   LDIW
#srcline 243
   ;GrData.info.actLen
#srcline 244
   ADD     ; + offset
#srcline 245
   ;ADR(GrData.buf) + GrData.info.actLen
#srcline 246
   WRY  addr
#srcline 247
   WRIW
#srcline 249
   LEAX _b  ;source
#srcline 250
   SRC  %X0
#srcline 252
   LDY  addr ;dest
#srcline 253
   ADD  2
#srcline 254
   LDY   _l
#srcline 255
   MOV  %X0
#srcline 257
   ; GrData.info.actLen += _l
#srcline 258
   LDX  _GrData
#srcline 259
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 260
   WRY  addr
#srcline 261
   LDY  addr
#srcline 262
   LDIW
#srcline 263
   LDY  _l
#srcline 264
   ADD  2
#srcline 265
   ADD
#srcline 266
   LDY  addr
#srcline 267
   WRIW
#srcline 268
#endm
#srcline 270
#macro GC_SaveTempLenBlockMacro (_b, _l, _GrData)
#srcline 271
   LDY  _l
#srcline 272
   LDX  _GrData
#srcline 273
   ADD  __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 274
   ;ADR(GrData.buf)
#srcline 275
   LDX  _GrData
#srcline 276
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 277
   ;ADR(GrData.info.actLen)
#srcline 278
   LDIW
#srcline 279
   ;GrData.info.actLen
#srcline 280
   ADD     ; + offset
#srcline 281
   ;ADR(GrData.buf) + GrData.info.actLen
#srcline 282
   WRY  addr
#srcline 283
   WRI
#srcline 285
   LEAX _b  ;source
#srcline 286
   SRC  %X0
#srcline 288
   LDY  addr ;dest
#srcline 289
   INR
#srcline 290
   LDY   _l
#srcline 291
   MOV  %X0
#srcline 293
   ; GrData.info.actLen += _l
#srcline 294
   LDX  _GrData
#srcline 295
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 296
   WRY  addr
#srcline 297
   LDY  addr
#srcline 298
   LDIW
#srcline 299
   LDY  _l
#srcline 300
   INR
#srcline 301
   ADD
#srcline 302
   LDY  addr
#srcline 303
   WRIW
#srcline 304
#endm
#srcline 306
#macro GC_SaveTempLenPtrBlockMacro (_b, _l, _GrData)  ;_b je pointer
#srcline 307
   LDX  _GrData
#srcline 308
   ADD  __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 309
   ;ADR(GrData.buf)
#srcline 310
   LDX  _GrData
#srcline 311
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 312
   ;ADR(GrData.info.actLen)
#srcline 313
   LDIW
#srcline 314
   ;GrData.info.actLen
#srcline 315
   ADD     ; + offset
#srcline 316
   ;ADR(GrData.buf) + GrData.info.actLen
#srcline 317
   WRY  addr
#srcline 319
   LDX _b  ;source
#srcline 320
   SRC  %X0
#srcline 322
   LDY  addr ;dest
#srcline 323
   LDY   _l
#srcline 324
   MOV  %X0
#srcline 326
   ; GrData.info.actLen += _l
#srcline 327
   LDX  _GrData
#srcline 328
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 329
   WRY  addr
#srcline 330
   LDY  addr
#srcline 331
   LDIW
#srcline 332
   LDY  _l
#srcline 333
   ADD
#srcline 334
   LDY  addr
#srcline 335
   WRIW
#srcline 336
#endm
#srcline 340
#macro GC_SaveTempLenWordBlockMacro (_b, _l, _GrData)  ;_b je pointer
#srcline 341
   LDY  _l
#srcline 342
   DIV  2
#srcline 343
   LDX  _GrData
#srcline 344
   ADD  __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 345
   ;ADR(GrData.buf)
#srcline 346
   LDX  _GrData
#srcline 347
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 348
   ;ADR(GrData.info.actLen)
#srcline 349
   LDIW
#srcline 350
   ;GrData.info.actLen
#srcline 351
   ADD     ; + offset
#srcline 352
   ;ADR(GrData.buf) + GrData.info.actLen
#srcline 353
   WRY  addr
#srcline 354
   WRIW
#srcline 356
   LDX _b  ;source
#srcline 357
   SRC  %X0
#srcline 359
   LDY  addr ;dest
#srcline 360
   ADD  2
#srcline 361
   LDY   _l
#srcline 362
   MOV  %X0
#srcline 364
   ; GrData.info.actLen += _l
#srcline 365
   LDX  _GrData
#srcline 366
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 367
   WRY  addr
#srcline 368
   LDY  addr
#srcline 369
   LDIW
#srcline 370
   LDY  _l
#srcline 371
   ADD  2
#srcline 372
   ADD
#srcline 373
   LDY  addr
#srcline 374
   WRIW
#srcline 375
#endm
#srcline 379
#macro GC_SavePosMacro (_x, _y, _GrData)
#srcline 380
   ;LDX _y
#srcline 381
   ;SWL
#srcline 382
   ;LDX _x
#srcline 383
   ;OR
#srcline 384
   LDX  long _x
#srcline 385
   ;x,y jako UDINT
#srcline 386
   LDX  _GrData
#srcline 387
   ADD  __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 388
   ;ADR(GrData.buf)
#srcline 389
   LDX  _GrData
#srcline 390
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 391
   ;ADR(GrData.info.actLen)
#srcline 392
   WRY  addr
#srcline 393
   LDIW
#srcline 394
   ;GrData.info.actLen
#srcline 395
   ADD     ; + offset
#srcline 396
   ;ADR(GrData.buf) + GrData.info.actLen
#srcline 397
   WRIL
#srcline 398
   ; GrData.info.actLen += sizeof(UDINT)
#srcline 399
   LDY  addr
#srcline 400
   LDIW
#srcline 401
   ADD  __sizeof(UDINT)
#srcline 402
   LDY  addr
#srcline 403
   WRIW
#srcline 404
#endm
#srcline 406
#macro GC_SaveFcDwordMacro (_fcCode, _x, _GrData)
#srcline 407
   LD   _fcCode
#srcline 408
   LDX  _GrData
#srcline 409
   ADD  __sizeof(TCanvasInfo) + __sizeof(TCanvasTouch) + __sizeof(TCanvasHeadBuf)
#srcline 410
   ;ADR(GrData.buf)
#srcline 411
   LDX  _GrData
#srcline 412
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 413
   ;ADR(GrData.info.actLen)
#srcline 414
   LDIW
#srcline 415
   ;GrData.info.actLen
#srcline 416
   ADD     ; + offset
#srcline 417
   ;ADR(GrData.buf) + GrData.info.actLen
#srcline 418
   WRY  addr
#srcline 419
   WRI
#srcline 421
   ;LDX _y
#srcline 422
   ;SWL
#srcline 423
   ;LDX _x
#srcline 424
   ;OR
#srcline 425
   LDX long _x
#srcline 426
   ;x,y jako UDINT
#srcline 427
   LDY  addr
#srcline 428
   INR
#srcline 429
   WRIL
#srcline 431
   ; GrData.info.actLen += sizeof(UDINT)
#srcline 432
   LDX  _GrData
#srcline 433
   ADD  __sizeof(USINT) + __sizeof(USINT) + __sizeof(UINT)
#srcline 434
   WRY  addr
#srcline 435
   LDY  addr
#srcline 436
   LDIW
#srcline 437
   ADD  __sizeof(USINT)+__sizeof(UDINT)
#srcline 438
   LDY  addr
#srcline 439
   WRIW
#srcline 440
#endm
#srcline 441
#endif
#srcline 442 ;  {END_ASM}
#srcline 445 ;  GrData.info.ver     := 2;                         // verze struktury dat
 LD   usint 2
 LDX  GrData
 WRI 
#debug_left usint GrData.info.ver
#srcline 446 ;  GrData.bufHead.DataLen := 0;                      // timto oznamime displeji, ze data nejsou platna
 LD   uint 0
 LDX  GrData
 ADD  18  ; + offset 
 WRIW 
#debug_left uint GrData.bufHead.DataLen
#srcline 447 ;  GrData.info.actLen  := 0;                         // a vynulujeme aktualni delku
 LD   uint 0
 LDX  GrData
 ADD  4  ; + offset 
 WRIW 
#debug_left uint GrData.info.actLen
#srcline 448 ;  GrData.info.flags.0 := 1;                         // prednastavit priznak pro vyhodnocovani volneho mista v bufferu
 LD   bool -1      ; true
 LDX  GrData
 ADD  1  ; + offset 
 MUL  8   ; -> bool pointer 
 WRIB 
#debug_left bool GrData.info.flags.0
#srcline 449 ;  IF SizeOfGrData > 0 THEN
 LDX  SizeOfGrData
#debug udint SizeOfGrData
 LD   udint 0
 GT
 JMC  GC_Begin_L1
#srcline 450 ;    GrData.info.maxLen := UDINT_TO_UINT(SizeOfGrData - SIZEOF(TCanvasData) + 8191);
 LDX  SizeOfGrData
#debug udint SizeOfGrData
 LD   8212  ; SizeOf()
 SUB
 LD   udint 8191
 ADD
 AND  $FFFF
 LDX  GrData
 ADD  2  ; + offset 
 WRIW 
#debug_left uint GrData.info.maxLen
#srcline 451 ;  END_IF;
GC_Begin_L1:
#srcline 453 ;  GC_SaveByte( GPRIMITIVE_BEGIN, GrData);           // znacka zacatku grafickych dat
 NXT
 LD   usint 1
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 454 ;  GC_SaveByte( GrData.info.ver, GrData);            // nastavit priznak buffer neni kompletni
 NXT
 LDX  GrData
 LDI  
#debug usint GrData.info.ver
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 455 ;  GC_SaveWord( 0, GrData);                          // sem pozdeji doplnime delku dat
 NXT
 LD   int 0
 WR   __Instance__GC_SaveWord~data
#debug_left int __Instance__GC_SaveWord~data
 LDX  GrData
 WR   __Instance__GC_SaveWord~GrData
#debug_left pointer __Instance__GC_SaveWord.GrData
 PRV
 LEA  __Instance__GC_SaveWord
 CAL  GC_SaveWord_L0
#srcline 456 ;  GC_Begin := TRUE;
 LD   bool -1       ; true
 WRX  __fc__GC_Begin
#debug_left bool GC_Begin
#srcline 457 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Begin
 ULNK
RET
E     61
#endpou 

#pou GC_End
#srcline 460 ;FUNCTION GC_End : bool
P     61
GC_End_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__GC_End
 LD   -1
 WRX  w
; End initialize - variables
#srcline 474 ;  GC_End := GrData.info.flags.0;
 LDX  GrData
 ADD  1  ; + offset 
 MUL  8   ; -> bool pointer 
 LDIB 
#debug bool GrData.info.flags.0
 WRX  __fc__GC_End
#debug_left bool GC_End
#srcline 475 ;  IF GrData.info.flags.0 THEN                              //brzda proti vicenasobnemu volani END
 LDX  GrData
 ADD  1  ; + offset 
 MUL  8   ; -> bool pointer 
 LDIB 
#debug bool GrData.info.flags.0
 JMC  GC_End_L1
#srcline 476 ;    GC_SaveByte( GPRIMITIVE_END, GrData);            // znacka konce grafickych dat
 NXT
 LD   usint 2
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 477 ;    w  := ADR(GrData.Buf) + 2;                             // doplnime delku dat
 LDX  GrData
 ADD  20  ; + offset 
#debug pointer GrData.Buf
 LD   udint 2
 ADD
 LEAX w
 WRIL 
#debug_left pointer w
#srcline 478 ;    w^ := GrData.info.actlen;
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actlen
 LEAX w
 LDIL    ; dereference 
 WRIW 
#debug_left uint w^
#srcline 479 ;    GrData.bufHead.dataLen := GrData.info.actlen;          // doplnime celkovou delku dat v bufferu
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actlen
 LDX  GrData
 ADD  18  ; + offset 
 WRIW 
#debug_left uint GrData.bufHead.dataLen
#srcline 480 ;    GrData.bufHead.dataChg := CheckCRC_16(ptr := ADR(GrData.Buf), length := GrData.info.actlen);
 NXT
 LDX  GrData
 ADD  20  ; + offset 
#debug pointer GrData.Buf
 LEA  __Instance__CheckCRC_16~ptr
 WRIL 
#debug_left udint __Instance__CheckCRC_16~ptr
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actlen
 WR   __Instance__CheckCRC_16~length
#debug_left uint __Instance__CheckCRC_16~length
 PRV
 LEA  __Instance__CheckCRC_16
 CAL  CheckCRC_16_L0
 LDX  GrData
 ADD  16  ; + offset 
 WRIW 
#debug_left uint GrData.bufHead.dataChg
#srcline 481 ;    //GrData.bufHead.dataChg + 1;  // nastavime zmenu dat v bufferu
#srcline 482 ;    GC_End := GrData.info.flags.0;                   // vratit 1, pokud jsou data v bufferu kompletni
 LDX  GrData
 ADD  1  ; + offset 
 MUL  8   ; -> bool pointer 
 LDIB 
#debug bool GrData.info.flags.0
 WRX  __fc__GC_End
#debug_left bool GC_End
#srcline 483 ;    GrData.info.flags.0 := 0;                              // zamknout buffer (uz se do nej neda dal pridavat)
 LD   bool 0       ; false
 LDX  GrData
 ADD  1  ; + offset 
 MUL  8   ; -> bool pointer 
 WRIB 
#debug_left bool GrData.info.flags.0
#srcline 484 ;  END_IF;
GC_End_L1:
#srcline 485 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_End
 ULNK
RET
E     61
#endpou 

#pou GC_MacroBegin
#srcline 487 ;FUNCTION GC_MacroBegin : BOOL

#struct GC_MacroBegin__temp__
  udint addr
P     61
GC_MacroBegin_L0:
 LINK __SizeOf(GC_MacroBegin__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 508 ;    BEGIN
#srcline 509 ;    {ASM}
#srcline 510
    GC_TestSpaceMacro(4, GrData);
#srcline 511
    GC_SaveFcByteMacro(GPRIMITIVE_MACROBEGIN, index, GrData);
#srcline 512 ;    {END_ASM}
#srcline 513 ;    //GC_SaveByte( GPRIMITIVE_MACROBEGIN, GrData);
#srcline 514 ;    //GC_SaveByte( index, GrData);
#srcline 515 ;    GrData.info.macroptr := GrData.info.actLen; // ulozime si pozici, kam dopsat delku dat
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LDX  GrData
 ADD  6  ; + offset 
 WRIW 
#debug_left uint GrData.info.macroptr
#srcline 516 ;    GC_SaveWord( 0, GrData);     // sem pozdeji doplnime delku dat
 NXT
 LD   int 0
 WR   __Instance__GC_SaveWord~data
#debug_left int __Instance__GC_SaveWord~data
 LDX  GrData
 WR   __Instance__GC_SaveWord~GrData
#debug_left pointer __Instance__GC_SaveWord.GrData
 PRV
 LEA  __Instance__GC_SaveWord
 CAL  GC_SaveWord_L0
#srcline 517 ;//  END_IF;
#srcline 518 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_MacroBegin
 ULNK
RET
E     61
#endpou 

#pou GC_MacroEnd
#srcline 520 ;FUNCTION GC_MacroEnd : BOOL

#struct GC_MacroEnd__temp__
  pointer w,
  udint addr
P     61
GC_MacroEnd_L0:
 LINK __SizeOf(GC_MacroEnd__temp__)
 NXT
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  w
; End initialize - dynamic variables
#srcline 532 ;    BEGIN
#srcline 533 ;    {ASM}
#srcline 534
    GC_TestSpaceMacro(1, GrData);
#srcline 535 ;    {END_ASM}
#srcline 537 ;    // za MACRO_BEGIN musime doplnit delku dat
#srcline 538 ;    w  := ADR(GrData.Buf) + UINT_TO_UDINT(GrData.info.macroptr);
 LDX  GrData
 ADD  20  ; + offset 
#debug pointer GrData.Buf
 LDX  GrData
 ADD  6  ; + offset 
 LDIW 
#debug uint GrData.info.macroptr
 ADD
 LEAY w
 WRIL 
#debug_left pointer w
#srcline 539 ;    w^ := UINT_TO_INT(GrData.info.actLen - GrData.info.macroptr - 2); // delka dat mezi MACRO_BEGIN a MACRO_END
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LDX  GrData
 ADD  6  ; + offset 
 LDIW 
#debug uint GrData.info.macroptr
 SUB
 AND  $FFFF
 LD   uint 2
 SUB
 AND  $FFFF
 EXTW
 LEAY w
 LDIL    ; dereference 
 WRIW 
#debug_left int w^
#srcline 541 ;    GC_SaveByte( GPRIMITIVE_MACROEND, GrData);
 NXT
 LD   usint 53
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 542 ;  //END_IF;
#srcline 543 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_MacroEnd
 ULNK
RET
E     61
#endpou 

#pou GC_MacroRun
#srcline 545 ;FUNCTION GC_MacroRun : BOOL

#struct GC_MacroRun__temp__
  udint addr
P     61
GC_MacroRun_L0:
 LINK __SizeOf(GC_MacroRun__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 562 ;    BEGIN
#srcline 563 ;    {ASM}
#srcline 564
    GC_TestSpaceMacro(2, GrData);
#srcline 565
    GC_SaveFcByteMacro(GPRIMITIVE_MACRORUN, index, GrData);
#srcline 566 ;    {END_ASM}
#srcline 567 ;    //GC_SaveByte( GPRIMITIVE_MACRORUN, GrData);
#srcline 568 ;    //GC_SaveByte( index, GrData);
#srcline 569 ;  //END_IF;
#srcline 570 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_MacroRun
 ULNK
RET
E     61
#endpou 

#pou GC_SetLineWidth
#srcline 572 ;FUNCTION GC_SetLineWidth : BOOL

#struct GC_SetLineWidth__temp__
  udint addr
P     61
GC_SetLineWidth_L0:
 LINK __SizeOf(GC_SetLineWidth__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 590 ;    BEGIN
#srcline 591 ;    {ASM}
#srcline 592
    GC_TestSpaceMacro(2, GrData);
#srcline 593
    GC_SaveFcByteMacro(GPRIMITIVE_SETLINEWIDTH, width, GrData);
#srcline 594 ;    {END_ASM}
#srcline 595 ;  //END_IF;
#srcline 596 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SetLineWidth
 ULNK
RET
E     61
#endpou 

#pou GC_SetLineStyle
#srcline 599 ;FUNCTION GC_SetLineStyle : BOOL

#struct GC_SetLineStyle__temp__
  udint addr
P     61
GC_SetLineStyle_L0:
 LINK __SizeOf(GC_SetLineStyle__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 617 ;    BEGIN
#srcline 618 ;    {ASM}
#srcline 619
    GC_TestSpaceMacro(2, GrData);
#srcline 620
    GC_SaveFcByteMacro(GPRIMITIVE_SETLINESTYLE, style, GrData);
#srcline 621 ;    {END_ASM}
#srcline 622 ;  //END_IF;
#srcline 623 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SetLineStyle
 ULNK
RET
E     61
#endpou 

#pou GC_SetFillStyle
#srcline 625 ;FUNCTION GC_SetFillStyle : BOOL

#struct GC_SetFillStyle__temp__
  udint addr
P     61
GC_SetFillStyle_L0:
 LINK __SizeOf(GC_SetFillStyle__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 643 ;    BEGIN
#srcline 644 ;    {ASM}
#srcline 645
    GC_TestSpaceMacro(2, GrData);
#srcline 646
    GC_SaveFcByteMacro(GPRIMITIVE_SETFILLSTYLE, style, GrData);
#srcline 647 ;    {END_ASM}
#srcline 648 ;  //END_IF;
#srcline 649 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SetFillStyle
 ULNK
RET
E     61
#endpou 

#pou GC_SetFgColor
#srcline 651 ;FUNCTION GC_SetFgColor : BOOL

#struct GC_SetFgColor__temp__
  udint addr
P     61
GC_SetFgColor_L0:
 LINK __SizeOf(GC_SetFgColor__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 665 ;    BEGIN
#srcline 666 ;    {ASM}
#srcline 667
    GC_TestSpaceMacro(5, GrData);
#srcline 668
    GC_SaveFcDwordMacro(GPRIMITIVE_SETFGCOLOR, color, GrData);
#srcline 669 ;    {END_ASM}
#srcline 670 ;    //GC_SaveByte( GPRIMITIVE_SETFGCOLOR, GrData);
#srcline 671 ;    //GC_SaveDWORD( color, GrData);
#srcline 672 ;  //END_IF;
#srcline 673 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SetFgColor
 ULNK
RET
E     61
#endpou 

#pou GC_SetBgColor
#srcline 676 ;FUNCTION GC_SetBgColor : BOOL

#struct GC_SetBgColor__temp__
  udint addr
P     61
GC_SetBgColor_L0:
 LINK __SizeOf(GC_SetBgColor__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 691 ;    BEGIN
#srcline 692 ;    {ASM}
#srcline 693
    GC_TestSpaceMacro(5, GrData);
#srcline 694
    GC_SaveFcDwordMacro(GPRIMITIVE_SETBGCOLOR, color, GrData);
#srcline 695 ;    {END_ASM}
#srcline 697 ;    //GC_SaveByte( GPRIMITIVE_SETBGCOLOR, GrData);
#srcline 698 ;    //GC_SaveDWORD( color, GrData);
#srcline 699 ;  //END_IF;
#srcline 700 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SetBgColor
 ULNK
RET
E     61
#endpou 

#pou GC_SetTextSize
#srcline 703 ;FUNCTION GC_SetTextSize : BOOL

#struct GC_SetTextSize__temp__
  udint addr
P     61
GC_SetTextSize_L0:
 LINK __SizeOf(GC_SetTextSize__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 721 ;    BEGIN
#srcline 722 ;    {ASM}
#srcline 723
    GC_TestSpaceMacro(2, GrData);
#srcline 724
    GC_SaveFcByteMacro(GPRIMITIVE_SETTEXTSIZE, size, GrData);
#srcline 725 ;    {END_ASM}
#srcline 726 ;  //END_IF;
#srcline 727 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SetTextSize
 ULNK
RET
E     61
#endpou 

#pou GC_SetTextStyle
#srcline 730 ;FUNCTION GC_SetTextStyle : BOOL

#struct GC_SetTextStyle__temp__
  udint addr
P     61
GC_SetTextStyle_L0:
 LINK __SizeOf(GC_SetTextStyle__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 745 ;    BEGIN
#srcline 746 ;    {ASM}
#srcline 747
    GC_TestSpaceMacro(3, GrData);
#srcline 748
    GC_SaveFcWordMacro(GPRIMITIVE_SETTEXTSTYLE, style, GrData);
#srcline 749 ;    {END_ASM}
#srcline 750 ;    //GC_SaveByte( GPRIMITIVE_SETTEXTSTYLE, GrData);
#srcline 751 ;    //GC_SaveWord( UINT_TO_INT(style), GrData);
#srcline 752 ;  //END_IF;
#srcline 753 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SetTextStyle
 ULNK
RET
E     61
#endpou 

#pou GC_SetGradientStyle
#srcline 756 ;FUNCTION GC_SetGradientStyle : BOOL

#struct GC_SetGradientStyle__temp__
  udint addr
P     61
GC_SetGradientStyle_L0:
 LINK __SizeOf(GC_SetGradientStyle__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 777 ;    BEGIN
#srcline 778 ;    {ASM}
#srcline 779
    GC_TestSpaceMacro(10, GrData);
#srcline 780
    GC_SaveFcConstLenBlockMacro(GPRIMITIVE_SETGRADIENTSTYLE, color1, __sizeof(udint)*2+__sizeof(usint), GrData);
#srcline 781 ;    {END_ASM}
#srcline 782 ;  (** )
#srcline 783 ;    GC_SaveByte ( GPRIMITIVE_SETGRADIENTSTYLE, GrData);
#srcline 784 ;    GC_SaveDWORD( color1, GrData);
#srcline 785 ;    GC_SaveDWORD( color2, GrData);
#srcline 786 ;    GC_SaveByte ( style, GrData);
#srcline 787 ;  (**)
#srcline 788 ;  //END_IF;
#srcline 789 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SetGradientStyle
 ULNK
RET
E     61
#endpou 

#pou GC_SetOrigin
#srcline 791 ;FUNCTION GC_SetOrigin : BOOL

#struct GC_SetOrigin__temp__
  udint addr
P     61
GC_SetOrigin_L0:
 LINK __SizeOf(GC_SetOrigin__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 802 ;    BEGIN
#srcline 803 ;    {ASM}
#srcline 804
    GC_TestSpaceMacro(1, GrData);
#srcline 805 ;    {END_ASM}
#srcline 806 ;    GC_SaveByte( GPRIMITIVE_SETORIGIN, GrData);
 NXT
 LD   usint 10
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 807 ;//  END_IF;
#srcline 808 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SetOrigin
 ULNK
RET
E     61
#endpou 

#pou GC_ResetOrigin
#srcline 810 ;FUNCTION GC_ResetOrigin : BOOL

#struct GC_ResetOrigin__temp__
  udint addr
P     61
GC_ResetOrigin_L0:
 LINK __SizeOf(GC_ResetOrigin__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 821 ;    BEGIN
#srcline 822 ;    {ASM}
#srcline 823
    GC_TestSpaceMacro(1, GrData);
#srcline 824 ;    {END_ASM}
#srcline 825 ;    GC_SaveByte( GPRIMITIVE_RESETORIGIN, GrData);
 NXT
 LD   usint 11
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 826 ;  //END_IF;
#srcline 827 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_ResetOrigin
 ULNK
RET
E     61
#endpou 

#pou GC_SetVirtSize
#srcline 829 ;FUNCTION GC_SetVirtSize : BOOL

#struct GC_SetVirtSize__temp__
  udint addr
P     61
GC_SetVirtSize_L0:
 LINK __SizeOf(GC_SetVirtSize__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 851 ;    BEGIN
#srcline 852 ;    {ASM}
#srcline 853
    GC_TestSpaceMacro(5, GrData);
#srcline 854
    GC_SaveFcConstLenBlockMacro(GPRIMITIVE_SETVIRTSIZE, width, __sizeof(int)*2, GrData);
#srcline 855 ;    {END_ASM}
#srcline 856 ;  (** )
#srcline 857 ;    GC_SaveByte( GPRIMITIVE_SETVIRTSIZE, GrData);
#srcline 858 ;    GC_SaveWord( width, GrData);
#srcline 859 ;    GC_SaveWord( height, GrData);
#srcline 860 ;  (**)
#srcline 861 ;  //END_IF;
#srcline 862 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_SetVirtSize
 ULNK
RET
E     61
#endpou 

#pou GC_MoveTo
#srcline 866 ;FUNCTION GC_MoveTo : BOOL

#struct GC_MoveTo__temp__
  udint addr
P     61
GC_MoveTo_L0:
 LINK __SizeOf(GC_MoveTo__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 881 ;    BEGIN
#srcline 882 ;    {ASM}
#srcline 883
    GC_TestSpaceMacro(5, GrData);
#srcline 884
    GC_SaveFcDwordMacro(GPRIMITIVE_MOVETO, x, GrData);
#srcline 885 ;    {END_ASM}
#srcline 886 ;    //GC_SaveByte( GPRIMITIVE_MOVETO, GrData);
#srcline 887 ;    //GC_SavePos ( x, y, GrData);
#srcline 888 ;  //END_IF;
#srcline 889 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_MoveTo
 ULNK
RET
E     61
#endpou 

#pou GC_Move
#srcline 892 ;FUNCTION GC_Move : BOOL

#struct GC_Move__temp__
  udint addr
P     61
GC_Move_L0:
 LINK __SizeOf(GC_Move__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 908 ;    BEGIN
#srcline 909 ;    {ASM}
#srcline 910
    GC_TestSpaceMacro(5, GrData);
#srcline 911
    GC_SaveFcDwordMacro(GPRIMITIVE_MOVE, x, GrData);
#srcline 912 ;    {END_ASM}
#srcline 913 ;    //GC_SaveByte( GPRIMITIVE_MOVE, GrData);
#srcline 914 ;    //GC_SavePos( x, y, GrData);
#srcline 915 ;  //END_IF;
#srcline 916 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Move
 ULNK
RET
E     61
#endpou 

#pou GC_Point
#srcline 918 ;FUNCTION GC_Point : BOOL

#struct GC_Point__temp__
  udint addr
P     61
GC_Point_L0:
 LINK __SizeOf(GC_Point__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 933 ;    BEGIN
#srcline 934 ;    {ASM}
#srcline 935
    GC_TestSpaceMacro(5, GrData);
#srcline 936
    GC_SaveFcDwordMacro(GPRIMITIVE_POINT, x, GrData);
#srcline 937 ;    {END_ASM}
#srcline 938 ;    //GC_SaveByte( GPRIMITIVE_POINT, GrData);
#srcline 939 ;    //GC_SavePos ( x, y, GrData);
#srcline 940 ;  //END_IF;
#srcline 941 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Point
 ULNK
RET
E     61
#endpou 

#pou GC_LineTo
#srcline 944 ;FUNCTION GC_LineTo : BOOL

#struct GC_LineTo__temp__
  udint addr
P     61
GC_LineTo_L0:
 LINK __SizeOf(GC_LineTo__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 959 ;    BEGIN
#srcline 960 ;    {ASM}
#srcline 961
    GC_TestSpaceMacro(5, GrData);
#srcline 962
    GC_SaveFcDwordMacro(GPRIMITIVE_LINETO, x, GrData);
#srcline 963 ;    {END_ASM}
#srcline 964 ;    //GC_SaveByte( GPRIMITIVE_LINETO, GrData);
#srcline 965 ;    //GC_SavePos ( x, y, GrData);
#srcline 966 ;  //END_IF;
#srcline 967 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_LineTo
 ULNK
RET
E     61
#endpou 

#pou GC_Line
#srcline 970 ;FUNCTION GC_Line : BOOL

#struct GC_Line__temp__
  udint addr
P     61
GC_Line_L0:
 LINK __SizeOf(GC_Line__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 987 ;    BEGIN
#srcline 988 ;    {ASM}
#srcline 989
    GC_TestSpaceMacro(9, GrData);
#srcline 990
    ;GC_SaveFcPosMacro(GPRIMITIVE_LINE, x1, GrData);
#srcline 991
    ;GC_SavePosMacro(x2, y2, GrData);
#srcline 992
    GC_SaveFcConstLenBlockMacro(GPRIMITIVE_LINE, x1, __sizeof(int)*4, GrData);
#srcline 993 ;    {END_ASM}
#srcline 994 ;    //GC_SaveByte(GPRIMITIVE_LINE, GrData);
#srcline 995 ;    //GC_SavePos ( x1, y1, GrData);
#srcline 996 ;    //GC_SavePos ( x2, y2, GrData);
#srcline 997 ;  //END_IF;
#srcline 998 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Line
 ULNK
RET
E     61
#endpou 

#pou GC_Box
#srcline 1001 ;FUNCTION GC_Box : BOOL

#struct GC_Box__temp__
  udint addr
P     61
GC_Box_L0:
 LINK __SizeOf(GC_Box__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1022 ;    BEGIN
#srcline 1023 ;    {ASM}
#srcline 1024
    GC_TestSpaceMacro(9, GrData);
#srcline 1025 ;    {END_ASM}
#srcline 1026 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_Box_L1
#srcline 1027 ;      {ASM}
#srcline 1028
      ;GC_SaveFcPosMacro(GPRIMITIVE_FILLBOX, x, GrData);
#srcline 1029
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_FILLBOX, x, __sizeof(int)*4, GrData);
#srcline 1030 ;      {END_ASM}
#srcline 1031 ;//      GC_SaveByte( GPRIMITIVE_FILLBOX, GrData);
#srcline 1032 ;    ELSE
 JMP  GC_Box_L2
GC_Box_L1:
#srcline 1033 ;      {ASM}
#srcline 1034
      ;GC_SaveFcPosMacro(GPRIMITIVE_BOX, x, GrData);
#srcline 1035
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_BOX, x, __sizeof(int)*4, GrData);
#srcline 1036 ;      {END_ASM}
#srcline 1037 ;//      GC_SaveByte( GPRIMITIVE_BOX, GrData);
#srcline 1038 ;    END_IF;
GC_Box_L2:
#srcline 1039 ;//    GC_SavePos ( x, y, GrData);
#srcline 1040 ;    {ASM}
#srcline 1041
    ;GC_SavePosMacro(width, height, GrData);
#srcline 1042 ;    {END_ASM}
#srcline 1043 ;//    GC_SavePos ( width, height, GrData);
#srcline 1044 ;  //END_IF;
#srcline 1045 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Box
 ULNK
RET
E     61
#endpou 

#pou GC_CBox
#srcline 1047 ;FUNCTION GC_CBox : BOOL

#struct GC_CBox__temp__
  udint addr
P     61
GC_CBox_L0:
 LINK __SizeOf(GC_CBox__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1066 ;    BEGIN
#srcline 1067 ;    {ASM}
#srcline 1068
    GC_TestSpaceMacro(5, GrData);
#srcline 1069 ;    {END_ASM}
#srcline 1070 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_CBox_L1
#srcline 1071 ;      {ASM}
#srcline 1072
      GC_SaveFcDwordMacro(GPRIMITIVE_CFILLBOX, width, GrData);
#srcline 1073 ;      {END_ASM}
#srcline 1074 ;//      GC_SaveByte( GPRIMITIVE_CFILLBOX, GrData);
#srcline 1075 ;    ELSE
 JMP  GC_CBox_L2
GC_CBox_L1:
#srcline 1076 ;      {ASM}
#srcline 1077
      GC_SaveFcDwordMacro(GPRIMITIVE_CBOX, width, GrData);
#srcline 1078 ;      {END_ASM}
#srcline 1079 ;//      GC_SaveByte( GPRIMITIVE_CBOX, GrData);
#srcline 1080 ;    END_IF;
GC_CBox_L2:
#srcline 1081 ;//    GC_SavePos ( width, height, GrData);
#srcline 1082 ;  //END_IF;
#srcline 1083 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_CBox
 ULNK
RET
E     61
#endpou 

#pou GC_RoundBox
#srcline 1086 ;FUNCTION GC_RoundBox : BOOL

#struct GC_RoundBox__temp__
  udint addr
P     61
GC_RoundBox_L0:
 LINK __SizeOf(GC_RoundBox__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1108 ;    BEGIN
#srcline 1109 ;    {ASM}
#srcline 1110
    GC_TestSpaceMacro(11, GrData);
#srcline 1111 ;    {END_ASM}
#srcline 1112 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_RoundBox_L1
#srcline 1113 ;      {ASM}
#srcline 1114
      ;GC_SaveFcPosMacro(GPRIMITIVE_ROUNDFILLBOX, x, GrData);
#srcline 1115
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_ROUNDFILLBOX, x, __sizeof(int)*5, GrData);
#srcline 1116 ;      {END_ASM}
#srcline 1117 ;//      GC_SaveByte( GPRIMITIVE_ROUNDFILLBOX, GrData);
#srcline 1118 ;    ELSE
 JMP  GC_RoundBox_L2
GC_RoundBox_L1:
#srcline 1119 ;      {ASM}
#srcline 1120
      ;GC_SaveFcPosMacro(GPRIMITIVE_ROUNDBOX, x, GrData);
#srcline 1121
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_ROUNDBOX, x, __sizeof(int)*5, GrData);
#srcline 1122 ;      {END_ASM}
#srcline 1123 ;//      GC_SaveByte( GPRIMITIVE_ROUNDBOX, GrData);
#srcline 1124 ;    END_IF;
GC_RoundBox_L2:
#srcline 1125 ;//    GC_SavePos ( x, y, GrData);
#srcline 1126 ;    {ASM}
#srcline 1127
    ;GC_SavePosMacro(width, height, GrData);
#srcline 1128 ;    {END_ASM}
#srcline 1129 ;    //GC_SavePos ( width, height, GrData);
#srcline 1130 ;    //GC_SaveWord( r, GrData);
#srcline 1131 ;  //END_IF;
#srcline 1132 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_RoundBox
 ULNK
RET
E     61
#endpou 

#pou GC_CRoundBox
#srcline 1134 ;FUNCTION GC_CRoundBox : BOOL

#struct GC_CRoundBox__temp__
  udint addr
P     61
GC_CRoundBox_L0:
 LINK __SizeOf(GC_CRoundBox__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1154 ;    BEGIN
#srcline 1155 ;    {ASM}
#srcline 1156
    GC_TestSpaceMacro(7, GrData);
#srcline 1157 ;    {END_ASM}
#srcline 1158 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_CRoundBox_L1
#srcline 1159 ;      {ASM}
#srcline 1160
      ;GC_SaveFcPosMacro(GPRIMITIVE_CROUNDFILLBOX, width, GrData);
#srcline 1161
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_CROUNDFILLBOX, width, __sizeof(int)*3, GrData);
#srcline 1162 ;      {END_ASM}
#srcline 1163 ;//      GC_SaveByte( GPRIMITIVE_CROUNDFILLBOX, GrData);
#srcline 1164 ;    ELSE
 JMP  GC_CRoundBox_L2
GC_CRoundBox_L1:
#srcline 1165 ;      {ASM}
#srcline 1166
      ;GC_SaveFcPosMacro(GPRIMITIVE_CROUNDBOX, width, GrData);
#srcline 1167
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_CROUNDBOX, width, __sizeof(int)*3, GrData);
#srcline 1168 ;      {END_ASM}
#srcline 1169 ;//      GC_SaveByte( GPRIMITIVE_CROUNDBOX, GrData);
#srcline 1170 ;    END_IF;
GC_CRoundBox_L2:
#srcline 1171 ;//    GC_SavePos ( width, height, GrData);
#srcline 1172 ;//    GC_SaveWord( r, GrData);
#srcline 1173 ;  //END_IF;
#srcline 1174 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_CRoundBox
 ULNK
RET
E     61
#endpou 

#pou GC_Triangle
#srcline 1176 ;FUNCTION GC_Triangle : BOOL

#struct GC_Triangle__temp__
  udint addr
P     61
GC_Triangle_L0:
 LINK __SizeOf(GC_Triangle__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1199 ;    BEGIN
#srcline 1200 ;    {ASM}
#srcline 1201
    GC_TestSpaceMacro(14, GrData);
#srcline 1202 ;    {END_ASM}
#srcline 1203 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_Triangle_L1
#srcline 1204 ;      {ASM}
#srcline 1205
      GC_SaveFcConstLenBlockMacro2(GPRIMITIVE_FILLPOLYGON, 3, x1, __sizeof(int)*6, GrData);
#srcline 1206 ;      {END_ASM}
#srcline 1207 ;      //GC_SaveByte( GPRIMITIVE_FILLPOLYGON, GrData);
#srcline 1208 ;    ELSE
 JMP  GC_Triangle_L2
GC_Triangle_L1:
#srcline 1209 ;      {ASM}
#srcline 1210
      GC_SaveFcConstLenBlockMacro2(GPRIMITIVE_POLYGON, 3, x1, __sizeof(int)*6, GrData);
#srcline 1211 ;      {END_ASM}
#srcline 1212 ;      //GC_SaveByte( GPRIMITIVE_POLYGON, GrData);
#srcline 1213 ;    END_IF;
GC_Triangle_L2:
#srcline 1214 ;    (** )
#srcline 1215 ;    GC_SaveByte( 4, GrData); // pocet bodu
#srcline 1216 ;    GC_SavePos ( x1, y1, GrData);
#srcline 1217 ;    GC_SavePos ( x2, y2, GrData);
#srcline 1218 ;    GC_SavePos ( x3, y3, GrData);
#srcline 1219 ;    GC_SavePos ( x4, y4, GrData);
#srcline 1220 ;    (**)
#srcline 1221 ;  //END_IF;
#srcline 1222 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Triangle
 ULNK
RET
E     61
#endpou 

#pou GC_Polygon4
#srcline 1225 ;FUNCTION GC_Polygon4 : BOOL

#struct GC_Polygon4__temp__
  udint addr
P     61
GC_Polygon4_L0:
 LINK __SizeOf(GC_Polygon4__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1250 ;    BEGIN
#srcline 1251 ;    {ASM}
#srcline 1252
    GC_TestSpaceMacro(18, GrData);
#srcline 1253 ;    {END_ASM}
#srcline 1254 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_Polygon4_L1
#srcline 1255 ;      {ASM}
#srcline 1256
      GC_SaveFcConstLenBlockMacro2(GPRIMITIVE_FILLPOLYGON, 4, x1, __sizeof(int)*8, GrData);
#srcline 1257 ;      {END_ASM}
#srcline 1258 ;      //GC_SaveByte( GPRIMITIVE_FILLPOLYGON, GrData);
#srcline 1259 ;    ELSE
 JMP  GC_Polygon4_L2
GC_Polygon4_L1:
#srcline 1260 ;      {ASM}
#srcline 1261
      GC_SaveFcConstLenBlockMacro2(GPRIMITIVE_POLYGON, 4, x1, __sizeof(int)*8, GrData);
#srcline 1262 ;      {END_ASM}
#srcline 1263 ;      //GC_SaveByte( GPRIMITIVE_POLYGON, GrData);
#srcline 1264 ;    END_IF;
GC_Polygon4_L2:
#srcline 1265 ;    (** )
#srcline 1266 ;    GC_SaveByte( 4, GrData); // pocet bodu
#srcline 1267 ;    GC_SavePos ( x1, y1, GrData);
#srcline 1268 ;    GC_SavePos ( x2, y2, GrData);
#srcline 1269 ;    GC_SavePos ( x3, y3, GrData);
#srcline 1270 ;    GC_SavePos ( x4, y4, GrData);
#srcline 1271 ;    (**)
#srcline 1272 ;  //END_IF;
#srcline 1273 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Polygon4
 ULNK
RET
E     61
#endpou 

#pou GC_Polygon
#srcline 1275 ;FUNCTION GC_Polygon : BOOL

#struct GC_Polygon__temp__
  udint addr,
  udint cnt
P     61
GC_Polygon_L0:
 LINK __SizeOf(GC_Polygon__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1294 ;    BEGIN
#srcline 1295 ;    {ASM}
#srcline 1296
    LDX NumPoints
#srcline 1297
    MUL 4
#srcline 1298
    ADD 2
#srcline 1299
    WRY cnt
#srcline 1300
    GC_TestSpaceMacro2(cnt, GrData);
#srcline 1301 ;    {END_ASM}
#srcline 1302 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_Polygon_L1
#srcline 1303 ;      //GC_SaveByte( GPRIMITIVE_FILLPOLYGON, GrData);
#srcline 1304 ;      {ASM}
#srcline 1305
      GC_SaveFcByteMacro(GPRIMITIVE_FILLPOLYGON, NumPoints, GrData);
#srcline 1306 ;      {END_ASM}
#srcline 1307 ;    ELSE
 JMP  GC_Polygon_L2
GC_Polygon_L1:
#srcline 1308 ;      //GC_SaveByte( GPRIMITIVE_POLYGON, GrData);
#srcline 1309 ;      {ASM}
#srcline 1310
      GC_SaveFcByteMacro(GPRIMITIVE_POLYGON, NumPoints, GrData);
#srcline 1311 ;      {END_ASM}
#srcline 1312 ;    END_IF;
GC_Polygon_L2:
#srcline 1313 ;    //GC_SaveByte( NumPoints, GrData); // pocet bodu
#srcline 1314 ;  //END_IF;
#srcline 1315 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Polygon
 ULNK
RET
E     61
#endpou 

#pou GC_PolygonArray
#srcline 1317 ;FUNCTION GC_PolygonArray : BOOL

#struct GC_PolygonArray__temp__
  udint addr,
  udint cnt
P     61
GC_PolygonArray_L0:
 LINK __SizeOf(GC_PolygonArray__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1337 ;    BEGIN
#srcline 1338 ;    {ASM}
#srcline 1339
    LDX NumPoints
#srcline 1340
    MUL 4
#srcline 1341
    ADD 2
#srcline 1342
    WRY cnt
#srcline 1343
    GC_TestSpaceMacro2(cnt, GrData);
#srcline 1344 ;    {END_ASM}
#srcline 1345 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_PolygonArray_L1
#srcline 1346 ;      GC_SaveByte( GPRIMITIVE_FILLPOLYGON, GrData);
 NXT
 LD   usint 23
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 1347 ;    ELSE
 JMP  GC_PolygonArray_L2
GC_PolygonArray_L1:
#srcline 1348 ;      GC_SaveByte( GPRIMITIVE_POLYGON, GrData);
 NXT
 LD   usint 22
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 1349 ;    END_IF;
GC_PolygonArray_L2:
#srcline 1350 ;    GC_SaveDwordArray(n := NumPoints, data := void(Points), GrData := GrData);
 NXT
 LDX  NumPoints
#debug usint NumPoints
 WR   __Instance__GC_SaveDwordArray~n
#debug_left usint __Instance__GC_SaveDwordArray~n
 LDX  Points
 WR   __Instance__GC_SaveDwordArray~data
#debug_left pointer __Instance__GC_SaveDwordArray.data
 LDX  GrData
 WR   __Instance__GC_SaveDwordArray~GrData
#debug_left pointer __Instance__GC_SaveDwordArray.GrData
 PRV
 LEA  __Instance__GC_SaveDwordArray
 CAL  GC_SaveDwordArray_L0
#srcline 1351 ;  //END_IF;
#srcline 1352 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_PolygonArray
 ULNK
RET
E     61
#endpou 

#pou GC_Arc
#srcline 1355 ;FUNCTION GC_Arc : BOOL

#struct GC_Arc__temp__
  udint addr
P     61
GC_Arc_L0:
 LINK __SizeOf(GC_Arc__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1377 ;    BEGIN
#srcline 1378 ;    {ASM}
#srcline 1379
    GC_TestSpaceMacro(17, GrData);
#srcline 1380 ;    {END_ASM}
#srcline 1381 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_Arc_L1
#srcline 1382 ;      {ASM}
#srcline 1383
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_FILLARC, x, __sizeof(int)*4+__sizeof(real)*2, GrData);
#srcline 1384 ;      {END_ASM}
#srcline 1385 ;//      GC_SaveByte ( GPRIMITIVE_FILLARC, GrData);
#srcline 1386 ;    ELSE
 JMP  GC_Arc_L2
GC_Arc_L1:
#srcline 1387 ;      {ASM}
#srcline 1388
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_ARC, x, __sizeof(int)*4+__sizeof(real)*2, GrData);
#srcline 1389 ;      {END_ASM}
#srcline 1390 ;//      GC_SaveByte ( GPRIMITIVE_ARC, GrData);
#srcline 1391 ;    END_IF;
GC_Arc_L2:
#srcline 1392 ;(** )
#srcline 1393 ;    GC_SavePos  ( x, y, GrData);
#srcline 1394 ;    GC_SavePos  ( rx, ry, GrData);
#srcline 1395 ;    GC_SaveAngle( angle, GrData);
#srcline 1396 ;    GC_SaveAngle( dangle, GrData);
#srcline 1397 ;(**)
#srcline 1398 ;  //END_IF;
#srcline 1399 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Arc
 ULNK
RET
E     61
#endpou 

#pou GC_CArc
#srcline 1401 ;FUNCTION GC_CArc : BOOL

#struct GC_CArc__temp__
  udint addr
P     61
GC_CArc_L0:
 LINK __SizeOf(GC_CArc__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1420 ;    BEGIN
#srcline 1421 ;    {ASM}
#srcline 1422
    GC_TestSpaceMacro(13, GrData);
#srcline 1423 ;    {END_ASM}
#srcline 1424 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_CArc_L1
#srcline 1425 ;      {ASM}
#srcline 1426
      ;GC_SaveFcPosMacro(GPRIMITIVE_CFILLARC, rx, GrData);
#srcline 1427
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_CFILLARC, rx, __sizeof(int)*2+__sizeof(real)*2, GrData);
#srcline 1428 ;      {END_ASM}
#srcline 1429 ;//      GC_SaveByte ( GPRIMITIVE_CFILLARC, GrData);
#srcline 1430 ;    ELSE
 JMP  GC_CArc_L2
GC_CArc_L1:
#srcline 1431 ;      {ASM}
#srcline 1432
      ;GC_SaveFcPosMacro(GPRIMITIVE_CARC, rx, GrData);
#srcline 1433
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_CARC, rx, __sizeof(int)*2+__sizeof(real)*2, GrData);
#srcline 1434 ;      {END_ASM}
#srcline 1435 ;//      GC_SaveByte ( GPRIMITIVE_CARC, GrData);
#srcline 1436 ;    END_IF;
GC_CArc_L2:
#srcline 1437 ;(** )
#srcline 1438 ;    GC_SavePos  ( rx, ry, GrData);
#srcline 1439 ;    GC_SaveAngle( angle, GrData);
#srcline 1440 ;    GC_SaveAngle( dangle, GrData);
#srcline 1441 ;(**)
#srcline 1442 ;  //END_IF;
#srcline 1443 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_CArc
 ULNK
RET
E     61
#endpou 

#pou GC_Circle
#srcline 1446 ;FUNCTION GC_Circle : BOOL

#struct GC_Circle__temp__
  udint addr
P     61
GC_Circle_L0:
 LINK __SizeOf(GC_Circle__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1465 ;    BEGIN
#srcline 1466 ;    {ASM}
#srcline 1467
    GC_TestSpaceMacro(7, GrData);
#srcline 1468 ;    {END_ASM}
#srcline 1469 ;    IF Fill THEN
 LDX  Fill
#debug bool Fill
 JMC  GC_Circle_L1
#srcline 1470 ;      {ASM}
#srcline 1471
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_FILLCIRCLE, x, __sizeof(int)*3, GrData);
#srcline 1472 ;      {END_ASM}
#srcline 1473 ;//      GC_SaveByte( GPRIMITIVE_FILLCIRCLE, GrData);
#srcline 1474 ;    ELSE
 JMP  GC_Circle_L2
GC_Circle_L1:
#srcline 1475 ;      {ASM}
#srcline 1476
      GC_SaveFcConstLenBlockMacro(GPRIMITIVE_CIRCLE, x, __sizeof(int)*3, GrData);
#srcline 1477 ;      {END_ASM}
#srcline 1478 ;//      GC_SaveByte( GPRIMITIVE_CIRCLE, GrData);
#srcline 1479 ;    END_IF;
GC_Circle_L2:
#srcline 1480 ;//    GC_SavePos ( x, y, GrData);
#srcline 1481 ;//    GC_SaveWord( r, GrData);
#srcline 1482 ;//  END_IF;
#srcline 1483 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Circle
 ULNK
RET
E     61
#endpou 

#pou GC_CCircle
#srcline 1485 ;FUNCTION GC_CCircle : BOOL

#struct GC_CCircle__temp__
  udint addr
P     61
GC_CCircle_L0:
 LINK __SizeOf(GC_CCircle__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1502 ;    BEGIN
#srcline 1503 ;    {ASM}
#srcline 1504
    GC_TestSpaceMacro(3, GrData);
#srcline 1505 ;    {END_ASM}
#srcline 1506 ;    IF Fill THEN
 LDX  Fill
#debug bool Fill
 JMC  GC_CCircle_L1
#srcline 1507 ;      GC_SaveByte( GPRIMITIVE_CFILLCIRCLE, GrData);
 NXT
 LD   usint 39
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 1508 ;    ELSE
 JMP  GC_CCircle_L2
GC_CCircle_L1:
#srcline 1509 ;      GC_SaveByte( GPRIMITIVE_CCIRCLE, GrData);
 NXT
 LD   usint 38
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 1510 ;    END_IF;
GC_CCircle_L2:
#srcline 1511 ;    GC_SaveWord( r, GrData);
 NXT
 LDX  r
#debug int r
 EXTW 
 WR   __Instance__GC_SaveWord~data
#debug_left int __Instance__GC_SaveWord~data
 LDX  GrData
 WR   __Instance__GC_SaveWord~GrData
#debug_left pointer __Instance__GC_SaveWord.GrData
 PRV
 LEA  __Instance__GC_SaveWord
 CAL  GC_SaveWord_L0
#srcline 1512 ;  //END_IF;
#srcline 1513 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_CCircle
 ULNK
RET
E     61
#endpou 

#pou GC_CTriangle
#srcline 1515 ;FUNCTION GC_CTriangle : BOOL

#struct GC_CTriangle__temp__
  udint addr
P     61
GC_CTriangle_L0:
 LINK __SizeOf(GC_CTriangle__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1539 ;    BEGIN
#srcline 1540 ;    {ASM}
#srcline 1541
    GC_TestSpaceMacro(14, GrData);
#srcline 1542 ;    {END_ASM}
#srcline 1544 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_CTriangle_L1
#srcline 1545 ;      //GC_SaveByte( GPRIMITIVE_CFILLPOLYGON, GrData);
#srcline 1546 ;      {ASM}
#srcline 1547
      GC_SaveFcConstLenBlockMacro2(GPRIMITIVE_CFILLPOLYGON, 3, x1, __sizeof(int)*6, GrData);
#srcline 1548 ;      {END_ASM}
#srcline 1549 ;    ELSE
 JMP  GC_CTriangle_L2
GC_CTriangle_L1:
#srcline 1550 ;      //GC_SaveByte( GPRIMITIVE_CPOLYGON, GrData);
#srcline 1551 ;      {ASM}
#srcline 1552
      GC_SaveFcConstLenBlockMacro2(GPRIMITIVE_CPOLYGON, 3, x1, __sizeof(int)*6, GrData);
#srcline 1553 ;      {END_ASM}
#srcline 1554 ;    END_IF;
GC_CTriangle_L2:
#srcline 1555 ;    (** )
#srcline 1556 ;    GC_SaveByte( 4, GrData); // pocet bodu
#srcline 1557 ;    GC_SavePos ( x1, y1, GrData);
#srcline 1558 ;    GC_SavePos ( x2, y2, GrData);
#srcline 1559 ;    GC_SavePos ( x3, y3, GrData);
#srcline 1560 ;    GC_SavePos ( x4, y4, GrData);
#srcline 1561 ;    (**)
#srcline 1562 ;  //END_IF;
#srcline 1563 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_CTriangle
 ULNK
RET
E     61
#endpou 

#pou GC_CPolygon4
#srcline 1565 ;FUNCTION GC_CPolygon4 : BOOL

#struct GC_CPolygon4__temp__
  udint addr
P     61
GC_CPolygon4_L0:
 LINK __SizeOf(GC_CPolygon4__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1591 ;    BEGIN
#srcline 1592 ;    {ASM}
#srcline 1593
    GC_TestSpaceMacro(18, GrData);
#srcline 1594 ;    {END_ASM}
#srcline 1596 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_CPolygon4_L1
#srcline 1597 ;      //GC_SaveByte( GPRIMITIVE_CFILLPOLYGON, GrData);
#srcline 1598 ;      {ASM}
#srcline 1599
      GC_SaveFcConstLenBlockMacro2(GPRIMITIVE_CFILLPOLYGON, 4, x1, __sizeof(int)*8, GrData);
#srcline 1600 ;      {END_ASM}
#srcline 1601 ;    ELSE
 JMP  GC_CPolygon4_L2
GC_CPolygon4_L1:
#srcline 1602 ;      //GC_SaveByte( GPRIMITIVE_CPOLYGON, GrData);
#srcline 1603 ;      {ASM}
#srcline 1604
      GC_SaveFcConstLenBlockMacro2(GPRIMITIVE_CPOLYGON, 4, x1, __sizeof(int)*8, GrData);
#srcline 1605 ;      {END_ASM}
#srcline 1606 ;    END_IF;
GC_CPolygon4_L2:
#srcline 1607 ;    (** )
#srcline 1608 ;    GC_SaveByte( 4, GrData); // pocet bodu
#srcline 1609 ;    GC_SavePos ( x1, y1, GrData);
#srcline 1610 ;    GC_SavePos ( x2, y2, GrData);
#srcline 1611 ;    GC_SavePos ( x3, y3, GrData);
#srcline 1612 ;    GC_SavePos ( x4, y4, GrData);
#srcline 1613 ;    (**)
#srcline 1614 ;  //END_IF;
#srcline 1615 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_CPolygon4
 ULNK
RET
E     61
#endpou 

#pou GC_CPolygon
#srcline 1617 ;FUNCTION GC_CPolygon : BOOL

#struct GC_CPolygon__temp__
  udint addr,
  udint cnt
P     61
GC_CPolygon_L0:
 LINK __SizeOf(GC_CPolygon__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1637 ;    BEGIN
#srcline 1638 ;    {ASM}
#srcline 1639
    LDX NumPoints
#srcline 1640
    MUL 4
#srcline 1641
    ADD 2
#srcline 1642
    WRY cnt
#srcline 1643
    GC_TestSpaceMacro2(cnt, GrData);
#srcline 1644 ;    {END_ASM}
#srcline 1645 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_CPolygon_L1
#srcline 1646 ;      GC_SaveByte( GPRIMITIVE_CFILLPOLYGON, GrData);
 NXT
 LD   usint 47
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 1647 ;    ELSE
 JMP  GC_CPolygon_L2
GC_CPolygon_L1:
#srcline 1648 ;      GC_SaveByte( GPRIMITIVE_CPOLYGON, GrData);
 NXT
 LD   usint 46
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 1649 ;    END_IF;
GC_CPolygon_L2:
#srcline 1650 ;    GC_SaveByte( NumPoints, GrData); // pocet bodu
 NXT
 LDX  NumPoints
#debug usint NumPoints
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 1651 ;//  END_IF;
#srcline 1652 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_CPolygon
 ULNK
RET
E     61
#endpou 

#pou GC_CPolygonArray
#srcline 1654 ;FUNCTION GC_CPolygonArray : BOOL

#struct GC_CPolygonArray__temp__
  udint addr,
  udint cnt
P     61
GC_CPolygonArray_L0:
 LINK __SizeOf(GC_CPolygonArray__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1674 ;    BEGIN
#srcline 1675 ;    {ASM}
#srcline 1676
    LDX NumPoints
#srcline 1677
    MUL 4
#srcline 1678
    ADD 2
#srcline 1679
    WRY cnt
#srcline 1680
    GC_TestSpaceMacro2(cnt, GrData);
#srcline 1681 ;    {END_ASM}
#srcline 1682 ;    IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_CPolygonArray_L1
#srcline 1683 ;      GC_SaveByte( GPRIMITIVE_CFILLPOLYGON, GrData);
 NXT
 LD   usint 47
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 1684 ;    ELSE
 JMP  GC_CPolygonArray_L2
GC_CPolygonArray_L1:
#srcline 1685 ;      GC_SaveByte( GPRIMITIVE_CPOLYGON, GrData);
 NXT
 LD   usint 46
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 1686 ;    END_IF;
GC_CPolygonArray_L2:
#srcline 1687 ;    //GC_SaveByte( NumPoints, GrData); // pocet bodu
#srcline 1688 ;    GC_SaveDwordArray(n := NumPoints, data := void(Points), GrData := GrData);
 NXT
 LDX  NumPoints
#debug usint NumPoints
 WR   __Instance__GC_SaveDwordArray~n
#debug_left usint __Instance__GC_SaveDwordArray~n
 LDX  Points
 WR   __Instance__GC_SaveDwordArray~data
#debug_left pointer __Instance__GC_SaveDwordArray.data
 LDX  GrData
 WR   __Instance__GC_SaveDwordArray~GrData
#debug_left pointer __Instance__GC_SaveDwordArray.GrData
 PRV
 LEA  __Instance__GC_SaveDwordArray
 CAL  GC_SaveDwordArray_L0
#srcline 1689 ;//  END_IF;
#srcline 1690 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_CPolygonArray
 ULNK
RET
E     61
#endpou 

#pou GC_AddPoint
#srcline 1692 ;FUNCTION GC_AddPoint : BOOL

#struct GC_AddPoint__temp__
  udint addr
P     61
GC_AddPoint_L0:
 LINK __SizeOf(GC_AddPoint__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1708 ;    BEGIN
#srcline 1709 ;    {ASM}
#srcline 1710
    GC_TestSpaceMacro(4, GrData);
#srcline 1711
    GC_SavePosMacro(x, y, GrData);
#srcline 1712 ;    {END_ASM}
#srcline 1713 ;    //GC_SavePos ( x, y, GrData);
#srcline 1714 ;  //END_IF;
#srcline 1715 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_AddPoint
 ULNK
RET
E     61
#endpou 

#pou GC_WriteText
#srcline 1717 ;FUNCTION GC_WriteText : BOOL

#struct GC_WriteText__temp__
  udint addr,
  usint cnt
P     61
GC_WriteText_L0:
 LINK __SizeOf(GC_WriteText__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1737 ;    BEGIN
#srcline 1738 ;    {ASM}
#srcline 1739
    LEAX text
#srcline 1740
    SLEN
#srcline 1741
    WRY cnt
#srcline 1742
    GC_TestSpaceMacro3(cnt, 1, GrData);
#srcline 1743
    GC_SaveFcTempLenBlockMacro(GPRIMITIVE_WRITETEXT, text, cnt, GrData);)
#srcline 1744 ;    {END_ASM}
#srcline 1747 ;  //cnt := LEN( text);
#srcline 1748 ;  //IF GC_TestSpace( cnt+1, GrData) THEN
#srcline 1749 ;  //  GC_SaveByte  ( GPRIMITIVE_WRITETEXT, GrData);
#srcline 1750 ;  //  GC_SaveArray ( void(text), cnt, GrData);
#srcline 1751 ;  //END_IF;
#srcline 1752 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_WriteText
 ULNK
RET
E     61
#endpou 

#pou GC_CWriteText
#srcline 1754 ;FUNCTION GC_CWriteText : BOOL

#struct GC_CWriteText__temp__
  udint addr,
  uint cnt
P     61
GC_CWriteText_L0:
 LINK __SizeOf(GC_CWriteText__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1773 ;    BEGIN
#srcline 1774 ;    {ASM}
#srcline 1775
    LEAX text
#srcline 1776
    SLEN
#srcline 1777
    WRY cnt
#srcline 1778
    GC_TestSpaceMacro3(cnt, 1, GrData);
#srcline 1779
    GC_SaveFcTempLenBlockMacro(GPRIMITIVE_CWRITETEXT, text, cnt, GrData);
#srcline 1780 ;    {END_ASM}
#srcline 1782 ;  (** )
#srcline 1783 ;  cnt := LEN( text);
#srcline 1784 ;  IF GC_TestSpace( cnt+1, GrData) THEN
#srcline 1785 ;    GC_SaveByte  ( GPRIMITIVE_CWRITETEXT, GrData);
#srcline 1786 ;    GC_SaveArray ( void(text), UINT_TO_USINT(cnt), GrData);
#srcline 1787 ;  END_IF;
#srcline 1788 ;  (**)
#srcline 1789 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_CWriteText
 ULNK
RET
E     61
#endpou 

#pou GC_Image
#srcline 1791 ;FUNCTION GC_Image : BOOL

#struct GC_Image__temp__
  uint cnt,
  udint addr
P     61
GC_Image_L0:
 LINK __SizeOf(GC_Image__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1810 ;    BEGIN
#srcline 1811 ;    {ASM}
#srcline 1812
    LEAX fileName
#srcline 1813
    SLEN
#srcline 1814
    WRY cnt
#srcline 1815
    GC_TestSpaceMacro3(cnt, 5, GrData);
#srcline 1816
    GC_SaveFcDwordMacro (GPRIMITIVE_IMAGE, width, GrData);
#srcline 1817
    GC_SaveTempLenBlockMacro(filename, cnt, GrData);
#srcline 1818 ;    {END_ASM}
#srcline 1819 ;(** )
#srcline 1820 ;  cnt := LEN( FileName);
#srcline 1821 ;  IF GC_TestSpace( cnt + 5, GrData) THEN
#srcline 1822 ;    GC_SaveByte  ( GPRIMITIVE_IMAGE, GrData);
#srcline 1823 ;    GC_SaveWord  ( width, GrData);
#srcline 1824 ;    GC_SaveWord  ( height, GrData);
#srcline 1825 ;    GC_SaveArray ( void(FileName), UINT_TO_USINT(cnt), GrData);
#srcline 1826 ;  END_IF;
#srcline 1827 ;(**)
#srcline 1828 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Image
 ULNK
RET
E     61
#endpou 

#pou GC_CImage
#srcline 1831 ;FUNCTION GC_CImage : BOOL

#struct GC_CImage__temp__
  uint cnt,
  udint addr
P     61
GC_CImage_L0:
 LINK __SizeOf(GC_CImage__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1850 ;    BEGIN
#srcline 1851 ;    {ASM}
#srcline 1852
    LEAX fileName
#srcline 1853
    SLEN
#srcline 1854
    WRY cnt
#srcline 1855
    GC_TestSpaceMacro3(cnt, 5, GrData);
#srcline 1856
    GC_SaveFcDwordMacro (GPRIMITIVE_CIMAGE, width, GrData);
#srcline 1857
    GC_SaveTempLenBlockMacro(filename, cnt, GrData);
#srcline 1858 ;    {END_ASM}
#srcline 1859 ;    
#srcline 1860 ;(** )
#srcline 1861 ;  IF GC_TestSpace( LEN( FileName) + 5, GrData) THEN
#srcline 1862 ;    {ASM}
#srcline 1863 ;    GC_SaveFcDwordMacro(GPRIMITIVE_CIMAGE, width, GrData);
#srcline 1864 ;    {END_ASM}
#srcline 1865 ;    GC_SaveByte  ( GPRIMITIVE_CIMAGE, GrData);
#srcline 1866 ;    GC_SaveWord  ( width, GrData);
#srcline 1867 ;    GC_SaveWord  ( height, GrData);
#srcline 1868 ;    GC_SaveString( FileName, GrData);
#srcline 1869 ;  END_IF;
#srcline 1870 ;(**)
#srcline 1871 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_CImage
 ULNK
RET
E     61
#endpou 

#pou GC_Heading
#srcline 1873 ;FUNCTION GC_Heading : BOOL

#struct GC_Heading__temp__
  udint addr
P     61
GC_Heading_L0:
 LINK __SizeOf(GC_Heading__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1887 ;    BEGIN
#srcline 1888 ;    {ASM}
#srcline 1889
    GC_TestSpaceMacro(5, GrData);
#srcline 1890
    GC_SaveFcDwordMacro (GPRIMITIVE_HEADING, angle, GrData);
#srcline 1891 ;    {END_ASM}
#srcline 1892 ;  (** )
#srcline 1893 ;    GC_SaveByte( GPRIMITIVE_HEADING, GrData);
#srcline 1894 ;    GC_SaveAngle( angle, GrData);
#srcline 1895 ;  (**)
#srcline 1896 ;  //END_IF;
#srcline 1897 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Heading
 ULNK
RET
E     61
#endpou 

#pou GC_Turn
#srcline 1899 ;FUNCTION GC_Turn : BOOL

#struct GC_Turn__temp__
  udint addr
P     61
GC_Turn_L0:
 LINK __SizeOf(GC_Turn__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1914 ;    BEGIN
#srcline 1915 ;    {ASM}
#srcline 1916
    GC_TestSpaceMacro(5, GrData);
#srcline 1917
    GC_SaveFcDwordMacro (GPRIMITIVE_TURN, angle, GrData);
#srcline 1918 ;    {END_ASM}
#srcline 1919 ;  (** )
#srcline 1920 ;    GC_SaveByte( GPRIMITIVE_TURN, GrData);
#srcline 1921 ;    GC_SaveAngle( angle, GrData);
#srcline 1922 ;  (**)
#srcline 1923 ;  //END_IF;
#srcline 1924 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_Turn
 ULNK
RET
E     61
#endpou 

#pou GC_LineFwd
#srcline 1926 ;FUNCTION GC_LineFwd : BOOL

#struct GC_LineFwd__temp__
  udint addr
P     61
GC_LineFwd_L0:
 LINK __SizeOf(GC_LineFwd__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1940 ;    BEGIN
#srcline 1941 ;    {ASM}
#srcline 1942
    GC_TestSpaceMacro(3, GrData);
#srcline 1943
    GC_SaveFcWordMacro (GPRIMITIVE_LINEFWD, length, GrData);
#srcline 1944 ;    {END_ASM}
#srcline 1945 ;  (** )
#srcline 1946 ;    GC_SaveByte( GPRIMITIVE_LINEFWD, GrData);
#srcline 1947 ;    GC_SaveWord( length, GrData);
#srcline 1948 ;  (**)
#srcline 1949 ;  //END_IF;
#srcline 1950 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_LineFwd
 ULNK
RET
E     61
#endpou 

#pou GC_MoveFwd
#srcline 1952 ;FUNCTION GC_MoveFwd : BOOL

#struct GC_MoveFwd__temp__
  udint addr
P     61
GC_MoveFwd_L0:
 LINK __SizeOf(GC_MoveFwd__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1966 ;    BEGIN
#srcline 1967 ;    {ASM}
#srcline 1968
    GC_TestSpaceMacro(3, GrData);
#srcline 1969
    GC_SaveFcWordMacro (GPRIMITIVE_MOVEFWD, length, GrData);
#srcline 1970 ;    {END_ASM}
#srcline 1971 ;  (** )
#srcline 1972 ;    GC_SaveByte( GPRIMITIVE_MOVEFWD, GrData);
#srcline 1973 ;    GC_SaveWord( length, GrData);
#srcline 1974 ;  (**)
#srcline 1975 ;  //END_IF;
#srcline 1976 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_MoveFwd
 ULNK
RET
E     61
#endpou 

#pou GC_PushPosition
#srcline 1978 ;FUNCTION GC_PushPosition : BOOL

#struct GC_PushPosition__temp__
  udint addr
P     61
GC_PushPosition_L0:
 LINK __SizeOf(GC_PushPosition__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 1997 ;    BEGIN
#srcline 1998 ;    {ASM}
#srcline 1999
    GC_TestSpaceMacro(2, GrData);
#srcline 2000
    GC_SaveFcByteMacro (GPRIMITIVE_PUSHPOSITION, index, GrData);
#srcline 2001 ;    {END_ASM}
#srcline 2002 ;  (** )
#srcline 2003 ;    GC_SaveByte( GPRIMITIVE_PUSHPOSITION, GrData);
#srcline 2004 ;    GC_SaveByte( index, GrData);
#srcline 2005 ;  (**)
#srcline 2006 ;  //END_IF;
#srcline 2007 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_PushPosition
 ULNK
RET
E     61
#endpou 

#pou GC_PopPosition
#srcline 2009 ;FUNCTION GC_PopPosition : BOOL

#struct GC_PopPosition__temp__
  udint addr
P     61
GC_PopPosition_L0:
 LINK __SizeOf(GC_PopPosition__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 2028 ;    BEGIN
#srcline 2029 ;    {ASM}
#srcline 2030
    GC_TestSpaceMacro(2, GrData);
#srcline 2031
    GC_SaveFcByteMacro (GPRIMITIVE_POPPOSITION, index, GrData);
#srcline 2032 ;    {END_ASM}
#srcline 2033 ;  (** )
#srcline 2034 ;    GC_SaveByte( GPRIMITIVE_POPPOSITION, GrData);
#srcline 2035 ;    GC_SaveByte( index, GrData);
#srcline 2036 ;  (**)
#srcline 2037 ;  //END_IF;
#srcline 2038 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_PopPosition
 ULNK
RET
E     61
#endpou 

#pou GC_PushHeading
#srcline 2040 ;FUNCTION GC_PushHeading : BOOL

#struct GC_PushHeading__temp__
  udint addr
P     61
GC_PushHeading_L0:
 LINK __SizeOf(GC_PushHeading__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 2059 ;    BEGIN
#srcline 2060 ;    {ASM}
#srcline 2061
    GC_TestSpaceMacro(2, GrData);
#srcline 2062
    GC_SaveFcByteMacro (GPRIMITIVE_PUSHHEADING, index, GrData);
#srcline 2063 ;    {END_ASM}
#srcline 2064 ;    (** )
#srcline 2065 ;    GC_SaveByte( GPRIMITIVE_PUSHHEADING, GrData);
#srcline 2066 ;    GC_SaveByte( index, GrData);
#srcline 2067 ;    (**)
#srcline 2068 ;  //END_IF;
#srcline 2069 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_PushHeading
 ULNK
RET
E     61
#endpou 

#pou GC_PopHeading
#srcline 2071 ;FUNCTION GC_PopHeading : BOOL

#struct GC_PopHeading__temp__
  udint addr
P     61
GC_PopHeading_L0:
 LINK __SizeOf(GC_PopHeading__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 2090 ;    BEGIN
#srcline 2091 ;    {ASM}
#srcline 2092
    GC_TestSpaceMacro(2, GrData);
#srcline 2093
    GC_SaveFcByteMacro (GPRIMITIVE_POPHEADING, index, GrData);
#srcline 2094 ;    {END_ASM}
#srcline 2095 ;    (** )
#srcline 2096 ;    {END_ASM}
#srcline 2097 ;    GC_SaveByte( GPRIMITIVE_POPHEADING, GrData);
#srcline 2098 ;    GC_SaveByte( index, GrData);
#srcline 2099 ;    (**)
#srcline 2100 ;  //END_IF;
#srcline 2101 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_PopHeading
 ULNK
RET
E     61
#endpou 

#pou GC_GraphLineArray
#srcline 2103 ;FUNCTION GC_GraphLineArray : BOOL

#struct GC_GraphLineArray__temp__
  udint addr,
  uint cnt
P     61
GC_GraphLineArray_L0:
 LINK __SizeOf(GC_GraphLineArray__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 2128 ;    BEGIN
#srcline 2129 ;    {ASM}
#srcline 2130
    LDX NumPoints
#srcline 2131
    MUL 2
#srcline 2132
    WRY cnt
#srcline 2133
    GC_TestSpaceMacro3(cnt, 6, GrData);
#srcline 2134
    GC_SaveFcConstLenBlockMacro(GPRIMITIVE_GRAPHLINE, params, __sizeof(int)*2+__sizeof(usint), GrData);
#srcline 2135
    GC_SaveTempLenPtrBlockMacro(data, cnt, GrData);
#srcline 2136 ;    {END_ASM}
#srcline 2139 ;  (** )
#srcline 2140 ;  IF GC_TestSpace( 6 + INT_TO_UINT(NumPoints) * 2, GrData) THEN
#srcline 2141 ;    GC_SaveByte( GPRIMITIVE_GRAPHLINE, GrData);
#srcline 2142 ;    GC_SaveByte( Params, GrData);
#srcline 2143 ;    GC_SaveWord( Length, GrData);
#srcline 2144 ;    (*
#srcline 2145 ;    GC_SaveWord( NumPoints, GrData);
#srcline 2146 ;    for a := 1 to NumPoints do
#srcline 2147 ;        GC_SaveWord( Data^, GrData);
#srcline 2148 ;        Data := Data + 2;
#srcline 2149 ;    end_for;
#srcline 2150 ;    * )
#srcline 2151 ;    GC_SaveWordArray(NumPoints, Data, GrData);
#srcline 2152 ;  END_IF;
#srcline 2153 ;  (**)
#srcline 2154 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_GraphLineArray
 ULNK
RET
E     61
#endpou 

#pou GC_GraphLineRealArray
#srcline 2156 ;FUNCTION GC_GraphLineRealArray : BOOL

#struct GC_GraphLineRealArray__temp__
  real stepY,
  real zero,
  int zeroline,
  pointer pStart,
  pointer pEnd,
  pointer pInt,
  udint addr,
  uint cnt
P     61
GC_GraphLineRealArray_L0:
 LINK __SizeOf(GC_GraphLineRealArray__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__GC_GraphLineRealArray
 WRX  a
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pStart
 LD   udint $FFFFFFFF    ; nil
 WRY  pEnd
 LD   udint $FFFFFFFF    ; nil
 WRY  pInt
; End initialize - dynamic variables
#srcline 2192 ;  stepY := (INT_TO_REAL(height)/(maxY - minY)); //meritko
 LDX  height
#debug int height
 EXTW 
 ILF
 LDX  maxY
#debug real maxY
 LDX  minY
#debug real minY
 SUF
 DIF
 WRY  stepY
#debug_left real stepY
#srcline 2194 ;  //urceni zda nula lezi v grafu
#srcline 2195 ;  IF minY > 0.0 THEN
 LDX  minY
#debug real minY
 LD   real 0.0
 GTF
 JMC  GC_GraphLineRealArray_L1
#srcline 2196 ;    zero := minY;
 LDX  minY
#debug real minY
 WRY  zero
#debug_left real zero
#srcline 2197 ;  ELSIF maxY < 0.0 THEN
 JMP  GC_GraphLineRealArray_L2
GC_GraphLineRealArray_L1:
 LDX  maxY
#debug real maxY
 LD   real 0.0
 LTF
 JMC  GC_GraphLineRealArray_L3
#srcline 2198 ;    zero := maxY;
 LDX  maxY
#debug real maxY
 WRY  zero
#debug_left real zero
#srcline 2199 ;  ELSE
 JMP  GC_GraphLineRealArray_L2
GC_GraphLineRealArray_L3:
#srcline 2200 ;    zero := 0.0;
 LD   real 0.0
 WRY  zero
#debug_left real zero
#srcline 2201 ;  END_IF;
GC_GraphLineRealArray_L2:
#srcline 2203 ;  (**)
#srcline 2204 ;    {ASM}
#srcline 2205
    LDX NumPoints
#srcline 2206
    MUL 2
#srcline 2207
    WRY cnt
#srcline 2208
    GC_TestSpaceMacro3(cnt, 16, GrData);
#srcline 2209 ;    {END_ASM}
#srcline 2210 ;  (**)
#srcline 2212 ;  //IF GC_TestSpace( 16 + INT_TO_UINT(NumPoints) * 2, GrData) THEN
#srcline 2213 ;    zeroLine := REAL_TO_INT(stepY * (LIMIT( minY, 0.0, maxY) - minY));
 LDY  stepY
#debug real stepY
 LD   real 0.0
 LDX  minY
#debug real minY
 MAXF
 LDX  maxY
#debug real maxY
 MINF
 LDX  minY
#debug real minY
 SUF
 MUF
 RND
 IFW
 EXTW
 WRY  zeroLine
#debug_left int zeroLine
#srcline 2215 ;    GC_Move(0, -zeroline, GrData); //posunout pero na nulu
 NXT
 LD   int 0
 WR   __Instance__GC_Move~x
#debug_left int __Instance__GC_Move~x
 LDY  zeroline
#debug int zeroline
 EXTW 
 CSGL 
 WR   __Instance__GC_Move~y
#debug_left int __Instance__GC_Move~y
 LDX  GrData
 WR   __Instance__GC_Move~GrData
#debug_left pointer __Instance__GC_Move.GrData
 PRV
 LEA  __Instance__GC_Move
 CAL  GC_Move_L0
#srcline 2217 ;    pStart := ADR(data);
 LDX  data
#debug pointer data
 LEAY pStart
 WRIL 
#debug_left pointer pStart
#srcline 2218 ;    pEnd := pStart + INT_TO_UDINT(numPoints)*SIZEOF(REAL);
 LEAY pStart
 LDIL 
#debug pointer pStart
 LDX  numPoints
#debug int numPoints
 EXTW 
 LD   __sizeof(real)  ; SizeOf()
 MUL
 ADD
 LEAY pEnd
 WRIL 
#debug_left pointer pEnd
#srcline 2220 ;    {ASM}
#srcline 2221
    GC_SaveFcConstLenBlockMacro(GPRIMITIVE_GRAPHLINE, params, __sizeof(int)*2+__sizeof(usint), GrData);
#srcline 2222 ;    {END_ASM}
#srcline 2223 ;    (** )
#srcline 2224 ;    GC_SaveByte( GPRIMITIVE_GRAPHLINE, GrData);
#srcline 2225 ;    GC_SaveByte( Params, GrData);
#srcline 2226 ;    GC_SaveWord( Length, GrData);
#srcline 2227 ;    GC_SaveWord( NumPoints, GrData);
#srcline 2228 ;    (**)
#srcline 2229 ;    pInt := ADR(GrData.buf[GrData.info.actLen]);
 LDX  GrData
 ADD  20  ; + offset 
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 RCHK 8191   ; Range Check
 ADD     ; + offset 
#debug pointer GrData.buf[GrData.info.actLen]
 LEAY pInt
 WRIL 
#debug_left pointer pInt
#srcline 2230 ;    GrData.info.actLen := GrData.info.actLen + INT_TO_UINT(numPoints)*2;
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LDX  numPoints
#debug int numPoints
 EXTW 
 AND  $FFFF
 LD   uint 2
 MUL
 AND  $FFFF
 ADD
 AND  $FFFF
 LDX  GrData
 ADD  4  ; + offset 
 WRIW 
#debug_left uint GrData.info.actLen
#srcline 2231 ;    WHILE PTR_TO_UDINT(pStart) < PTR_TO_UDINT(pEnd) DO
GC_GraphLineRealArray_L4:
 LEAY pStart
 LDIL 
#debug pointer pStart
 LEAY pEnd
 LDIL 
#debug pointer pEnd
 LT
 JMC  GC_GraphLineRealArray_L5
 DBG 
#srcline 2232 ;      //GC_SaveWord(REAL_TO_INT(stepY * (LIMIT( minY, pStart^, maxY) - zero)), GrData);
#srcline 2233 ;      pInt^  := REAL_TO_INT(stepY * (LIMIT( minY, pStart^, maxY) - zero));
 LDY  stepY
#debug real stepY
 LEAY pStart
 LDIL    ; dereference 
 LDIL 
#debug real pStart^
 LDX  minY
#debug real minY
 MAXF
 LDX  maxY
#debug real maxY
 MINF
 LDY  zero
#debug real zero
 SUF
 MUF
 RND
 IFW
 EXTW
 LEAY pInt
 LDIL    ; dereference 
 WRIW 
#debug_left int pInt^
#srcline 2234 ;      pInt   := pInt + SIZEOF(INT);
 LEAY pInt
 LDIL 
#debug pointer pInt
 LD   __sizeof(int)  ; SizeOf()
 ADD
 LEAY pInt
 WRIL 
#debug_left pointer pInt
#srcline 2235 ;      pStart := pStart + SIZEOF(REAL);
 LEAY pStart
 LDIL 
#debug pointer pStart
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStart
 WRIL 
#debug_left pointer pStart
#srcline 2236 ;    END_WHILE;
 JMP  GC_GraphLineRealArray_L4
GC_GraphLineRealArray_L5:
#srcline 2238 ;    GC_Move(0, zeroline, GrData); //vratit pero zpet
 NXT
 LD   int 0
 WR   __Instance__GC_Move~x
#debug_left int __Instance__GC_Move~x
 LDY  zeroline
#debug int zeroline
 EXTW 
 WR   __Instance__GC_Move~y
#debug_left int __Instance__GC_Move~y
 LDX  GrData
 WR   __Instance__GC_Move~GrData
#debug_left pointer __Instance__GC_Move.GrData
 PRV
 LEA  __Instance__GC_Move
 CAL  GC_Move_L0
#srcline 2239 ;  //END_IF;
#srcline 2241 ;  (*
#srcline 2242 ;  IF GC_TestSpace( 6 + INT_TO_UINT(NumPoints) * 2, GrData) THEN
#srcline 2243 ;    GC_SaveByte( GPRIMITIVE_GRAPHLINE, GrData);
#srcline 2244 ;    GC_SaveByte( Params, GrData);
#srcline 2245 ;    GC_SaveWord( Length, GrData);
#srcline 2246 ;    GC_SaveWordArray(NumPoints, Data, GrData);
#srcline 2247 ;  END_IF;
#srcline 2248 ;  *)
#srcline 2249 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_GraphLineRealArray
 ULNK
RET
E     61
#endpou 

#pou GC_GraphLine
#srcline 2251 ;FUNCTION GC_GraphLine : BOOL

#struct GC_GraphLine__temp__
  udint addr,
  uint cnt
P     61
GC_GraphLine_L0:
 LINK __SizeOf(GC_GraphLine__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 2275 ;    BEGIN
#srcline 2276 ;    {ASM}
#srcline 2277
    LDX NumPoints
#srcline 2278
    MUL 2
#srcline 2279
    WRY cnt
#srcline 2280
    GC_TestSpaceMacro3(cnt, 6, GrData);
#srcline 2281
    GC_SaveFcConstLenBlockMacro(GPRIMITIVE_GRAPHLINE, params, __sizeof(usint)+__sizeof(int)*2, GrData);
#srcline 2282 ;    {END_ASM}
#srcline 2284 ;  (** )
#srcline 2285 ;  IF GC_TestSpace( 6 + INT_TO_UINT(NumPoints) * 2, GrData) THEN
#srcline 2286 ;    GC_SaveByte( GPRIMITIVE_GRAPHLINE, GrData);
#srcline 2287 ;    GC_SaveByte( Params, GrData);
#srcline 2288 ;    GC_SaveWord( Length, GrData);
#srcline 2289 ;    GC_SaveWord( NumPoints, GrData);
#srcline 2290 ;  END_IF;
#srcline 2291 ;  (**)
#srcline 2292 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_GraphLine
 ULNK
RET
E     61
#endpou 

#pou GC_GraphBarsArray
#srcline 2294 ;FUNCTION GC_GraphBarsArray : BOOL (*

#struct GC_GraphBarsArray__temp__
  udint addr,
  uint cnt
P     61
GC_GraphBarsArray_L0:
 LINK __SizeOf(GC_GraphBarsArray__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 2319 ;    BEGIN
#srcline 2320 ;    {ASM}
#srcline 2321
    LDX NumPoints
#srcline 2322
    MUL 2
#srcline 2323
    WRY cnt
#srcline 2324
    GC_TestSpaceMacro3(cnt, 8, GrData);
#srcline 2325
    GC_SaveFcConstLenBlockMacro(GPRIMITIVE_GRAPHBARS, params, __sizeof(int)*3+__sizeof(usint), GrData);
#srcline 2326
    GC_SaveTempLenPtrBlockMacro(data, cnt, GrData);
#srcline 2327 ;    {END_ASM}
#srcline 2329 ;    (** )
#srcline 2330 ;  IF GC_TestSpace( 8 + INT_TO_UINT(NumPoints) * 2, GrData) THEN
#srcline 2331 ;    GC_SaveByte( GPRIMITIVE_GRAPHBARS, GrData);
#srcline 2332 ;    GC_SaveByte( Params, GrData);
#srcline 2333 ;    GC_SaveWord( Length, GrData);
#srcline 2334 ;    GC_SaveWord( BarWidth, GrData);
#srcline 2335 ;    //GC_SaveWord( NumPoints, GrData);
#srcline 2336 ;    GC_SaveWordArray(NumPoints, Data, GrData);
#srcline 2337 ;  END_IF;
#srcline 2338 ;  (**)
#srcline 2339 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_GraphBarsArray
 ULNK
RET
E     61
#endpou 

#pou GC_GraphBarsRealArray
#srcline 2341 ;FUNCTION GC_GraphBarsRealArray : BOOL (*

#struct GC_GraphBarsRealArray__temp__
  real stepY,
  real zero,
  int zeroline,
  pointer pStart,
  pointer pEnd,
  pointer pInt,
  udint addr,
  uint cnt
P     61
GC_GraphBarsRealArray_L0:
 LINK __SizeOf(GC_GraphBarsRealArray__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__GC_GraphBarsRealArray
 WRX  a
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pStart
 LD   udint $FFFFFFFF    ; nil
 WRY  pEnd
 LD   udint $FFFFFFFF    ; nil
 WRY  pInt
; End initialize - dynamic variables
#srcline 2378 ;  stepY := (INT_TO_REAL(height)/(maxY - minY)); //meritko
 LDX  height
#debug int height
 EXTW 
 ILF
 LDX  maxY
#debug real maxY
 LDX  minY
#debug real minY
 SUF
 DIF
 WRY  stepY
#debug_left real stepY
#srcline 2380 ;  //urceni zda nula lezi v grafu
#srcline 2381 ;  IF minY > 0.0 THEN
 LDX  minY
#debug real minY
 LD   real 0.0
 GTF
 JMC  GC_GraphBarsRealArray_L1
#srcline 2382 ;    zero := minY;
 LDX  minY
#debug real minY
 WRY  zero
#debug_left real zero
#srcline 2383 ;  ELSIF maxY < 0.0 THEN
 JMP  GC_GraphBarsRealArray_L2
GC_GraphBarsRealArray_L1:
 LDX  maxY
#debug real maxY
 LD   real 0.0
 LTF
 JMC  GC_GraphBarsRealArray_L3
#srcline 2384 ;    zero := maxY;
 LDX  maxY
#debug real maxY
 WRY  zero
#debug_left real zero
#srcline 2385 ;  ELSE
 JMP  GC_GraphBarsRealArray_L2
GC_GraphBarsRealArray_L3:
#srcline 2386 ;    zero := 0.0;
 LD   real 0.0
 WRY  zero
#debug_left real zero
#srcline 2387 ;  END_IF;
GC_GraphBarsRealArray_L2:
#srcline 2389 ;  (**)
#srcline 2390 ;    {ASM}
#srcline 2391
    LDX NumPoints
#srcline 2392
    MUL 2
#srcline 2393
    WRY cnt
#srcline 2394
    GC_TestSpaceMacro3(cnt, 18, GrData);
#srcline 2395 ;    {END_ASM}
#srcline 2396 ;  (**)
#srcline 2398 ;  //IF GC_TestSpace( 18 + INT_TO_UINT(NumPoints) * 2, GrData) THEN
#srcline 2399 ;    zeroLine := REAL_TO_INT(stepY * (LIMIT( minY, 0.0, maxY) - minY));
 LDY  stepY
#debug real stepY
 LD   real 0.0
 LDX  minY
#debug real minY
 MAXF
 LDX  maxY
#debug real maxY
 MINF
 LDX  minY
#debug real minY
 SUF
 MUF
 RND
 IFW
 EXTW
 WRY  zeroLine
#debug_left int zeroLine
#srcline 2401 ;    GC_Move(0, -zeroline, GrData); //posunout pero na nulu
 NXT
 LD   int 0
 WR   __Instance__GC_Move~x
#debug_left int __Instance__GC_Move~x
 LDY  zeroline
#debug int zeroline
 EXTW 
 CSGL 
 WR   __Instance__GC_Move~y
#debug_left int __Instance__GC_Move~y
 LDX  GrData
 WR   __Instance__GC_Move~GrData
#debug_left pointer __Instance__GC_Move.GrData
 PRV
 LEA  __Instance__GC_Move
 CAL  GC_Move_L0
#srcline 2403 ;    pStart := ADR(data);
 LDX  data
#debug pointer data
 LEAY pStart
 WRIL 
#debug_left pointer pStart
#srcline 2404 ;    pEnd := pStart + INT_TO_UDINT(numPoints)*SIZEOF(REAL);
 LEAY pStart
 LDIL 
#debug pointer pStart
 LDX  numPoints
#debug int numPoints
 EXTW 
 LD   __sizeof(real)  ; SizeOf()
 MUL
 ADD
 LEAY pEnd
 WRIL 
#debug_left pointer pEnd
#srcline 2405 ;  (**)
#srcline 2406 ;    {ASM}
#srcline 2407
    GC_SaveFcConstLenBlockMacro(GPRIMITIVE_GRAPHBARS, params, __sizeof(int)*3+__sizeof(usint), GrData);
#srcline 2408 ;    {END_ASM}
#srcline 2409 ;    (** )
#srcline 2410 ;    GC_SaveByte( GPRIMITIVE_GRAPHBARS, GrData);
#srcline 2411 ;    GC_SaveByte( Params, GrData);
#srcline 2412 ;    GC_SaveWord( Length, GrData);
#srcline 2413 ;    GC_SaveWord( BarWidth, GrData);
#srcline 2414 ;    GC_SaveWord( NumPoints, GrData);
#srcline 2415 ;    (**)
#srcline 2416 ;    pInt := ADR(GrData.buf[GrData.info.actLen]);
 LDX  GrData
 ADD  20  ; + offset 
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 RCHK 8191   ; Range Check
 ADD     ; + offset 
#debug pointer GrData.buf[GrData.info.actLen]
 LEAY pInt
 WRIL 
#debug_left pointer pInt
#srcline 2417 ;    GrData.info.actLen := GrData.info.actLen + INT_TO_UINT(numPoints)*2;
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LDX  numPoints
#debug int numPoints
 EXTW 
 AND  $FFFF
 LD   uint 2
 MUL
 AND  $FFFF
 ADD
 AND  $FFFF
 LDX  GrData
 ADD  4  ; + offset 
 WRIW 
#debug_left uint GrData.info.actLen
#srcline 2418 ;    WHILE PTR_TO_UDINT(pStart) < PTR_TO_UDINT(pEnd) DO
GC_GraphBarsRealArray_L4:
 LEAY pStart
 LDIL 
#debug pointer pStart
 LEAY pEnd
 LDIL 
#debug pointer pEnd
 LT
 JMC  GC_GraphBarsRealArray_L5
 DBG 
#srcline 2419 ;      //GC_SaveWord(REAL_TO_INT(stepY * (LIMIT( minY, pStart^, maxY) - zero)), GrData);
#srcline 2420 ;      pInt^  := REAL_TO_INT(stepY * (LIMIT( minY, pStart^, maxY) - zero));
 LDY  stepY
#debug real stepY
 LEAY pStart
 LDIL    ; dereference 
 LDIL 
#debug real pStart^
 LDX  minY
#debug real minY
 MAXF
 LDX  maxY
#debug real maxY
 MINF
 LDY  zero
#debug real zero
 SUF
 MUF
 RND
 IFW
 EXTW
 LEAY pInt
 LDIL    ; dereference 
 WRIW 
#debug_left int pInt^
#srcline 2421 ;      pInt   := pInt + SIZEOF(INT);
 LEAY pInt
 LDIL 
#debug pointer pInt
 LD   __sizeof(int)  ; SizeOf()
 ADD
 LEAY pInt
 WRIL 
#debug_left pointer pInt
#srcline 2422 ;      pStart := pStart + SIZEOF(REAL);
 LEAY pStart
 LDIL 
#debug pointer pStart
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStart
 WRIL 
#debug_left pointer pStart
#srcline 2423 ;    END_WHILE;
 JMP  GC_GraphBarsRealArray_L4
GC_GraphBarsRealArray_L5:
#srcline 2425 ;    GC_Move(0, zeroline, GrData); //vratit pero zpet
 NXT
 LD   int 0
 WR   __Instance__GC_Move~x
#debug_left int __Instance__GC_Move~x
 LDY  zeroline
#debug int zeroline
 EXTW 
 WR   __Instance__GC_Move~y
#debug_left int __Instance__GC_Move~y
 LDX  GrData
 WR   __Instance__GC_Move~GrData
#debug_left pointer __Instance__GC_Move.GrData
 PRV
 LEA  __Instance__GC_Move
 CAL  GC_Move_L0
#srcline 2426 ;  //END_IF;
#srcline 2428 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_GraphBarsRealArray
 ULNK
RET
E     61
#endpou 

#pou GC_GraphBars
#srcline 2430 ;FUNCTION GC_GraphBars : BOOL (*

#struct GC_GraphBars__temp__
  udint addr,
  uint cnt
P     61
GC_GraphBars_L0:
 LINK __SizeOf(GC_GraphBars__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 2454 ;    BEGIN
#srcline 2455 ;    {ASM}
#srcline 2456
    LDX NumPoints
#srcline 2457
    MUL 2
#srcline 2458
    WRY cnt
#srcline 2459
    GC_TestSpaceMacro3(cnt, 8, GrData);
#srcline 2460
    GC_SaveFcConstLenBlockMacro(GPRIMITIVE_GRAPHBARS, params, __sizeof(int)*3+__sizeof(usint), GrData);
#srcline 2461 ;    {END_ASM}
#srcline 2462 ;  (** )
#srcline 2463 ;  IF GC_TestSpace( 8 + INT_TO_UINT(NumPoints) * 2, GrData) THEN
#srcline 2464 ;    GC_SaveByte( GPRIMITIVE_GRAPHBARS, GrData);
#srcline 2465 ;    GC_SaveByte( Params, GrData);
#srcline 2466 ;    GC_SaveWord( Length, GrData);
#srcline 2467 ;    GC_SaveWord( BarWidth, GrData);
#srcline 2468 ;    GC_SaveWord( NumPoints, GrData);
#srcline 2469 ;  END_IF;
#srcline 2470 ; (**)
#srcline 2471 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_GraphBars
 ULNK
RET
E     61
#endpou 

#pou GC_GraphAddData
#srcline 2473 ;FUNCTION GC_GraphAddData : BOOL

#struct GC_GraphAddData__temp__
  udint addr
P     61
GC_GraphAddData_L0:
 LINK __SizeOf(GC_GraphAddData__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 2488 ;    BEGIN
#srcline 2489 ;    {ASM}
#srcline 2490
    GC_TestSpaceMacro(2, GrData);
#srcline 2491 ;    {END_ASM}
#srcline 2492 ;    GC_SaveWord( data, GrData);
 NXT
 LDX  data
#debug int data
 EXTW 
 WR   __Instance__GC_SaveWord~data
#debug_left int __Instance__GC_SaveWord~data
 LDX  GrData
 WR   __Instance__GC_SaveWord~GrData
#debug_left pointer __Instance__GC_SaveWord.GrData
 PRV
 LEA  __Instance__GC_SaveWord
 CAL  GC_SaveWord_L0
#srcline 2493 ;  //END_IF;
#srcline 2494 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_GraphAddData
 ULNK
RET
E     61
#endpou 

#pou GC_RadialScale
#srcline 2496 ;FUNCTION GC_RadialScale : BOOL

#struct GC_RadialScale__temp__
  udint addr
P     61
GC_RadialScale_L0:
 LINK __SizeOf(GC_RadialScale__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 2523 ;    BEGIN
#srcline 2524 ;    {ASM}
#srcline 2525
    GC_TestSpaceMacro(37, GrData);
#srcline 2526
    GC_SaveFcConstLenBlockMacro(GPRIMITIVE_RADIALSCALE, radius, __sizeof(int)+__sizeof(real)*2+__sizeof(int)*2+__sizeof(usint)*2+__sizeof(real)*4+__sizeof(usint)*2+__sizeof(int), GrData);
#srcline 2527 ;    {END_ASM}
#srcline 2528 ;    (** )
#srcline 2529 ;    GC_SaveByte( GPRIMITIVE_RADIALSCALE, GrData); //1
#srcline 2530 ;    GC_SaveWord(radius, GrData);                 //3  0
#srcline 2531 ;    GC_SaveAngle(sAngle, GrData);                //7  2
#srcline 2532 ;    GC_SaveAngle(eAngle, GrData);                //11 6
#srcline 2533 ;    GC_SaveWord(majorTickLen, GrData);           //13 10
#srcline 2534 ;    GC_SaveWord(minorTickLen, GrData);           //15 12
#srcline 2535 ;    GC_SaveByte(labelOffset, GrData);            //16 14
#srcline 2536 ;    GC_SaveByte(labelDec, GrData);               //17 15
#srcline 2537 ;    GC_SaveReal(sVal, GrData);                   //21 16
#srcline 2538 ;    GC_SaveReal(eVal, GrData);                   //25 20
#srcline 2539 ;    GC_SaveReal(majorStep, GrData);              //29 24
#srcline 2540 ;    GC_SaveReal(labelAt, GrData);                //33 28
#srcline 2541 ;    GC_SaveByte(labelStep, GrData);              //34 32
#srcline 2542 ;    GC_SaveByte(stepDiv, GrData);                //35 33
#srcline 2543 ;    GC_SaveWord(params, GrData);                 //37 34
#srcline 2544 ;    (**)
#srcline 2545 ;  //END_IF;
#srcline 2546 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_RadialScale
 ULNK
RET
E     61
#endpou 

#pou GC_LinearScale
#srcline 2548 ;FUNCTION GC_LinearScale : BOOL

#struct GC_LinearScale__temp__
  udint addr
P     61
GC_LinearScale_L0:
 LINK __SizeOf(GC_LinearScale__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 2576 ;    BEGIN
#srcline 2577 ;    {ASM}
#srcline 2578
    GC_TestSpaceMacro(31, GrData);
#srcline 2579
    GC_SaveFcConstLenBlockMacro(GPRIMITIVE_LINEARSCALE, length, __sizeof(int)*4+__sizeof(usint)*2+__sizeof(real)*4+__sizeof(usint)*2+__sizeof(int), GrData);
#srcline 2580 ;    {END_ASM}
#srcline 2581 ;    (** )
#srcline 2582 ;    GC_SaveByte( GPRIMITIVE_LINEARSCALE, GrData); //1
#srcline 2583 ;    GC_SaveWord(length, GrData);                 //3  0
#srcline 2584 ;    GC_SaveWord(majorTickLen, GrData);           //5  2
#srcline 2585 ;    GC_SaveWord(minorTickLen, GrData);           //7  4
#srcline 2586 ;    GC_SaveWord(gridLength, GrData);             //9  6
#srcline 2587 ;    GC_SaveByte(labelOffset, GrData);            //10 8
#srcline 2588 ;    GC_SaveByte(labelDec, GrData);               //11 9
#srcline 2589 ;    GC_SaveReal(sVal, GrData);                   //14 10
#srcline 2590 ;    GC_SaveReal(eVal, GrData);                   //19 14
#srcline 2591 ;    GC_SaveReal(majorStep, GrData);              //23 18
#srcline 2592 ;    GC_SaveReal(labelAt, GrData);                //27 22
#srcline 2593 ;    GC_SaveByte(labelStep, GrData);              //28 26
#srcline 2594 ;    GC_SaveByte(stepDiv, GrData);                //29 27
#srcline 2595 ;    GC_SaveWord(params, GrData);                 //31 28
#srcline 2596 ;    (**)
#srcline 2597 ;  //END_IF;
#srcline 2599 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_LinearScale
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\CANVASLIB\CANVASLIB\COLOROPERATIONS.ST'
#pou RGBA_TO_Color
#srcline 3 ;FUNCTION RGBA_TO_Color : UDINT
P     61
RGBA_TO_Color_L0:
 LINK 0
 NXT
#srcline 16 ;  RGBA_TO_Color := DWORD_TO_UDINT(SHL(SHL(SHL(USINT_TO_DWORD(A),8) OR USINT_TO_DWORD(B),8) OR USINT_TO_DWORD(G),8) OR USINT_TO_DWORD(R));
 LDX  A
#debug usint A
 LD   uint 8
 SHL
 LDX  B
#debug usint B
 OR  
 LD   uint 8
 SHL
 LDX  G
#debug usint G
 OR  
 LD   uint 8
 SHL
 LDX  R
#debug usint R
 OR  
 WRX  __fc__RGBA_TO_Color
#debug_left udint RGBA_TO_Color
#srcline 17 ;END_FUNCTION
 PRV  
 LDX  __fc__RGBA_TO_Color
 ULNK
RET
E     61
#endpou 

#pou Color_TO_RGBA
#srcline 19 ;FUNCTION Color_TO_RGBA : bool
P     61
Color_TO_RGBA_L0:
 LINK 0
 NXT
#srcline 44 ;  R := UDINT_TO_USINT(color);
 LDX  color
#debug udint color
 AND  $FF
 LDX  R
 WRI 
#debug_left usint R
#srcline 45 ;  G := DWORD_TO_USINT(SHR(UDINT_TO_DWORD(color),8));
 LDX  color
#debug udint color
 LD   uint 8
 SHR
 AND  $FF
 LDX  G
 WRI 
#debug_left usint G
#srcline 46 ;  B := DWORD_TO_USINT(SHR(UDINT_TO_DWORD(color),16));
 LDX  color
#debug udint color
 LD   uint 16
 SHR
 AND  $FF
 LDX  B
 WRI 
#debug_left usint B
#srcline 47 ;  A := DWORD_TO_USINT(SHR(UDINT_TO_DWORD(color),24));
 LDX  color
#debug udint color
 LD   uint 24
 SHR
 AND  $FF
 LDX  A
 WRI 
#debug_left usint A
#srcline 48 ;  
#srcline 49 ;END_FUNCTION
 PRV  
 LDX  __fc__Color_TO_RGBA
 ULNK
RET
E     61
#endpou 

#pou Alpha_TO_Color
#srcline 51 ;FUNCTION Alpha_TO_Color : UDINT
P     61
Alpha_TO_Color_L0:
 LINK 0
 NXT
#srcline 68 ;  Alpha_TO_Color := DWORD_TO_UDINT(UDINT_TO_DWORD(color) and 16#00FFFFFF or SHL(IN := USINT_TO_DWORD(alpha), N := 24));
 LDX  color
#debug udint color
 LD   dword $00FFFFFF
 AND
 LDX  alpha
#debug usint alpha
 LD   uint 24
 SHL
 OR  
 WRX  __fc__Alpha_TO_Color
#debug_left udint Alpha_TO_Color
#srcline 69 ;  
#srcline 70 ;END_FUNCTION
 PRV  
 LDX  __fc__Alpha_TO_Color
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\CANVASLIB\CANVASLIB\GC_POLYGONREALARRAY.ST'
#pou GC_GraphPolygonRealArray
#srcline 1 ;FUNCTION GC_GraphPolygonRealArray : BOOL

#struct GC_GraphPolygonRealArray__temp__
  real stepX,
  real stepY,
  real zeroX,
  int zerolineX,
  real zeroY,
  int zerolineY,
  pointer pStartX,
  pointer pEndX,
  pointer pStartY,
  pointer pInt,
  pointer pUsint,
  real lastX,
  real lastY,
  usint lnumPts
P     61
GC_GraphPolygonRealArray_L0:
 LINK __SizeOf(GC_GraphPolygonRealArray__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__GC_GraphPolygonRealArray
 WRX  a
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pStartX
 LD   udint $FFFFFFFF    ; nil
 WRY  pEndX
 LD   udint $FFFFFFFF    ; nil
 WRY  pStartY
 LD   udint $FFFFFFFF    ; nil
 WRY  pInt
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint
; End initialize - dynamic variables
#srcline 42 ;  stepX := (INT_TO_REAL(length)/(maxX - minX)); //meritko
 LDX  length
#debug int length
 EXTW 
 ILF
 LDX  maxX
#debug real maxX
 LDX  minX
#debug real minX
 SUF
 DIF
 WRY  stepX
#debug_left real stepX
#srcline 43 ;  stepY := -(INT_TO_REAL(height)/(maxY - minY)); //meritko
 LDX  height
#debug int height
 EXTW 
 ILF
 LDX  maxY
#debug real maxY
 LDX  minY
#debug real minY
 SUF
 DIF
 XOR  $80000000
 WRY  stepY
#debug_left real stepY
#srcline 45 ;  //urceni zda nula lezi v grafu
#srcline 46 ;  (*
#srcline 47 ;  IF minY > 0.0 THEN
#srcline 48 ;    zero := minY;
#srcline 49 ;  ELSIF maxY < 0.0 THEN
#srcline 50 ;    zero := maxY;
#srcline 51 ;  ELSE
#srcline 52 ;    zero := 0.0;
#srcline 53 ;  END_IF;
#srcline 54 ;  *)
#srcline 55 ;  zeroX := LIMIT(minX, 0.0, maxX);
 LD   real 0.0
 LDX  minX
#debug real minX
 MAXF
 LDX  maxX
#debug real maxX
 MINF
 WRY  zeroX
#debug_left real zeroX
#srcline 56 ;  zeroLineX := REAL_TO_INT(stepX * (zeroX - minX));
 LDY  stepX
#debug real stepX
 LDY  zeroX
#debug real zeroX
 LDX  minX
#debug real minX
 SUF
 MUF
 RND
 IFW
 EXTW
 WRY  zeroLineX
#debug_left int zeroLineX
#srcline 57 ;  zeroY := LIMIT(minY, 0.0, maxY);
 LD   real 0.0
 LDX  minY
#debug real minY
 MAXF
 LDX  maxY
#debug real maxY
 MINF
 WRY  zeroY
#debug_left real zeroY
#srcline 58 ;  zeroLineY := REAL_TO_INT(stepY * (zeroY - minY));
 LDY  stepY
#debug real stepY
 LDY  zeroY
#debug real zeroY
 LDX  minY
#debug real minY
 SUF
 MUF
 RND
 IFW
 EXTW
 WRY  zeroLineY
#debug_left int zeroLineY
#srcline 59 ;  
#srcline 60 ;  GC_Move(zerolineX, zerolineY, GrData); //posunout pero na nulu
 NXT
 LDY  zerolineX
#debug int zerolineX
 EXTW 
 WR   __Instance__GC_Move~x
#debug_left int __Instance__GC_Move~x
 LDY  zerolineY
#debug int zerolineY
 EXTW 
 WR   __Instance__GC_Move~y
#debug_left int __Instance__GC_Move~y
 LDX  GrData
 WR   __Instance__GC_Move~GrData
#debug_left pointer __Instance__GC_Move.GrData
 PRV
 LEA  __Instance__GC_Move
 CAL  GC_Move_L0
#srcline 62 ;  IF GC_TestSpace( 2 + USINT_TO_UINT(NumPoints+2) * 4, GrData) THEN //tady se zbytecne kontroluje na plny pocet bodu
 NXT
 LD   uint 2
 LDX  NumPoints
#debug usint NumPoints
 LD   usint 2
 ADD
 AND  $FF
 AND  $FFFF
 LD   uint 4
 MUL
 AND  $FFFF
 ADD
 AND  $FFFF
 WR   __Instance__GC_TestSpace~rqLen
#debug_left uint __Instance__GC_TestSpace~rqLen
 LDX  GrData
 WR   __Instance__GC_TestSpace~GrData
#debug_left pointer __Instance__GC_TestSpace.GrData
 PRV
 LEA  __Instance__GC_TestSpace
 CAL  GC_TestSpace_L0
 JMC  GC_GraphPolygonRealArray_L1
#srcline 63 ;  (*
#srcline 64 ;    {ASM}
#srcline 65 ;    LDX NumPoints
#srcline 66 ;    MUL 4
#srcline 67 ;    ADD 2
#srcline 68 ;    WRY cnt
#srcline 69 ;    GC_TestSpaceMacro2(cnt, GrData);
#srcline 70 ;    {END_ASM}
#srcline 72 ;  *)
#srcline 73 ;    
#srcline 75 ;    pStartX := ADR(pointsX);
 LDX  pointsX
#debug pointer pointsX
 LEAY pStartX
 WRIL 
#debug_left pointer pStartX
#srcline 76 ;    pEndX := pStartX + USINT_TO_UDINT(numPoints)*SIZEOF(REAL);
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LDX  numPoints
#debug usint numPoints
 LD   __sizeof(real)  ; SizeOf()
 MUL
 ADD
 LEAY pEndX
 WRIL 
#debug_left pointer pEndX
#srcline 77 ;    pStartY := ADR(pointsY);
 LDX  pointsY
#debug pointer pointsY
 LEAY pStartY
 WRIL 
#debug_left pointer pStartY
#srcline 80 ;    WHILE PTR_TO_UDINT(pStartX) < PTR_TO_UDINT(pEndX) DO
GC_GraphPolygonRealArray_L3:
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LEAY pEndX
 LDIL 
#debug pointer pEndX
 LT
 JMC  GC_GraphPolygonRealArray_L4
 DBG 
#srcline 81 ;      IF minX > pStartX^ THEN     //bod mimo
 LDX  minX
#debug real minX
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 GTF
 JMC  GC_GraphPolygonRealArray_L5
#srcline 82 ;        lastX := pStartX^;        //zapamatovat
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 WRY  lastX
#debug_left real lastX
#srcline 83 ;        lastY := pStartY^;
 LEAY pStartY
 LDIL    ; dereference 
 LDIL 
#debug real pStartY^
 WRY  lastY
#debug_left real lastY
#srcline 84 ;        pStartX := pStartX + SIZEOF(REAL);
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartX
 WRIL 
#debug_left pointer pStartX
#srcline 85 ;        pStartY := pStartY + SIZEOF(REAL);
 LEAY pStartY
 LDIL 
#debug pointer pStartY
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartY
 WRIL 
#debug_left pointer pStartY
#srcline 86 ;      ELSE //bod uvnitr
 JMP  GC_GraphPolygonRealArray_L6
GC_GraphPolygonRealArray_L5:
#srcline 87 ;        IF PTR_TO_UDINT(pStartX) <> PTR_TO_UDINT(ADR(pointsX)) THEN
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LDX  pointsX
#debug pointer pointsX
 EQ
 NEG
 JMC  GC_GraphPolygonRealArray_L7
#srcline 88 ;          lastY := (pStartY^ - lastY) * (minX - lastX) / (pStartX^ - lastX) + lastY;
 LEAY pStartY
 LDIL    ; dereference 
 LDIL 
#debug real pStartY^
 LDY  lastY
#debug real lastY
 SUF
 LDX  minX
#debug real minX
 LDY  lastX
#debug real lastX
 SUF
 MUF
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 LDY  lastX
#debug real lastX
 SUF
 DIF
 LDY  lastY
#debug real lastY
 ADF
 WRY  lastY
#debug_left real lastY
#srcline 89 ;          lastX := minX;
 LDX  minX
#debug real minX
 WRY  lastX
#debug_left real lastX
#srcline 90 ;        ELSE //byl to prvni bod
 JMP  GC_GraphPolygonRealArray_L8
GC_GraphPolygonRealArray_L7:
#srcline 91 ;          lastX := pStartX^;
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 WRY  lastX
#debug_left real lastX
#srcline 92 ;          lastY := pStartY^;
 LEAY pStartY
 LDIL    ; dereference 
 LDIL 
#debug real pStartY^
 WRY  lastY
#debug_left real lastY
#srcline 93 ;          pStartX := pStartX + SIZEOF(REAL);
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartX
 WRIL 
#debug_left pointer pStartX
#srcline 94 ;          pStartY := pStartY + SIZEOF(REAL);
 LEAY pStartY
 LDIL 
#debug pointer pStartY
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartY
 WRIL 
#debug_left pointer pStartY
#srcline 95 ;        END_IF;
GC_GraphPolygonRealArray_L8:
#srcline 96 ;        EXIT;
 JMP  GC_GraphPolygonRealArray_L4
#srcline 97 ;      END_IF;
GC_GraphPolygonRealArray_L6:
#srcline 98 ;    END_WHILE;
 JMP  GC_GraphPolygonRealArray_L3
GC_GraphPolygonRealArray_L4:
#srcline 100 ;    IF minX <= lastX AND lastX <= maxX THEN //osa je v rozsahu grafu
 LDX  minX
#debug real minX
 LDY  lastX
#debug real lastX
 GTF
 NEG
 LDY  lastX
#debug real lastX
 LDX  maxX
#debug real maxX
 GTF
 NEG
 AND
 JMC  GC_GraphPolygonRealArray_L9
#srcline 101 ;      IF fill THEN
 LDX  fill
#debug bool fill
 JMC  GC_GraphPolygonRealArray_L11
#srcline 102 ;        GC_SaveByte( GPRIMITIVE_CFILLPOLYGON, GrData);
 NXT
 LD   usint 47
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 103 ;      ELSE
 JMP  GC_GraphPolygonRealArray_L12
GC_GraphPolygonRealArray_L11:
#srcline 104 ;        GC_SaveByte( GPRIMITIVE_CPOLYGON, GrData);
 NXT
 LD   usint 46
 WR   __Instance__GC_SaveByte~data
#debug_left usint __Instance__GC_SaveByte~data
 LDX  GrData
 WR   __Instance__GC_SaveByte~GrData
#debug_left pointer __Instance__GC_SaveByte.GrData
 PRV
 LEA  __Instance__GC_SaveByte
 CAL  GC_SaveByte_L0
#srcline 105 ;      END_IF;
GC_GraphPolygonRealArray_L12:
#srcline 106 ;      //GC_SaveByte( NumPoints+2, GrData); // pocet bodu
#srcline 108 ;      lnumPts := 2;
 LD   usint 2
 WRY  lnumPts
#debug_left usint lnumPts
#srcline 110 ;      pUsint := ADR(GrData.buf[GrData.info.actLen]);
 LDX  GrData
 ADD  20  ; + offset 
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 RCHK 8191   ; Range Check
 ADD     ; + offset 
#debug pointer GrData.buf[GrData.info.actLen]
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 111 ;      pInt := pUsint + 1;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LD   udint 1
 ADD
 LEAY pInt
 WRIL 
#debug_left pointer pInt
#srcline 114 ;      //prvni bod na nule
#srcline 115 ;      pInt^  := REAL_TO_INT(stepX * (lastX - zeroX));
 LDY  stepX
#debug real stepX
 LDY  lastX
#debug real lastX
 LDY  zeroX
#debug real zeroX
 SUF
 MUF
 RND
 IFW
 EXTW
 LEAY pInt
 LDIL    ; dereference 
 WRIW 
#debug_left int pInt^
#srcline 116 ;      pInt   := pInt + SIZEOF(INT);
 LEAY pInt
 LDIL 
#debug pointer pInt
 LD   __sizeof(int)  ; SizeOf()
 ADD
 LEAY pInt
 WRIL 
#debug_left pointer pInt
#srcline 117 ;      pInt^  := 0;
 LD   int 0
 LEAY pInt
 LDIL    ; dereference 
 WRIW 
#debug_left int pInt^
#srcline 118 ;      pInt   := pInt + SIZEOF(INT);
 LEAY pInt
 LDIL 
#debug pointer pInt
 LD   __sizeof(int)  ; SizeOf()
 ADD
 LEAY pInt
 WRIL 
#debug_left pointer pInt
#srcline 121 ;      WHILE true DO //PTR_TO_UDINT(pStartX) <= PTR_TO_UDINT(pEndX)
GC_GraphPolygonRealArray_L13:
 LD   bool -1       ; true
 JMC  GC_GraphPolygonRealArray_L14
 DBG 
#srcline 122 ;        lnumPts := lnumPts+1;
 LDY  lnumPts
#debug usint lnumPts
 LD   usint 1
 ADD
 AND  $FF
 WRY  lnumPts
#debug_left usint lnumPts
#srcline 123 ;        pInt^  := REAL_TO_INT(stepX * (lastX - zeroX));
 LDY  stepX
#debug real stepX
 LDY  lastX
#debug real lastX
 LDY  zeroX
#debug real zeroX
 SUF
 MUF
 RND
 IFW
 EXTW
 LEAY pInt
 LDIL    ; dereference 
 WRIW 
#debug_left int pInt^
#srcline 124 ;        pInt   := pInt + SIZEOF(INT);
 LEAY pInt
 LDIL 
#debug pointer pInt
 LD   __sizeof(int)  ; SizeOf()
 ADD
 LEAY pInt
 WRIL 
#debug_left pointer pInt
#srcline 125 ;        pInt^  := REAL_TO_INT(stepY * (LIMIT( minY, lastY, maxY) - zeroY));
 LDY  stepY
#debug real stepY
 LDY  lastY
#debug real lastY
 LDX  minY
#debug real minY
 MAXF
 LDX  maxY
#debug real maxY
 MINF
 LDY  zeroY
#debug real zeroY
 SUF
 MUF
 RND
 IFW
 EXTW
 LEAY pInt
 LDIL    ; dereference 
 WRIW 
#debug_left int pInt^
#srcline 126 ;        pInt   := pInt + SIZEOF(INT);
 LEAY pInt
 LDIL 
#debug pointer pInt
 LD   __sizeof(int)  ; SizeOf()
 ADD
 LEAY pInt
 WRIL 
#debug_left pointer pInt
#srcline 127 ;        IF lastX = maxX OR PTR_TO_UDINT(pStartX) = PTR_TO_UDINT(pEndX) THEN //mimo nebo konec
 LDY  lastX
#debug real lastX
 LDX  maxX
#debug real maxX
 EQF
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LEAY pEndX
 LDIL 
#debug pointer pEndX
 EQ
 OR  
 JMC  GC_GraphPolygonRealArray_L15
#srcline 128 ;          EXIT;
 JMP  GC_GraphPolygonRealArray_L14
#srcline 129 ;        END_IF;
GC_GraphPolygonRealArray_L15:
#srcline 130 ;        
#srcline 131 ;        IF pStartX^ > maxX THEN //jsme mimo
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 LDX  maxX
#debug real maxX
 GTF
 JMC  GC_GraphPolygonRealArray_L17
#srcline 132 ;          lastY := (pStartY^ - lastY) * (maxX - lastX) / (pStartX^ - lastX) + lastY;
 LEAY pStartY
 LDIL    ; dereference 
 LDIL 
#debug real pStartY^
 LDY  lastY
#debug real lastY
 SUF
 LDX  maxX
#debug real maxX
 LDY  lastX
#debug real lastX
 SUF
 MUF
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 LDY  lastX
#debug real lastX
 SUF
 DIF
 LDY  lastY
#debug real lastY
 ADF
 WRY  lastY
#debug_left real lastY
#srcline 133 ;          lastX := maxX;
 LDX  maxX
#debug real maxX
 WRY  lastX
#debug_left real lastX
#srcline 134 ;        ELSE
 JMP  GC_GraphPolygonRealArray_L18
GC_GraphPolygonRealArray_L17:
#srcline 135 ;          lastX := pStartX^;
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 WRY  lastX
#debug_left real lastX
#srcline 136 ;          lastY := pStartY^;
 LEAY pStartY
 LDIL    ; dereference 
 LDIL 
#debug real pStartY^
 WRY  lastY
#debug_left real lastY
#srcline 137 ;          pStartX := pStartX + SIZEOF(REAL);
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartX
 WRIL 
#debug_left pointer pStartX
#srcline 138 ;          pStartY := pStartY + SIZEOF(REAL);
 LEAY pStartY
 LDIL 
#debug pointer pStartY
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartY
 WRIL 
#debug_left pointer pStartY
#srcline 139 ;        END_IF;
GC_GraphPolygonRealArray_L18:
#srcline 140 ;      END_WHILE;
 JMP  GC_GraphPolygonRealArray_L13
GC_GraphPolygonRealArray_L14:
#srcline 142 ;      pInt^  := REAL_TO_INT(stepX * (lastX - zeroX));
 LDY  stepX
#debug real stepX
 LDY  lastX
#debug real lastX
 LDY  zeroX
#debug real zeroX
 SUF
 MUF
 RND
 IFW
 EXTW
 LEAY pInt
 LDIL    ; dereference 
 WRIW 
#debug_left int pInt^
#srcline 143 ;      pInt   := pInt + SIZEOF(INT);
 LEAY pInt
 LDIL 
#debug pointer pInt
 LD   __sizeof(int)  ; SizeOf()
 ADD
 LEAY pInt
 WRIL 
#debug_left pointer pInt
#srcline 144 ;      pInt^  := 0;
 LD   int 0
 LEAY pInt
 LDIL    ; dereference 
 WRIW 
#debug_left int pInt^
#srcline 145 ;  //    pInt   := pInt + SIZEOF(INT);
#srcline 147 ;      //
#srcline 148 ;      pUsint^ := lnumPts;
 LDY  lnumPts
#debug usint lnumPts
 LEAY pUsint
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint^
#srcline 149 ;      //update len
#srcline 150 ;      GrData.info.actLen := GrData.info.actLen + USINT_TO_UINT(lnumPts)*4 + 1; //+1 je za pocet bodu
 LDX  GrData
 ADD  4  ; + offset 
 LDIW 
#debug uint GrData.info.actLen
 LDY  lnumPts
#debug usint lnumPts
 AND  $FFFF
 LD   uint 4
 MUL
 AND  $FFFF
 ADD
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 LDX  GrData
 ADD  4  ; + offset 
 WRIW 
#debug_left uint GrData.info.actLen
#srcline 151 ;    END_IF;
GC_GraphPolygonRealArray_L9:
#srcline 153 ;    GC_Move(-zerolineX, -zerolineY, GrData); //vratit pero zpet
 NXT
 LDY  zerolineX
#debug int zerolineX
 EXTW 
 CSGL 
 WR   __Instance__GC_Move~x
#debug_left int __Instance__GC_Move~x
 LDY  zerolineY
#debug int zerolineY
 EXTW 
 CSGL 
 WR   __Instance__GC_Move~y
#debug_left int __Instance__GC_Move~y
 LDX  GrData
 WR   __Instance__GC_Move~GrData
#debug_left pointer __Instance__GC_Move.GrData
 PRV
 LEA  __Instance__GC_Move
 CAL  GC_Move_L0
#srcline 155 ;    
#srcline 156 ;    //GC_SaveDwordArray(n := NumPoints, data := void(Points), GrData := GrData);
#srcline 157 ;  END_IF;
GC_GraphPolygonRealArray_L1:
#srcline 158 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_GraphPolygonRealArray
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\CANVASLIB\CANVASLIB\GC_GRAPHLINEXYREALARRAY.ST'
#pou GC_GraphLineXYRealArray
#srcline 1 ;FUNCTION GC_GraphLineXYRealArray : BOOL

#struct GC_GraphLineXYRealArray__temp__
  int x1,
  int y1,
  real stepX,
  real stepY,
  real zeroX,
  int zerolineX,
  real zeroY,
  int zerolineY,
  pointer pStartX,
  pointer pEndX,
  pointer pStartY,
  real lastX,
  real lastY,
  usint lnumPts
P     61
GC_GraphLineXYRealArray_L0:
 LINK __SizeOf(GC_GraphLineXYRealArray__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__GC_GraphLineXYRealArray
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pStartX
 LD   udint $FFFFFFFF    ; nil
 WRY  pEndX
 LD   udint $FFFFFFFF    ; nil
 WRY  pStartY
; End initialize - dynamic variables
#srcline 44 ;  stepX := (INT_TO_REAL(length)/(maxX - minX)); //meritko
 LDX  length
#debug int length
 EXTW 
 ILF
 LDX  maxX
#debug real maxX
 LDX  minX
#debug real minX
 SUF
 DIF
 WRY  stepX
#debug_left real stepX
#srcline 45 ;  stepY := -(INT_TO_REAL(height)/(maxY - minY)); //meritko
 LDX  height
#debug int height
 EXTW 
 ILF
 LDX  maxY
#debug real maxY
 LDX  minY
#debug real minY
 SUF
 DIF
 XOR  $80000000
 WRY  stepY
#debug_left real stepY
#srcline 47 ;  //urceni zda nula lezi v grafu
#srcline 48 ;  (*
#srcline 49 ;  IF minY > 0.0 THEN
#srcline 50 ;    zero := minY;
#srcline 51 ;  ELSIF maxY < 0.0 THEN
#srcline 52 ;    zero := maxY;
#srcline 53 ;  ELSE
#srcline 54 ;    zero := 0.0;
#srcline 55 ;  END_IF;
#srcline 56 ;  *)
#srcline 57 ;  zeroX := LIMIT(minX, 0.0, maxX);
 LD   real 0.0
 LDX  minX
#debug real minX
 MAXF
 LDX  maxX
#debug real maxX
 MINF
 WRY  zeroX
#debug_left real zeroX
#srcline 58 ;  zeroLineX := REAL_TO_INT(stepX * (zeroX - minX));
 LDY  stepX
#debug real stepX
 LDY  zeroX
#debug real zeroX
 LDX  minX
#debug real minX
 SUF
 MUF
 RND
 IFW
 EXTW
 WRY  zeroLineX
#debug_left int zeroLineX
#srcline 59 ;  zeroY := LIMIT(minY, 0.0, maxY);
 LD   real 0.0
 LDX  minY
#debug real minY
 MAXF
 LDX  maxY
#debug real maxY
 MINF
 WRY  zeroY
#debug_left real zeroY
#srcline 60 ;  zeroLineY := REAL_TO_INT(stepY * (zeroY - minY));
 LDY  stepY
#debug real stepY
 LDY  zeroY
#debug real zeroY
 LDX  minY
#debug real minY
 SUF
 MUF
 RND
 IFW
 EXTW
 WRY  zeroLineY
#debug_left int zeroLineY
#srcline 62 ;  x1 := x + zerolineX; y1 := y + zerolineY;
 LDX  x
#debug int x
 EXTW 
 LDY  zerolineX
#debug int zerolineX
 EXTW 
 ADD
 EXTW
 WRY  x1
#debug_left int x1
 LDX  y
#debug int y
 EXTW 
 LDY  zerolineY
#debug int zerolineY
 EXTW 
 ADD
 EXTW
 WRY  y1
#debug_left int y1
#srcline 63 ;  //GC_MoveTo(zerolineX+x1, zerolineY+y1, GrData); //posunout pero na nulu
#srcline 65 ;  pStartX := ADR(pointsX);
 LDX  pointsX
#debug pointer pointsX
 LEAY pStartX
 WRIL 
#debug_left pointer pStartX
#srcline 66 ;  pEndX := pStartX + USINT_TO_UDINT(numPoints)*SIZEOF(REAL);
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LDX  numPoints
#debug usint numPoints
 LD   __sizeof(real)  ; SizeOf()
 MUL
 ADD
 LEAY pEndX
 WRIL 
#debug_left pointer pEndX
#srcline 67 ;  pStartY := ADR(pointsY);
 LDX  pointsY
#debug pointer pointsY
 LEAY pStartY
 WRIL 
#debug_left pointer pStartY
#srcline 70 ;  WHILE PTR_TO_UDINT(pStartX) < PTR_TO_UDINT(pEndX) DO
GC_GraphLineXYRealArray_L1:
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LEAY pEndX
 LDIL 
#debug pointer pEndX
 LT
 JMC  GC_GraphLineXYRealArray_L2
 DBG 
#srcline 71 ;    IF minX > pStartX^ THEN     //bod mimo
 LDX  minX
#debug real minX
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 GTF
 JMC  GC_GraphLineXYRealArray_L3
#srcline 72 ;      lastX := pStartX^;        //zapamatovat
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 WRY  lastX
#debug_left real lastX
#srcline 73 ;      lastY := pStartY^;
 LEAY pStartY
 LDIL    ; dereference 
 LDIL 
#debug real pStartY^
 WRY  lastY
#debug_left real lastY
#srcline 74 ;      pStartX := pStartX + SIZEOF(REAL);
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartX
 WRIL 
#debug_left pointer pStartX
#srcline 75 ;      pStartY := pStartY + SIZEOF(REAL);
 LEAY pStartY
 LDIL 
#debug pointer pStartY
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartY
 WRIL 
#debug_left pointer pStartY
#srcline 76 ;    ELSE //bod uvnitr
 JMP  GC_GraphLineXYRealArray_L4
GC_GraphLineXYRealArray_L3:
#srcline 77 ;      IF PTR_TO_UDINT(pStartX) <> PTR_TO_UDINT(ADR(pointsX)) THEN
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LDX  pointsX
#debug pointer pointsX
 EQ
 NEG
 JMC  GC_GraphLineXYRealArray_L5
#srcline 78 ;        lastY := (pStartY^ - lastY) * (minX - lastX) / (pStartX^ - lastX) + lastY;
 LEAY pStartY
 LDIL    ; dereference 
 LDIL 
#debug real pStartY^
 LDY  lastY
#debug real lastY
 SUF
 LDX  minX
#debug real minX
 LDY  lastX
#debug real lastX
 SUF
 MUF
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 LDY  lastX
#debug real lastX
 SUF
 DIF
 LDY  lastY
#debug real lastY
 ADF
 WRY  lastY
#debug_left real lastY
#srcline 79 ;        lastX := minX;
 LDX  minX
#debug real minX
 WRY  lastX
#debug_left real lastX
#srcline 80 ;      ELSE //byl to prvni bod
 JMP  GC_GraphLineXYRealArray_L6
GC_GraphLineXYRealArray_L5:
#srcline 81 ;        lastX := pStartX^;
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 WRY  lastX
#debug_left real lastX
#srcline 82 ;        lastY := pStartY^;
 LEAY pStartY
 LDIL    ; dereference 
 LDIL 
#debug real pStartY^
 WRY  lastY
#debug_left real lastY
#srcline 83 ;        pStartX := pStartX + SIZEOF(REAL);
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartX
 WRIL 
#debug_left pointer pStartX
#srcline 84 ;        pStartY := pStartY + SIZEOF(REAL);
 LEAY pStartY
 LDIL 
#debug pointer pStartY
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartY
 WRIL 
#debug_left pointer pStartY
#srcline 85 ;      END_IF;
GC_GraphLineXYRealArray_L6:
#srcline 86 ;      EXIT;
 JMP  GC_GraphLineXYRealArray_L2
#srcline 87 ;    END_IF;
GC_GraphLineXYRealArray_L4:
#srcline 88 ;  END_WHILE;
 JMP  GC_GraphLineXYRealArray_L1
GC_GraphLineXYRealArray_L2:
#srcline 90 ;  IF minX <= lastX AND lastX <= maxX THEN //osa je v rozsahu grafu
 LDX  minX
#debug real minX
 LDY  lastX
#debug real lastX
 GTF
 NEG
 LDY  lastX
#debug real lastX
 LDX  maxX
#debug real maxX
 GTF
 NEG
 AND
 JMC  GC_GraphLineXYRealArray_L7
#srcline 92 ;     WHILE true DO //PTR_TO_UDINT(pStartX) <= PTR_TO_UDINT(pEndX)
GC_GraphLineXYRealArray_L9:
 LD   bool -1       ; true
 JMC  GC_GraphLineXYRealArray_L10
 DBG 
#srcline 95 ;      IF lnumPts > 0 THEN
 LDY  lnumPts
#debug usint lnumPts
 LD   usint 0
 GT
 JMC  GC_GraphLineXYRealArray_L11
#srcline 96 ;        GC_LineTo(x := REAL_TO_INT(stepX * (lastX - zeroX))+x1, y := REAL_TO_INT(stepY * (LIMIT( minY, lastY, maxY) - zeroY))+y1, GrData := GrData);
 NXT
 LDY  stepX
#debug real stepX
 LDY  lastX
#debug real lastX
 LDY  zeroX
#debug real zeroX
 SUF
 MUF
 RND
 IFW
 EXTW
 LDY  x1
#debug int x1
 EXTW 
 ADD
 EXTW
 WR   __Instance__GC_LineTo~x
#debug_left int __Instance__GC_LineTo~x
 LDY  stepY
#debug real stepY
 LDY  lastY
#debug real lastY
 LDX  minY
#debug real minY
 MAXF
 LDX  maxY
#debug real maxY
 MINF
 LDY  zeroY
#debug real zeroY
 SUF
 MUF
 RND
 IFW
 EXTW
 LDY  y1
#debug int y1
 EXTW 
 ADD
 EXTW
 WR   __Instance__GC_LineTo~y
#debug_left int __Instance__GC_LineTo~y
 LDX  GrData
 WR   __Instance__GC_LineTo~GrData
#debug_left pointer __Instance__GC_LineTo.GrData
 PRV
 LEA  __Instance__GC_LineTo
 CAL  GC_LineTo_L0
#srcline 97 ;      ELSE
 JMP  GC_GraphLineXYRealArray_L12
GC_GraphLineXYRealArray_L11:
#srcline 98 ;        GC_MoveTo(x := REAL_TO_INT(stepX * (lastX - zeroX))+x1, y := REAL_TO_INT(stepY * (LIMIT( minY, lastY, maxY) - zeroY))+y1, GrData := GrData);
 NXT
 LDY  stepX
#debug real stepX
 LDY  lastX
#debug real lastX
 LDY  zeroX
#debug real zeroX
 SUF
 MUF
 RND
 IFW
 EXTW
 LDY  x1
#debug int x1
 EXTW 
 ADD
 EXTW
 WR   __Instance__GC_MoveTo~x
#debug_left int __Instance__GC_MoveTo~x
 LDY  stepY
#debug real stepY
 LDY  lastY
#debug real lastY
 LDX  minY
#debug real minY
 MAXF
 LDX  maxY
#debug real maxY
 MINF
 LDY  zeroY
#debug real zeroY
 SUF
 MUF
 RND
 IFW
 EXTW
 LDY  y1
#debug int y1
 EXTW 
 ADD
 EXTW
 WR   __Instance__GC_MoveTo~y
#debug_left int __Instance__GC_MoveTo~y
 LDX  GrData
 WR   __Instance__GC_MoveTo~GrData
#debug_left pointer __Instance__GC_MoveTo.GrData
 PRV
 LEA  __Instance__GC_MoveTo
 CAL  GC_MoveTo_L0
#srcline 99 ;      END_IF;
GC_GraphLineXYRealArray_L12:
#srcline 101 ;      lnumPts := lnumPts+1;
 LDY  lnumPts
#debug usint lnumPts
 LD   usint 1
 ADD
 AND  $FF
 WRY  lnumPts
#debug_left usint lnumPts
#srcline 103 ;      IF lastX = maxX OR PTR_TO_UDINT(pStartX) = PTR_TO_UDINT(pEndX) THEN //mimo nebo konec
 LDY  lastX
#debug real lastX
 LDX  maxX
#debug real maxX
 EQF
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LEAY pEndX
 LDIL 
#debug pointer pEndX
 EQ
 OR  
 JMC  GC_GraphLineXYRealArray_L13
#srcline 104 ;        EXIT;
 JMP  GC_GraphLineXYRealArray_L10
#srcline 105 ;      END_IF;
GC_GraphLineXYRealArray_L13:
#srcline 107 ;      IF pStartX^ > maxX THEN //jsme mimo
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 LDX  maxX
#debug real maxX
 GTF
 JMC  GC_GraphLineXYRealArray_L15
#srcline 108 ;        lastY := (pStartY^ - lastY) * (maxX - lastX) / (pStartX^ - lastX) + lastY;
 LEAY pStartY
 LDIL    ; dereference 
 LDIL 
#debug real pStartY^
 LDY  lastY
#debug real lastY
 SUF
 LDX  maxX
#debug real maxX
 LDY  lastX
#debug real lastX
 SUF
 MUF
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 LDY  lastX
#debug real lastX
 SUF
 DIF
 LDY  lastY
#debug real lastY
 ADF
 WRY  lastY
#debug_left real lastY
#srcline 109 ;        lastX := maxX;
 LDX  maxX
#debug real maxX
 WRY  lastX
#debug_left real lastX
#srcline 110 ;      ELSE
 JMP  GC_GraphLineXYRealArray_L16
GC_GraphLineXYRealArray_L15:
#srcline 111 ;        lastX := pStartX^;
 LEAY pStartX
 LDIL    ; dereference 
 LDIL 
#debug real pStartX^
 WRY  lastX
#debug_left real lastX
#srcline 112 ;        lastY := pStartY^;
 LEAY pStartY
 LDIL    ; dereference 
 LDIL 
#debug real pStartY^
 WRY  lastY
#debug_left real lastY
#srcline 113 ;        pStartX := pStartX + SIZEOF(REAL);
 LEAY pStartX
 LDIL 
#debug pointer pStartX
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartX
 WRIL 
#debug_left pointer pStartX
#srcline 114 ;        pStartY := pStartY + SIZEOF(REAL);
 LEAY pStartY
 LDIL 
#debug pointer pStartY
 LD   __sizeof(real)  ; SizeOf()
 ADD
 LEAY pStartY
 WRIL 
#debug_left pointer pStartY
#srcline 115 ;      END_IF;
GC_GraphLineXYRealArray_L16:
#srcline 116 ;    END_WHILE;
 JMP  GC_GraphLineXYRealArray_L9
GC_GraphLineXYRealArray_L10:
#srcline 118 ;    GC_MoveTo(x, y, GrData); //posunout pero na nulu
 NXT
 LDX  x
#debug int x
 EXTW 
 WR   __Instance__GC_MoveTo~x
#debug_left int __Instance__GC_MoveTo~x
 LDX  y
#debug int y
 EXTW 
 WR   __Instance__GC_MoveTo~y
#debug_left int __Instance__GC_MoveTo~y
 LDX  GrData
 WR   __Instance__GC_MoveTo~GrData
#debug_left pointer __Instance__GC_MoveTo.GrData
 PRV
 LEA  __Instance__GC_MoveTo
 CAL  GC_MoveTo_L0
#srcline 120 ;  END_IF;
GC_GraphLineXYRealArray_L7:
#srcline 121 ;END_FUNCTION
 PRV  
 LDX  __fc__GC_GraphLineXYRealArray
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
$¬ G  ^