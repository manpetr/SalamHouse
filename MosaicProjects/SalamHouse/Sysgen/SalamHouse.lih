{LIBFILE="LOCALLIB\STDLIB_V21_20140514.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : C:\TecoLib\StdLib_V21_20140514.mlb *)
(* Knihovna : StdLib 2.1 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c) 2006-2010 Teco a.s. *)
(* Verze IEC pøekladaèe : 3.8.20.0 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : StdLib 2.1  }
(* Historie: *)
(*
v1.0 30.06.2004 Nem  Uvodni verze knihovny
                     Bloky : R_TRIG, F_TRIG, SR, RS, TON, TOF, CTU, CTD, TP
v1.1 09.08.2004	Nem  Oprava bloku TOF
v1.2 06.09.2004	Nem  Upraveny komentare funkcnich bloku v knihovne
v1.3 16.05.2005	Nem  Osetren stav casovacu TON/TOF/TP po restartu
                     v pripade, ze jsou casovace cele v rem zone
v1.4            Nem  vynechana
v1.5 01.11.2005	Nem  Upraveny casovace TON/TOF/TP tak, aby skutecne 
                     fungovaly rem zone i pri teplem restartu
                     Funkcni bloky R_TRIG, F_TRIG, SR a RS prepsany do asm
v1.6 07.11.2005	Nem  Doplneny funkce ADD_TIME, SUB_TIME, ADD_TOD_TIME, 
                     ADD_DT_TIME, SUB_DATE_DATE, SUB_TOD_TIME, SUB_TOD_TOD, 
                     SUB_DT_TIME, SUB_DT_DT a CONCAT_DATE_TOD
v1.7 17.03.2006	Nem  Oprava masky u TON/TOF/PT
                     Oprava funkce SUB_DT_DT
v1.8 04.04.2006	Nem  Zkraceny komentare u TON, .... kvuli FBD
v1.9 29.09.2008	Nem  Opraven funkcni blok TOF po zapnuti (casovac cely prepracovan)
v2.0 25.02.2009	Nem  Do funkcniho bloku TP doplnena kontrola predvolby
                     (je-li predvolba nula, casovac negeneruje zadny pulz)
     19.05.2010	Nem  Doplneny komentare v cestine (pro Mosaic od v2.0.23)
     27.10.2010 Nem  Doplnena historie verzi v anglictine
v2.1 14.05.2014	Nem  Ve funkcnim bloku TP se trvale vyhodnocuje nabezna
                     hrana na vstupu IN
*)

(*----------------------------------------------------------------------------*)

__DECL FUNCTION_BLOCK R_TRIG
(*Blok pro vyhodnocení nábìné hrany*)
  VAR_INPUT
    CLK              : bool;
  END_VAR
  VAR_OUTPUT
    Q                : bool;
  END_VAR
  VAR
    M                : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK F_TRIG
(*Blok pro vyhodnocení sestupné hrany*)
  VAR_INPUT
    CLK              : bool;
  END_VAR
  VAR_OUTPUT
    Q                : bool;
  END_VAR
  VAR
    M                : bool :=  TRUE;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK SR
(*RS klopnı obvod (s dominantní funkcí Set)*)
  VAR_INPUT
    S1               : bool;
    R                : bool;
  END_VAR
  VAR_OUTPUT
    Q1               : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK RS
(*RS klopnı obvod (s dominantní funkcí Reset)*)
  VAR_INPUT
    S                : bool;
    R1               : bool;
  END_VAR
  VAR_OUTPUT
    Q1               : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK CTU
(*Èítac nahoru*)
  VAR_INPUT
    CU               : bool R_EDGE;  (*vstup pro èítání nahoru*)
    R                : bool;  (*reset èítaèe*)
    PV               : int;  (*pøedvolba èítaèe*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*vıstup èítaèe*)
    CV               : int;  (*hodnota èítaèe*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK CTD
(*Èítac dolù*)
  VAR_INPUT
    CD               : bool R_EDGE;  (*vstup pro èítání dolù*)
    LD               : bool;  (*vstup pro nastavení pøedvolby*)
    PV               : int;  (*pøedvolba èítaèe*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*vıstup èítaèe*)
    CV               : int;  (*hodnota èítaèe*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK CTUD
(*Obousmìrnı èítac*)
  VAR_INPUT
    CU               : bool R_EDGE;  (*vstup pro èítání nahoru*)
    CD               : bool R_EDGE;  (*vstup pro èítání dolù*)
    R                : bool;  (*reset èítaèe*)
    LD               : bool;  (*vstup pro nastavení pøedvolby*)
    PV               : int;  (*pøedvolba èítaèe*)
  END_VAR
  VAR_OUTPUT
    QU               : bool;  (*vıstup èítaèe nahoru*)
    QD               : bool;  (*vıstup èítaèe dolù*)
    CV               : int;  (*hodnota èítaèe*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK TON
(*Èasovaè TON (zpodìní nábìné hrany)*)
  VAR_INPUT
    IN               : bool;  (*vstup èasovaèe*)
    PT               : time;  (*pøedvolba èasovaèe*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*vıstup èasovaèe*)
    ET               : time;  (*aktuální hodnota èasovaèe*)
  END_VAR
  VAR
    IN_r_edge        : R_TRIG;
    LT               : time;  (*last tick value ( 1ms resolution)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK TOF
(*Èasovaè TOF (zpodìní sestupné hrany)*)
  VAR_INPUT
    IN               : bool;  (*vstup èasovaèe*)
    PT               : time;  (*pøedvolba èasovaèe*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*vıstup èasovaèe*)
    ET               : time;  (*aktuální hodnota èasovaèe*)
  END_VAR
  VAR
    IN_f_edge        : F_TRIG;
    LT               : time;  (*last tick value ( 1ms resolution)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK TP
(*Èasovaè TP (generuje pulz dané šíøky)*)
  VAR_INPUT
    IN               : bool;  (*vstup èasovaèe*)
    PT               : time;  (*pøedvolba èasovaèe*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*vıstup èasovaèe*)
    ET               : time;  (*aktuální hodnota èasovaèe*)
  END_VAR
  VAR
    IN_r_edge        : R_TRIG;
    LT               : time;  (*last tick value ( 1ms resolution)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION ADD_TIME : time
(*------------------------------------------------------------------------------
  TIME := TIME + TIME;*)
  VAR_INPUT
    IN1              : time;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_TIME : time
(*------------------------------------------------------------------------------
  TIME := TIME - TIME;*)
  VAR_INPUT
    IN1              : time;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION ADD_TOD_TIME : tod
(*------------------------------------------------------------------------------
  TIME_OF_DAY := TIME_OF_DAY + TIME;*)
  VAR_INPUT
    IN1              : tod;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION ADD_DT_TIME : dt
(*------------------------------------------------------------------------------
  DATE_AND_TIME := DATE_AND_TIME + TIME;*)
  VAR_INPUT
    IN1              : dt;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DATE_DATE : time
(*------------------------------------------------------------------------------
  TIME := DATE - DATE;*)
  VAR_INPUT
    IN1              : date;
    IN2              : date;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_TOD_TIME : tod
(*------------------------------------------------------------------------------
  TIME_OF_DAY := TIME_OF_DAY - TIME;*)
  VAR_INPUT
    IN1              : tod;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_TOD_TOD : time
(*------------------------------------------------------------------------------
  TIME := TIME_OF_DAY - TIME_OF_DAY;*)
  VAR_INPUT
    IN1              : tod;
    IN2              : tod;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DT_TIME : dt
(*------------------------------------------------------------------------------
  DATE_AND_TIME := DATE_AND_TIME - TIME;*)
  VAR_INPUT
    IN1              : dt;
    IN2              : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DT_DT : time
(*------------------------------------------------------------------------------
  TIME := DATE_AND_TIME - DATE_AND_TIME;*)
  VAR_INPUT
    IN1              : dt;
    IN2              : dt;
  END_VAR
END_FUNCTION

__DECL FUNCTION CONCAT_DATE_TOD : dt
(*------------------------------------------------------------------------------
  DATE_AND_TIME := DATE + TIME_OF_DAY;*)
  VAR_INPUT
    IN1              : date;
    IN2              : tod;
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\SYSLIB_V37_20160627.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : C:\TecoLib\SysLib_V37_20160627.mlb *)
(* Knihovna : SysLib 3.7 *)
(* Autor : Teco a.s. Kolin *)
(* Autorská práva : (c) 2004..2016 Teco a.s. *)
(* Verze IEC pøekladaèe : 3.11.8.1 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : SysLib 3.7  }
(* Historie: *)
(*
v1.0 01.09.2004 Nem úvodní verze knihovny
v1.1 16.09.2004 Nem Pøidány funkce : memcpy(),
                    SetSummerTime(), IsSummerTime(), SetWinterTime(), IsWinterTime()
v1.2 16.05.2005 Nem Pøidány funkce GetDate(), GetTime(), GetDateTime(), GetRTC(), 
                    SetRTC()
                    Zmìna deklarace systémovıch promìnnıch na strukturu
v1.3 10.11.2005 Nem Doplnìny funkce TecoDT_TO_DT() a DT_TO_TecoDT()
v1.4 17.11.2007 Nem Doplnìna funkce Memset()
v1.5 17.01.2008 Nem Doplnìna funkce IncreaseMaxCycleTime()
                    Vynechány funkce nastavení analog. kanálu.
v1.6 18.08.2008 Nem Prohozeno poøadí parametrù VAR_INPUT a VAR_IN_OUT
                    u funkcí Memset() a Memcpy() kvùli pouití v LD,
                    kde je problem s VAR_IN_OUT, pokud je prvni (na CR)
v1.7 20.02.2009 Nem Doplnìny funkce Get_IP_address() a Set_IP_address() pro Eth1
v1.8 10.03.2009 Nem Funkce Get_IP_address() nahrazena funkci GetIPaddress() a 
                    pøesunuta do ComLib
                    + sesouhlaseny parametry s funkcí GetRemoteIPaddress
                    Funkce Set_IP_address() nahrazena funkci SetIPaddress() a 
                    pøesunuta do ComLib
v1.9 22.10.2009 Nem Doplnìny funkce CIBunitInfo() a SetCIBunitAddress()
                    a datové typy TCIBunitState a TCIBunitInfo
v2.0 20.11.2009 Nem Doplnìna funkce ProgramLock()
v2.1 16.12.2009 Nem Doplnìn funkèní blok fbTick() a funkce Memcmp()
v2.2 18.01.2010 Nem Opraveno kódování CIB masteru a doplnìn kód pro mastera 0 
                    (MI0_CIB1 a MI0_CIB2)
v2.3 06.05.2010 Nem Doplnìny funkce SetWebPSW() a VerifyWebPSW()
v2.4 16.08.2010 Nem Doplnìny funkce SystemDisplayBacklightOn() a 
                    SystemDisplayBacklightOff()
v2.5 02.09.2010 Nem Doplnìny závislosti na knihovnách
     15.09.2010 Nem Funkce SetRTC vrací informaci o tom, jestli se podaøilo zapsat 
                    èas do RTC obvodu
v2.6 19.01.2011 Nem Doplnìny funkce RFunitInfo() and SetRFunitAddress()
                    Pokud je SW78 = 0 (starsi systemy) tak funkce GetDateTime()
                    a GetTime() pouzivaji S5 (desitky milisekund) jinak se pouziva 
                    SW78 (jednotky milisekund)
v2.7 30.06.2011 Nem Doplnìn funkèní blok fbBondRFunit()
v2.8 02.11.2011 Nem Doplnìny funkèní bloky memcpyEx(), memsetEx() a memcmpEx()
v2.9 02.12.2011 Nem Doplnìny funkce SetWebMAC() a VerifyWebMAC()
v3.0 27.04.2012 Nem Doplnìn funkèní blok TPR() a deklarace do struktury SystemS
v3.1 21.06.2012 Nem Blok TPR nahrazen blokem fbTPR() - vstup RESET ma prednost
                    Oprava deklarace struktury SystemS od %S57 dále
                    (doplnìny CPU_DI a CPU_DO)
v3.2 22.03.2013 Nem Doplnìn pùvodní blok TPR z verze 3.0 kvùli zpìtné kompatibilitì
                    Doplnìna funkce ProgramIsChanged()
v3.3 21.06.2013 Nem Opravena funkce ProgramIsChanged() v pøípadì on-line zmìny
                    Doplnìny funkce ReInitPLC_hotRestart(), ReInitPLC_coldRestart()
                    a ReInitPLC_noRestart() - pro Foxtrot je tøeba minimálnì FW v7.8
v3.4 03.10.2014 Nem Doplnìna funkce GetModuleID() a typ T_RGB_COLOR
v3.5 16.04.2015 Nem Doplnìna funkce MemcpyPtr()
v3.6 14.12.2015 Nem Doplnìny funkce GetVarValueByName() a SetVarValueByName()
v3.7 27.06.2016 Nem Doplnìna funkce GetVarNameByAdr()
*)

(*----------------------------------------------------------------------------*)

TYPE T_RGB_COLOR :
  STRUCT
    red              : usint;  (*red color <0..255>*)
    green            : usint;  (*green color <0..255>*)
    blue             : usint;  (*blue color <0..255>*)
    opacity          : usint;  (*opacity (0 = opaque, 255 = transparent)*)
  END_STRUCT;
END_TYPE

TYPE TSYSTEM_S :
  STRUCT
    S0               : byte;  (*flags of the results of arithmetic operations pøíznaky vısledkù aritmetickıch operací*)
    S1               : byte;  (*flags of the results of logical operations pøíznaky vısledkù logickıch operací*)
    S2_0             : bool;
    S2_1             : bool;
    S2_2             : bool;  (*PLC je v reimu RUN*)
    S2_3             : bool;  (*teplı restart PLC*)
    S2_4             : bool;  (*studenı restart PLC*)
    OUTPUTS_ARE_ENABLED : bool;  (*vystupy odblokovany*)
    S2_6             : bool;  (*prechod do run bez restartu PLC*)
    CYCLE_TIME_WARNING : bool;  (*prekrocena prva mez doby cyklu (varovani)*)
    LAST_CYCLE_TIME_10MS : usint;  (*Doba minuleho cyklu v 10 ms*)
    CYCLE_COUNTER    : usint;  (*Citac cyklu*)
    COUNTER_10MS     : usint;  (*Citac desitek milisekund*)
    COUNTER_SECONDS  : usint;  (*Citac sekund systemoveho casu*)
    COUNTER_MINUTES  : usint;  (*Citac minut systemoveho casu*)
    COUNTER_HOURS    : usint;  (*Citac hodin systemoveho casu*)
    COUNTER_DAYS_OF_WEEK : usint;  (*Citac dnu v tydnu*)
    COUNTER_DAYS_OF_MONTH : usint;  (*Citac dnu v mesici*)
    COUNTER_MONTHS   : usint;  (*Citac mesicu*)
    COUNTER_YEARS    : usint;  (*Citac roku*)
    PERIOD_PULSE_100MS : bool;  (*pulz s periodou 100 ms*)
    PERIOD_PULSE_500MS : bool;  (*pulz s periodou 500 ms*)
    PERIOD_PULSE_1SEC : bool;  (*pulz s periodou 1 s*)
    PERIOD_PULSE_10SEC : bool;  (*pulz s periodou 10 s*)
    PERIOD_PULSE_1MIN : bool;  (*pulz s periodou 1 min*)
    PERIOD_PULSE_10MIN : bool;  (*pulz s periodou 10 min*)
    PERIOD_PULSE_1HOUR : bool;  (*pulz s periodou 1 hod*)
    PERIOD_PULSE_1DAY : bool;  (*pulz s periodou 1 den*)
    COUNTER_100MS    : uint;  (*Citac v 100m*)
    COUNTER_1SEC     : uint;  (*Citac v 1s*)
    COUNTER_10SEC    : uint;  (*Citac v 10s*)
    R_EDGE_100MS     : bool;  (*nabezna hrana 1x za 100 ms*)
    R_EDGE_500MS     : bool;  (*nabezna hrana 1x za 500 ms*)
    R_EDGE_1SEC      : bool;  (*nabezna hrana 1x za 1 s*)
    R_EDGE_10SEC     : bool;  (*nabezna hrana 1x za 10 s*)
    R_EDGE_1MIN      : bool;  (*nabezna hrana 1x za 1 min*)
    R_EDGE_10MIN     : bool;  (*nabezna hrana 1x za 10 min*)
    R_EDGE_1HOUR     : bool;  (*nabezna hrana 1x za 1 hod*)
    R_EDGE_1DAY      : bool;  (*nabezna hrana 1x za 1 den*)
    F_EDGE_100MS     : bool;  (*sestupna hrana 1x za 100 ms*)
    F_EDGE_500MS     : bool;  (*sestupna hrana 1x za 500 ms*)
    F_EDGE_1SEC      : bool;  (*sestupna hrana 1x za 1 s*)
    F_EDGE_10SEC     : bool;  (*sestupna hrana 1x za 10 s*)
    F_EDGE_1MIN      : bool;  (*sestupna hrana 1x za 1 min*)
    F_EDGE_10MIN     : bool;  (*sestupna hrana 1x za 10 min*)
    F_EDGE_1HOUR     : bool;  (*sestupna hrana 1x za 1 hod*)
    F_EDGE_1DAY      : bool;  (*sestupna hrana 1x za 1 den*)
    LAST_CYCLE_TIME_100US : uint;  (*Doba minuleho cyklu v 100 µs*)
    S24              : byte;  (*øídící masky procesù*)
    S25              : byte;  (*øídící masky procesù*)
    S26              : byte;  (*øídící masky procesù*)
    S27              : byte;  (*øídící masky procesù*)
    S28              : byte;  (*øídící masky procesù*)
    S29              : byte;  (*øídící masky procesù*)
    S30              : byte;  (*rezervováno*)
    S31              : byte;  (*rezervováno*)
    S32              : byte;  (*rezervováno*)
    S33              : byte;  (*rezervováno*)
    S34              : byte;  (*hlavní kód chyby PLC*)
    BAT_ERR          : bool;  (*Chyba zalohovaci baterie*)
    S35_1            : bool;  (*rezervováno*)
    S35_2            : bool;  (*rezervováno*)
    S35_3            : bool;  (*rezervováno*)
    S35_4            : bool;  (*rezervováno*)
    S35_5            : bool;  (*rezervováno*)
    IS_SUMMER_TIME   : bool;  (*Indikace letniho casu*)
    SUMMER_TIME_REQUEST : bool;  (*Zadost o automaticky prechod na letni cas*)
    CPU_TEMPERATURE  : usint;  (*Teplota procesoroveho modulu [stupne C]*)
    S37              : byte;
    S38              : byte;
    S39              : byte;
    S40              : byte;
    S41              : byte;
    S42              : byte;
    S43              : byte;
    S44              : byte;
    S45              : byte;
    S46              : byte;
    S47              : byte;
    S48              : byte;
    S49              : byte;
    S50              : byte;
    S51              : byte;
    COUNTER_1MS      : udint;  (*Citac po 1 ms*)
    S56              : byte;
    S57              : byte;
    CPU_DI           : byte;  (*vstupy obsluhované centrální jednotkou*)
    CPU_DO           : byte;  (*vıstupy obsluhované centrální jednotkou*)
    INDEX_OF_RETAIN_ZONE : udint;  (*index prvního remanentního registru*)
    SIZE_OF_RETAIN_ZONE : udint;  (*velikost remanentní zóny (poèet bytù)*)
    INDEX_SOFT_PLC_STRUCT : uint;  (*rezervováno pro SoftPLC*)
    CRC_OF_USER_PROGRAM : word;  (*CRC uivatelského programu*)
    CRC_OF_HEADER_PROGRAM : word;  (*CRC hlavièky uivatelského programu*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL
 System_S AT %S0 : TSYSTEM_S;
 IS_HOT_RESTART_PLC AT System_S.S2_3 : bool;  (*teplı restart PLC*)
 IS_COLD_RESTART_PLC AT System_S.S2_4 : bool;  (*studenı restart PLC*)
 IS_RESTART_PLC AT System_S.S2_6 : bool;  (*prechod do run bez restartu PLC*)
 CRC_OF_APLIC_PROGRAM AT System_S.CRC_OF_USER_PROGRAM : dword;  (*CRC aplikaèního programu*)

END_VAR

TYPE TModuleInfo :
  STRUCT
    ECOM             : bool;  (*1 = chyba komunikace mezi CPU a IO modulem*)
    DATA             : bool;  (*1 = data poskytovaná modulem jsou platná*)
    DUMMY1           : bool;  (*nepouzito*)
    DUMMY2           : bool;  (*nepouzito*)
    ERR              : bool;  (*1 = chyba IO modulu*)
    DEC              : bool;  (*1 = modul má platnou deklaraci v programu PLC*)
    OTH              : bool;  (*1 = typ IO modulu neodpovídá deklaraci v programu PLC*)
    POS              : bool;  (*1 = modul je pøítomen v dané pozici*)
    STAT             : usint;  (*status modulu – vıše uvedené promìnné jako 1 byte (ECOM = STAT.0, … , POS = STAT.7)*)
  END_STRUCT;
END_TYPE

TYPE TIOSystemInfo :
  STRUCT
    err              : bool;  (*0 = IO systém PLC je bez chyby, 1 = v IO systému PLC je nìjakı problém*)
    rackNumber       : usint;  (*pøi err = 1 udává èíslo rámu PLC, kde je umístìn modul signalizující nìjakı problém*)
    position         : usint;  (*pøi err = 1 udává èíslo pozice v rámu PLC, kde je umístìn modul signalizující nìjakı problém*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 MODULE_AND_DATA_OK : usint :=  16#A2;

END_VAR

__DECL FUNCTION ModuleInfo : TModuleInfo
(*Informace o IO modulu
   Funkce vrátí informace o aktuálním stavu jednoho I/O modulu.
   Funkce je urèena pro kontrolu I/O modulù vyndavanıch za chodu*)
  VAR_INPUT
    rackNumber       : usint;  (*èíslo rámu, kde je umístìn I/O modul*)
    position         : usint;  (*èíslo pozice v rámu, kde je umístìn I/O modul*)
  END_VAR
END_FUNCTION

__DECL FUNCTION IOSystemInfo : TIOSystemInfo
(*Informace o stavu IO systému PLC

   Funkce vrátí celkovou informaci o stavu I/O systému PLC
   Funkce je urèena pro kontrolu I/O modulù vyndavanıch za chodu
   
   Pokud je v IO systému nìjakı problém
   (napø. chybí IO modul poadovanı v HW konfiguraci)
   tak vıstup err je nastaven na TRUE,
   vıstupní promìnná rackNumber udává èíslo rámu
   a promìnná position øíká pozici v rámu, na které se našel problém*)
END_FUNCTION

__DECL FUNCTION Memcpy : uint
(*Kopírovat pamì
  Funkce Memcpy zkopíruje blok pamìti ze source do dest
  Funkce vrací poèet zkopírovanıch bytù*)
  VAR_INPUT
    length           : uint;  (*Délka kopírovaného bloku v bytech*)
  END_VAR
  VAR_IN_OUT
    source           : usint;  (*Zdroj odkud kopírovat*)
    dest             : usint;  (*Cíl kam kopírovat*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MemcpyEx : uint
(*Kopírovat pamì
  Funkce Memcpy zkopíruje blok pamìti ze source+offsetSource do dest+offsetDest
  Funkce vrací poèet zkopírovanıch bytù*)
  VAR_INPUT
    length           : udint;  (*Délka kopírovaného bloku v bytech*)
    offSource        : udint;  (*Posunutí od zaèátku zdroje*)
    offDest          : udint;  (*Posunutí od zaèátku cíle*)
  END_VAR
  VAR_IN_OUT
    source           : usint;  (*Zdroj odkud kopírovat*)
    dest             : usint;  (*Cíl kam kopírovat*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MemcpyPtr : udint
(*Funkce memcpy kopíruje blok n bytù ze source do dest.
  Funkce vrací poèet zkopírovanıch bytù*)
  VAR_INPUT
    source           : PTR_TO usint;  (*pointer to source*)
    dest             : PTR_TO usint;  (*pointer to  destination*)
    length           : udint;  (*number of bytes*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Memset : bool
(*Naplnit pamì
  Funkce Memset vyplní blok pamìti zadanou hodnotou
  Funkce vrací TRUE, paklie se podaøí naplnit blok pamìti*)
  VAR_INPUT
    val              : udint;  (*Hodnota, která se zapíše do bloku pamìti*)
    length           : uint;  (*Délka bloku pamìti v bytech*)
  END_VAR
  VAR_IN_OUT
    dest             : usint;  (*Cíl, kterı bude naplnìn konstantou*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MemsetEx : bool
(*Naplnit pamì
  Funkce Memset vyplní blok pamìti zadanou hodnotou. Adresa bloku je dest+offDest.
  Funkce vrací TRUE, paklie se podaøí naplnit blok pamìti*)
  VAR_INPUT
    val              : udint;  (*Hodnota, která se zapíše do bloku pamìti*)
    length           : udint;  (*Délka bloku pamìti v bytech*)
    offDest          : udint;  (*Posunutí od zaèátku cíle*)
  END_VAR
  VAR_IN_OUT
    dest             : usint;  (*Cíl, kterı bude naplnìn konstantou*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Memcmp : bool
(*Porovnání bloku pamìti
  Funkce Memcmp porovná vzájemnì dva bloky pamìti
  Funkce vrací TRUE pokud jsou bloky pamìti shodné*)
  VAR_INPUT
    length           : uint;  (*Délka porovnávaného bloku v bytech*)
  END_VAR
  VAR_IN_OUT
    in1              : usint;  (*První porovnávanı blok*)
    in2              : usint;  (*Druhı porovnávanı blok*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MemcmpEx : bool
(*Porovnání bloku pamìti
  Funkce Memcmp porovná vzájemnì dva bloky pamìti.
  Adresy blokù jsou in1+offIn1 a in2+offIn2.
  Funkce vrací TRUE pokud jsou bloky pamìti shodné*)
  VAR_INPUT
    length           : udint;  (*Délka porovnávaného bloku v bytech*)
    offIn1           : udint;  (*Posunutí prvního porovnávaného bloku*)
    offIn2           : udint;  (*Posunutí druhého porovnávaného bloku*)
  END_VAR
  VAR_IN_OUT
    in1              : usint;  (*První porovnávanı blok*)
    in2              : usint;  (*Druhı porovnávanı blok*)
  END_VAR
END_FUNCTION

__DECL FUNCTION IncreaseMaxCycleTime : bool
(*Zvıšit èas pro dobu cyklu PLC

   Funkce zvıší jednorázovì hlídanou dobu cyklu PLC*)
  VAR_INPUT
    addTime          : uint;  (*o kolik milisekund se má zvıšit hlídaná doba cyklu*)
  END_VAR
END_FUNCTION

TYPE TTecoDateTime :
  STRUCT
    year             : usint;  (*rok     (poslední dvì èíslice letopoètu)*)
    month            : usint;  (*mìsíc   (1 .. 12)*)
    day              : usint;  (*den     (1 .. 28/29/30/31)*)
    hour             : usint;  (*hodina  (0 .. 23)*)
    min              : usint;  (*minuta  (0 .. 59)*)
    sec              : usint;  (*sekunda (0 .. 59)*)
    dayOfWeek        : usint;  (*den v tıdnu (1 = pondìlí, 7 = nedìle)*)
    milisec          : uint;  (*milisekunda*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION SetSummerTime : bool
(*Nastavit automatickı pøechod na letní èas
  Funkce nastaví poadavek na automatickı pøechod mezi letním a zimním èasem*)
END_FUNCTION

__DECL FUNCTION IsSummerTime : bool
(*Test letního èasu
  Funkce otestuje je-li aktuálnì nastaven letní èas*)
END_FUNCTION

__DECL FUNCTION SetWinterTime : bool
(*Vypnout automatickı pøechod na letní èas
  Funkce vypne poadavek na automatickı pøechod mezi letním a zimním èasem*)
END_FUNCTION

__DECL FUNCTION IsWinterTime : bool
(*Test zimního èasu
  Funkce otestuje je-li aktuálnì nastaven zimní èas*)
END_FUNCTION

__DECL FUNCTION GetDate : date
(*Naèíst aktuální datum*)
  VAR
    tmp              : TTecoDateTime;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetTime : time
(*Naèíst aktuální èas PLC*)
  VAR
    milisec          : uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetDateTime : dt
(*Naèíst aktuální datum a èas PLC*)
  VAR
    tmp              : TTecoDateTime;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetRTC : dt
(*Naèíst datum a èas pøímo z RTC obvodu v PLC*)
  VAR
    tmp              : TTecoDateTime;
  END_VAR
END_FUNCTION

__DECL FUNCTION SetRTC : bool
(*Nastavit novı èas a datum PLC
  Funkce nastaví novı datum a èas do RTC obvodu v PLC*)
  VAR_INPUT
    PDT              : dt;  (*novı datum a èas*)
  END_VAR
  VAR
    tmp              : TTecoDateTime;
  END_VAR
END_FUNCTION

__DECL FUNCTION TecoDT_TO_DT : dt
(*Pøevod datumu a èasu ze struktury TTecoDateTime do IEC formátu DATE_AND_TIME*)
  VAR_INPUT
    Teco_DT          : TTecoDateTime;  (*datum a èas*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DT_TO_TecoDT : TTecoDateTime
(*Pøevod datumu a èasu z IEC formátu DATE_AND_TIME do struktury TTecoDateTime*)
  VAR_INPUT
    IEC_DT           : dt;  (*datum a èas*)
  END_VAR
END_FUNCTION

__DECL FUNCTION memory_for_ProgramIsChanged {HIDDEN} : bool
  VAR_INPUT
    saveSL70         : bool;
    memSL70          : udint;
    memS4            : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION ProgramIsChanged : bool
(*Funkce vrací TRUE pøi restartu programu a pøi on-line zmìnì programu*)
  VAR
    saveSL70         : bool;
    memSL70          : udint;
    memS4            : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION ReInitPLC_hotRestart : bool
(*Funkce pro reinicializaci PLC
  PLC nejprve pøejde do reimu HALT a vıstupy PLC budou zablokovány.
  Provádìní programu (øízení technologie) se zastaví!
  Poté se provede teplı restart a PLC pøejde do reimu RUN.
  Bìhem pøechodu do RUN dojde ke kompletní inicializaci IO systému.
  Hodnoty RETAIN promìnnıch zùstanou zachovány,
  ostatní promìnné se nastaví na inicializaèní hodnotu*)
  VAR_INPUT
    rq               : bool;  (*1 = provést reinicializaci PLC*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ReInitPLC_coldRestart : bool
(*Funkce pro reinicializaci PLC
  PLC nejprve pøejde do reimu HALT a vıstupy PLC budou zablokovány.
  Provádìní programu (øízení technologie) se zastaví!
  Poté se provede studenı restart a PLC pøejde do reimu RUN.
  Bìhem pøechodu do RUN dojde ke kompletní inicializaci IO systému.
  Do všech promìnnıch se nastaví inicializaèní hodnoty*)
  VAR_INPUT
    rq               : bool;  (*1 = provést reinicializaci PLC*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ReInitPLC_noRestart : bool
(*Funkce pro reinicializaci PLC
  PLC nejprve pøejde do reimu HALT a vıstupy PLC budou zablokovány.
  Provádìní programu (øízení technologie) se zastaví!
  Poté PLC pøejde do reimu RUN.
  Bìhem pøechodu do RUN dojde ke kompletní inicializaci IO systému.
  Hodnoty promìnnıch zùstanou beze zmìny*)
  VAR_INPUT
    rq               : bool;  (*1 = provést reinicializaci PLC*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetModuleID : string [40]
(*Vrátí identifikacní retezec 32 a 36 znaku dle typu modulu*)
  VAR_INPUT
    rackNumber       : usint;  (*císlo rámu, kde je umísten I/O modul*)
    position         : usint;  (*císlo pozice v rámu, kde je umísten I/O modul*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetVarValueByName : string [255]
(*Vrátí hodnotu promìnné podle zadaného jména promìnné*)
  VAR_INPUT
    varName          : string [255];  (*úplné jméno promìnné (jméno instance)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetVarNameByAdr : string [255]
(*Vrátí jméno promìnné podle adresy promìnné*)
  VAR_IN_OUT
    varAdr           : byte;  (*jméno promìnné (jméno instance)*)
  END_VAR
  VAR_INPUT
    varSize          : udint;  (*velikost promìnné (poèet bytù)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetVarValueByName : bool
(*Nastaví hodnotu promìnné podle zadaného jména promìnné*)
  VAR_INPUT
    varName          : string [255];  (*úplné jméno promìnné (jméno instance)*)
    varValue         : string [255];  (*nová hodnota promìnné*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 MI_CIB1 : usint :=  1;  (*interní CIB sbìrnice systému Foxtrot*)
 MI_CIB2 : usint :=  2;
 MI0_CIB1 : usint :=  3;  (*externí CIB master, adresa 0, CIB linka 1*)
 MI0_CIB2 : usint :=  4;  (*externí CIB master, adresa 0, CIB linka 2*)
 MI2_CIB1 : usint :=  5;  (*externí CIB master, adresa 2, CIB linka 1*)
 MI2_CIB2 : usint :=  6;  (*externí CIB master, adresa 2, CIB linka 2*)
 MI4_CIB1 : usint :=  7;  (*externí CIB master, adresa 4, CIB linka 1*)
 MI4_CIB2 : usint :=  8;  (*externí CIB master, adresa 4, CIB linka 2*)
 MI6_CIB1 : usint :=  9;  (*externí CIB master, adresa 6, CIB linka 1*)
 MI6_CIB2 : usint :=  10;  (*externí CIB master, adresa 6, CIB linka 2*)
 MI_RF : usint :=  100;  (*interní RF sbìrnice systému Foxtrot*)
 RF0_RF : usint :=  101;  (*externí RF master, adresa 0*)
 RF2_RF : usint :=  102;  (*externí RF master, adresa 2*)
 RF4_RF : usint :=  103;  (*externí RF master, adresa 4*)
 RF6_RF : usint :=  104;  (*externí RF master, adresa 6*)

END_VAR

TYPE TCIBunitState :
  STRUCT
    INI              : bool;  (*CIB jednotka je inicializovaná*)
    COM              : bool;  (*komunikace s CIB jednotkou je bez závad*)
    ADDR             : bool;  (*adresa CIB jednotky byla akceptovaná*)
    DUMMY3 {HIDDEN}  : bool;
    REI              : bool;  (*pøíznak reinicializace CIB jednotky*)
    DUMMY5 {HIDDEN}  : bool;
    DUMMY6 {HIDDEN}  : bool;
    NET              : bool;  (*CIB jednotka je definovaná v programu a obsluhovaná centrální jednotkou*)
  END_STRUCT;
END_TYPE

TYPE TCIBunitInfo :
  STRUCT
    line_defined     : bool;  (*CIB linka je definovaná v HW konfiguraci PLC*)
    unit_defined     : bool;  (*CIB jednotka je definovaná v HW konfiguraci PLC*)
    state            : TCIBunitState;  (*stav CIB jednotky (viz Typ TCIBunitState)*)
    address          : word;  (*aktuálnì nastavená HW adresa CIB jednotky*)
    code             : word;  (*kód CIB jednotky*)
    unit_type        : string [17];  (*typové oznaèení CIB jednotky*)
    description      : string [31];  (*popis CIB jednotky*)
  END_STRUCT;
END_TYPE

TYPE TRFunitState :
  STRUCT
    INI              : bool;  (*RF jednotka je inicializovaná*)
    COM              : bool;  (*komunikace s RF jednotkou je bez závad*)
    DUMMY2 {HIDDEN}  : bool;
    DUMMY3 {HIDDEN}  : bool;
    DUMMY4 {HIDDEN}  : bool;
    SLP              : bool;  (*RF jednotka muze prechazet do sleep rezimu*)
    BND              : bool;  (*jednotka je spárovaná*)
    NET              : bool;  (*RF jednotka je definovaná v programu a obsluhovaná centrální jednotkou*)
  END_STRUCT;
END_TYPE

TYPE TRFunitInfo :
  STRUCT
    line_defined     : bool;  (*RF linka je definovaná v HW konfiguraci PLC*)
    unit_defined     : bool;  (*RF jednotka je definovaná v HW konfiguraci PLC*)
    state            : TRFunitState;  (*stav RF jednotky (viz Typ TRFunitState)*)
    address          : word;  (*aktuálnì nastavená HW adresa RF jednotky*)
    code             : word;  (*kód RF jednotky*)
    unit_type        : string [17];  (*typové oznaèení RF jednotky*)
    description      : string [31];  (*popis RF jednotky*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION CIBunitInfo : bool
(*Informace o stavu CIB jednotky

  Funkce získá informace o aktuálním stavu jedné jednotky na CIB sbìrnici
  Funkce vrací hodnotu TRUE, pokud se podaøí informace o CIB jednotce získat*)
  VAR_INPUT
    CIB_line         : usint;  (*èíslo CIB linky (viz konstanty MI_CIB1 a MI6_CIB2)*)
    CIB_unitID       : usint;  (*èíslo pozice CIB jednotky (1,...,32)*)
  END_VAR
  VAR_IN_OUT
    unitInfo         : TCIBunitInfo;  (*promìnná, do které jsou uloeny získané informace o CIB jednotce*)
  END_VAR
END_FUNCTION

__DECL FUNCTION RFunitInfo : bool
(*Informace o stavu RF jednotky

  Funkce získá informace o aktuálním stavu jedné RF jednotky
  Funkce vrací hodnotu TRUE, pokud se podaøí informace o RF jednotce získat*)
  VAR_INPUT
    RF_line          : usint;  (*èíslo RF linky (viz konstanty MI_RF, RF0_RF,...,RF6_RF)*)
    RF_unitID        : usint;  (*èíslo pozice RF jednotky (1,...,64)*)
  END_VAR
  VAR_IN_OUT
    unitInfo         : TRFunitInfo;  (*promìnná, do které jsou uloeny získané informace o RF jednotce*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetAddressCIBunit : bool
(*Nastavit novou HW adresu CIB jednotky
  Funkce nastaví novou HW adresu CIB jednotky
  Funkce vrací hodnotu TRUE, pokud se podaøí adresu CIB jednotky nastavit*)
  VAR_INPUT
    CIB_line         : usint;  (*èíslo CIB linky (viz konstanty MI_CIB1 a MI6_CIB2)*)
    CIB_unitID       : usint;  (*èíslo pozice CIB jednotky (1,...,32)*)
    CIB_addr         : word;  (*nová HW adresa CIB jednotky*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetAddressRFunit : bool
(*Nastavit novou HW adresu RF jednotky
  Funkce nastaví novou HW adresu RF jednotky
  Funkce vrací hodnotu TRUE, pokud se podaøí adresu RF jednotky nastavit*)
  VAR_INPUT
    RF_line          : usint;  (*èíslo RF linky (viz konstanty MI_RF, RF0_RF,...,RF6_RF)*)
    RF_unitID        : usint;  (*èíslo pozice RF jednotky (1,...,64)*)
    RF_addr          : word;  (*nová HW adresa RF jednotky*)
  END_VAR
END_FUNCTION

TYPE TBondStat {HIDDEN} :
  STRUCT  (*status bondovani*)
    disconnect       : bool;  (*probiha odbondovani*)
    connect          : bool;  (*probiha bondovani*)
    bondMap          : bool;  (*probiha cteni bondovaci mapy*)
    dummy3           : bool;
    dummy4           : bool;
    error            : bool;  (*doslo k chybe*)
    done             : bool;  (*hotovo*)
    busy             : bool;  (*master zaneprazdnen*)
  END_STRUCT;
END_TYPE

TYPE TBondInfo {HIDDEN} :
  STRUCT  (*informace, kterou vraci instrukce SYS 79*)
    bondStat         : TBondStat;
    bondID           : usint;  (*cislo pozice pribondovane jednotky (je-li bondovani uspesne)*)
    bondType         : word;  (*typ pribondovane jednotky (je-li bondovani uspesne)*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbBondRFunit
(*Spárovat RF jednotku s RF masterem
  Funkèní blok spáruje RF jednotku s RF masterem.
  Tato akce mùe nìjakou dobu trvat. Bìhem akce je nastavena promìnná busy.
  Pokud se podaøí RF jednotku spárovat tak je vıstupní promìnná done nastavena na hodnotu TRUE
  a promìnná unitType obsahuje øetìzec s typem a vırobním èíslem spárované RF jednotky.
  V opaèném pøípadì je nastavena promìnná err a promìnná errID obsahuje kód chyby*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*ádost o spárování = nábìná hrana zahájí akci*)
    RF_line          : usint;  (*èíslo RF linky (viz konstanty MI_RF, RF0_RF,...,RF6_RF)*)
    RF_unitID        : usint;  (*èíslo pozice RF jednotky (1,...,64)*)
    bondRq           : bool;  (*0 = pouze zrušit párování, 1 = napárovat novou jednotku*)
    useRouter        : bool;  (*1 = po napárování komunikovat s RF jednotkou pøes router*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*párování úspìšnì ukonèeno*)
    busy             : bool;  (*probíhá párování*)
    err              : bool;  (*párování ukonèeno s chybou*)
    errID            : udint;  (*kód chyby*)
    unitType         : string [40];  (*typ úspìšnì spárované jednotky*)
  END_VAR
  VAR
    result           : TBondInfo;
    timIN            : bool;
    timPT            : time :=  T#2s;
    tim              : TON;  (*odbondovat 2+2 s, pribondovat 12+2 s*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION ProgramLock : bool
(*Uzamèení aplikaèního programu
  Funkce uzamkne uivatelskı program PLC tak,
  e nelze provést jeho zpìtnı pøeklad v prostøedí Mosaic*)
END_FUNCTION

__DECL FUNCTION_BLOCK TPR
(*Èasovaè TPR. Zastaralá verze! V novém projektu pouijte fbTPR.
  (generuje pulz dané šíøky, pulz je mono ukonèit vstupem R)*)
  VAR_INPUT
    IN               : bool;  (*vstup èasovaèe*)
    R                : bool;  (*reset èasovaèe*)
    PT               : time;  (*pøedvolba èasovaèe*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*vıstup èasovaèe*)
    ET               : time;  (*aktuální hodnota èasovaèe*)
  END_VAR
  VAR
    IN_r_edge        : R_TRIG;
    LT               : time;  (*last tick value ( 1ms resolution)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbTPR
(*Èasovaè fbTPR (generuje pulz dané šíøky, pulz je mono ukonèit vstupem R)*)
  VAR_INPUT
    IN               : bool;  (*vstup èasovaèe*)
    R                : bool;  (*reset èasovaèe*)
    PT               : time;  (*pøedvolba èasovaèe*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*vıstup èasovaèe*)
    ET               : time;  (*aktuální hodnota èasovaèe*)
  END_VAR
  VAR
    IN_r_edge        : R_TRIG;
    LT               : time;  (*last tick value ( 1ms resolution)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION SetWebPSW : bool
(*Nastavit heslo pro pøístup na web stránky PLC
   Funkce nastaví nové pøihlašovací jméno a heslo pro pøístup na web stránky v PLC*)
  VAR_INPUT
    user             : usint;  (*cislo radku v tabulce uzivatelu (0...9)*)
  END_VAR
  VAR_IN_OUT
    name             : string [80];  (*nové pøihlašovací jméno*)
    password         : string [80];  (*nové heslo*)
  END_VAR
END_FUNCTION

__DECL FUNCTION VerifyWebPSW : bool
(*Ovìøit heslo pro pøístup na web stránky PLC
   Funkce oveøí, zda-li je nastaveno poadované
   pøihlašovací jméno a heslo pro pøístup na web stránky v PLC*)
  VAR_INPUT
    user             : usint;  (*èíslo øádku v tabulce uivatelù (0...9)*)
  END_VAR
  VAR_IN_OUT
    name             : string [80];  (*pøihlašovací jméno*)
    password         : string [80];  (*heslo*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetWebMAC : bool
(*Nastavit MAC pro pøístup na web stránky PLC
   Funkce nastaví novou MAC adresu pro pøístup na web stránky v PLC*)
  VAR_INPUT
    user             : usint;  (*èíslo øádku v tabulce uivatelù (0...9)*)
  END_VAR
  VAR_IN_OUT
    MAC              : string [80];  (*nová MAC adresa ('00:11:22:33:44:55')*)
  END_VAR
END_FUNCTION

__DECL FUNCTION VerifyWebMAC : bool
(*Ovìøit MAC pro pøístup na web stránky PLC
   Funkce oveøí, zda-li je nastavena poadovaná
   MAC adresa pro pøístup na web stránky v PLC*)
  VAR_INPUT
    user             : usint;  (*èíslo øádku v tabulce uivatelù (0...9)*)
  END_VAR
  VAR_IN_OUT
    MAC              : string [80];  (*MAC adresa ('00:11:22:33:44:55')*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SystemDisplayBacklightOn : bool
(*Rozsvítit podsvícení systémového displeje
   Funkce rozsítí podsvícení LCD displeje na základním modulu PLC.
   Funkce vrací TRUE, pokud je displej na základním modulu dostupnı,
   jinak vrací FALSE.*)
  VAR
    tmp              : udint;
  END_VAR
END_FUNCTION

__DECL FUNCTION SystemDisplayBacklightOff : bool
(*Zhasnout podsvícení systémového displeje
   Funkce zhasne podsvícení LCD displeje na základním modulu PLC.
   Funkce vrací TRUE, pokud je displej na základním modulu dostupnı,
   jinak vrací FALSE.*)
  VAR
    tmp              : udint;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbTick
(*Periodickı èasovaè*)
  VAR_INPUT
    IN               : bool;  (*povolení èasovaèe*)
    PT               : time;  (*perioda vıstupních pulzù*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*vıstup èasovaèe*)
    ET               : time;  (*prùbìnı èas v rámci periody*)
  END_VAR
  VAR
    WasRun           : bool;
    RunTime          : time;
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\MODELLIB_V19_20161101.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : D:\TecoUserLibs\ModelLib_V19_20161101.mlb *)
(* Knihovna : ModelLib 1.9 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c)2004-2012 *)
(* Verze IEC pøekladaèe : 3.11.10.0 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : ModelLib 1.9  }
(* Historie: *)
(*
v1.0 18.09.2004 Byd První verze knihovny
v1.1 02.09.2010 Byd Doplnìny závislosti na knihovnách a pøidány komentáøe.
v1.2 04.05.2012 Byd Vylepšená inicializace fbSimplePID
v1.3 21.09.2012 Byd Vylepšenı fbSimplePID, pøidanı fbStepControl
v1.4 08.11.2012 Byd fbStepControl vylepšené hlídání minimální doby pulzu
v1.5 14.11.2012 Byd fbSimplePID opraveno chování v saturaci
v1.6 27.11.2013 Byd fbStepControl pøi saturaci je nastaven vıstup Open/Close trvale 
(døíve byl resetován pokud sepnutí trvalo déle jak t0100) 
v1.7 21.11.2014 Byd fbSimplePID pøi inicializaci potlaèen zásah od derivaèní sloky
v1.8 09.06.2016 Byd Algoritmus èasování ošetøen proti stavu, kdy se funkèní blok nevolá v kadém 
cyklu PLC
v1.9 01.11.2016 Byd Ošetøení bloku fbSimplePID proti vstupùm typu NaN
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\REXLIB_V17_20101208.MLB"}

__DECL FUNCTION fcModelLibInvalidReal {HIDDEN} : bool
  VAR_INPUT
    r                : real;
  END_VAR
END_FUNCTION

TYPE  GenericArrayForDelay : ARRAY [0..1023] OF real;  (*Obecnı typ pro VAR_IN_OUT*)
END_TYPE

__DECL FUNCTION fcHiddenModelLibDoStep {HIDDEN} : bool
(*Auxiliary function for controlling periodic execution*)
  VAR_INPUT
    T                : real;
  END_VAR
  VAR_IN_OUT
    LastT            : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbLimIntegrator
(*Simulace integrace vstupu s omezením.
  Poèítáno stupòovitou náhradou zleva

            1    /t
  Out(t) = --- * |  In(t) dt + Preset
            Ti   /0

  Aproximace:

  Out(k) = Out(k-1) + (T/Ti) * In(k) + Preset*)
  VAR_INPUT
    In               : real;  (*Vstupní signál*)
    MinO             : real;  (*Omezení*)
    MaxO             : real;  (*Omezení*)
    T                : real :=  0.100;  (*Perioda vzorkování v sekundách*)
    Preset           : real;  (*Poèáteèní hodnota*)
    Reset            : bool R_EDGE;  (*Reset vıstupu na poèáteèní hodnotu*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Integrál vstupního signálu*)
  END_VAR
  VAR
    Init             : bool;  (*Initialization flag (true means initialized)*)
    LastT            : time;  (*Last time of block execution*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbIntegrator
(*Simulace integrace vstupu.
  Poèítáno stupòovitou náhradou zleva.
  
           /t
  Out(t) = |  In(t) dt + Preset
           /0

  Aproximace:

  Out(k) = Out(k-1) + T * In(k) + Preset*)
  VAR_INPUT
    In               : real;  (*Vstupní signál*)
    T                : real :=  0.1;  (*Perioda vzorkování v sekundách*)
    Preset           : real;  (*Poèáteèní hodnota*)
    Reset            : bool R_EDGE;  (*Reset vıstupu na poèáteèní hodnotu*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Integrál vstupního signálu*)
  END_VAR
  VAR
    Init             : bool;  (*Initialization flag (true means initialized)*)
    LastT            : time;  (*Last time of block execution*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbDerivator
(*Simulace derivace vstupu
  Poèítáno lichobìníkovou náhradou.

                  d
  Out(t) = In(t) ---
                  dt

  Aproximace:

  Out(k) = (In(k) - In(k-1)) / T*)
  VAR_INPUT
    In               : real;  (*Vstupní signál*)
    T                : real :=  0.1;  (*Perioda vzorkování v sekundách*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Derivace vstupního signálu*)
  END_VAR
  VAR
    Init             : bool;  (*Initialization flag (true means initialized)*)
    LastT            : time;  (*Last time of block execution*)
    Last_In          : real;  (*Last input value (In(k-1))*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbDelay
(*Simulace dopravního zpodìní

  Out(t) = In(t - Tau)
  Tau = T*K

  Aproximace:

  Out(k) = In(k-K)*)
  VAR_INPUT
    In               : real;  (*Vstupní signál*)
    K                : int;  (*Dopravní zpodìní vyjádøené poètem period. Maximum je dáno velikostí zásobníku Buffer (max 1024)*)
    T                : real :=  0.1;  (*Perioda vzorkování v sekundách*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Zpodìnı vstupní signál*)
  END_VAR
  VAR_IN_OUT
    Buffer           : GenericArrayForDelay;  (*Zásobník minulıch vzorkù. Mùe odkazovat na libovolné pole typù REAL do velikosti 1024 prvkù*)
  END_VAR
  VAR
    LastT            : time;  (*Last time of block execution*)
    Point            : int;  (*Pointer to buffer*)
    Init             : bool;  (*Initialization flag (true means initialized)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbFirstOrder
(*Simulace lineárního diferenciálního systému prvního øádu
       se statickım zesílením G a èasovou konstantou T1 dle vzorce

       d Out(t)
  T1 * -------- + Out(t) = G * In
          dt

  nebo po Laplaceho transformaci

  OUT(s) * [T1 * s + 1] = G * IN(s)*)
  VAR_INPUT
    In               : real;  (*Vstupní signál*)
    G                : real :=  1.0;  (*Statické zesílení*)
    T1               : real :=  1.0;  (*Èasová konstanta v sekundách*)
    T                : real :=  0.1;  (*Perioda vzorkování v sekundách*)
    Preset           : real;  (*Poèáteèní hodnota*)
    Reset            : bool R_EDGE;  (*Reset vıstupu na poèáteèní hodnotu*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Vıstupní signál*)
  END_VAR
  VAR
    Init             : bool;  (*Initialization flag (true means initialized)*)
    LastT            : time;  (*Last time of block execution*)
    Exp1             : real;  (*Constant evaluated by time constant*)
    OldT1            : real;  (*Old time constant - for change tracking*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSecondOrder
(*Simulace lineárního diferenciálního systému druhého øádu
  se statickım zesílením G a èasovou konstantou T1 a T2 dle vzorce
  
          d^2 Out(t)             d Out(t)
  T1 * T2 ---------- + (T1 + T2) -------- + Out(t) = G * In(t)
             dt^2                   dt

  nebo po Laplaceho transformaci

  OUT(s) * [T1 * T2 * s^2 + (T1 + T2) * s + 1] = G * IN(s)*)
  VAR_INPUT
    In               : real;  (*Vstupní signál*)
    G                : real :=  1.0;  (*Statické zesílení*)
    T1               : real :=  1.0;  (*Èasová konstanta v sekundách*)
    T2               : real :=  1.0;  (*Èasová konstanta v sekundách*)
    T                : real :=  0.1;  (*Perioda vzorkování v sekundách*)
    Preset           : real;  (*Poèáteèní hodnota*)
    Reset            : bool R_EDGE;  (*Reset vıstupu na poèáteèní hodnotu*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Vıstupní signál*)
  END_VAR
  VAR
    Init             : bool;  (*Initialization flag (true means initialized)*)
    LastT            : time;  (*Last time of block execution*)
    a                : real;  (*Auxiliary constants*)
    b                : real;  (*Auxiliary constants*)
    c                : real;  (*Auxiliary constants*)
    d                : real;  (*Auxiliary constants*)
    OldT1            : real;  (*Old time constant - for change tracking*)
    OldT2            : real;  (*Old time constant - for change tracking*)
    LastIn           : real;  (*Last input*)
    LastOut          : real;  (*Output to step older*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSecondOrderOsc
(*Funkèní blok slouí pro simulaci kmitajícího lineárního diferenciálního systému druhého øádu
  se statickım zesílením G a èasovou konstantou T1 dle vzorce
  
              d^2 Out(t)                 d Out(t)
  (1 / Omg^2) ---------- + 2 * Alp / Omg -------- + Out(t) = G * In(t)
                 dt^2                       dt

  nebo po Laplaceho transformaci

  OUT(s) * [(1 / Omg^2) * s^2  + 2 * Alp / Omg * s + 1] = G * IN(s)*)
  VAR_INPUT
    In               : real;  (*Vstupní signál*)
    G                : real :=  1.0;  (*Statické zesílení*)
    Alp              : real :=  0.25;  (*Koeficient tlumení*)
    Omg              : real :=  4.0;  (*Vlastní úhlová frekvence [1/(rad * s)]*)
    T                : real :=  0.1;  (*Perioda vzorkování v sekundách*)
    Preset           : real;  (*Poèáteèní hodnota*)
    Reset            : bool R_EDGE;  (*Reset vıstupu na poèáteèní hodnotu*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Vıstupní signál*)
  END_VAR
  VAR
    i1               : fbIntegrator;
    i2               : fbIntegrator;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSimplePID
(*Algoritmus PID s filtrovanou derivaèní slokou a omezením integraèní sloky pøi saturaci vıstupu
  popsán Laplaceho rovnící

                /          1              Td * s        \
  U(s) = Gain * | E(s) + ------ E(s) - ----------- Y(s) |
                \        Ti * s         Tf * s + 1      /*)
  VAR_INPUT
    y                : real;  (*Mìøená velièina*)
    w                : real;  (*ádaná hodnota*)
    u_man            : real;  (*Hodnota vıstupu v ruèním reimu*)
    min_u            : real :=  0.0;  (*Minimální hodnota vıstupu*)
    max_u            : real :=  100.0;  (*Maximální hodnota vıstupu*)
    Gain             : real :=  1.0;  (*Zesílení*)
    Ti               : real :=  10.0;  (*Integraèní konstanta v sekundách*)
    Td               : real :=  1.0;  (*Derivaèní èasová konstanta v sekundách*)
    T                : real :=  0.1;  (*Perioda vzorkování v sekundách*)
    Tf               : real :=  0.25;  (*Èasová konstanta filtru derivaèní sloky v sekundách*)
    dz               : real;  (*Symetrické pásmo necitlivosti*)
    manual           : bool;  (*Nastavení ruèního reimu (0 – automatickı reim, 1 – ruèní reim)*)
    IH               : bool;  (*Pozastavení integrace (0 = integrace je povolena, 1 = integrace je pozastavena)*)
  END_VAR
  VAR_OUTPUT
    u                : real;  (*Vıstup regulátoru*)
    uvel             : real;  (*Rychlost vıstup regulátoru*)
    partP            : real;  (*Hodnota proporcionální sloky*)
    partI            : real;  (*Hodnota integraèní sloky*)
    partD            : real;  (*Hodnota derivaèní sloky*)
    e                : real;  (*Regulaèní odchylka*)
    auto             : bool;  (*Reim regulátoru (0 – ruèní reim, 1 – automatickı reim)*)
    satmax           : bool;  (*Vıstup saturován na maximální hodnotì*)
    satmin           : bool;  (*Vıstup saturován na minimální hodnotì*)
  END_VAR
  VAR
    wasman           : bool;  (*flag for change from manual mode*)
    Init             : bool;  (*initialization flag (true means initialized)*)
    e_1              : real;  (*last deviation*)
    y_p              : real;  (*filtered input*)
    y_1              : real;  (*last output*)
    LastT            : time;  (*last execution time*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK _STEP_CONTROL_POS_SIM_
(*Pomocnı blok
nepouívat samostatnì*)
  VAR_INPUT
    o                : bool;
    c                : bool;
    fo               : bool;
    fc               : bool;
    t0100            : real;
  END_VAR
  VAR
    LT               : time;
    timdif           : real;
    virPos           : real;
    INIT             : bool;
  END_VAR
  VAR_OUTPUT
    so               : bool;
    sc               : bool;
    pos              : real;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbStepControl
(*Tøístavové ovládaní servopohonu pro fbSimplePID*)
  VAR_INPUT
    Pos              : real;  (*ádaná poloha servopohonu*)
    PosVel           : real;  (*Rychlost zmìny ádané polohy servopohonu*)
    HiSw             : bool;  (*Koncovı spínaè plnì otevøené polohy*)
    LoSw             : bool;  (*Koncovı spínaè plnì zavøené polohy*)
    t0100            : real :=  30.0;  (*Doba pøechodu z plnì zavøené do plnì otevøené polohy v sekundách*)
    tmin             : real :=  0.5;  (*Minimální délka pulzu a doba mezi pulzy v sekundách*)
    t01min           : real :=  2.0;  (*Minimální doba mezi pulzy opaèné polarity v sekundách*)
  END_VAR
  VAR_OUTPUT
    Open             : bool;  (*Poadavek otvírat*)
    Close            : bool;  (*Poadavek zavírat*)
    Run              : bool;  (*Pohon v pohybu (logickı souèet poadavku otvírat a zavírat)*)
    VirPos           : real;  (*Vypoètená virtuální poloha pohonu*)
  END_VAR
  VAR
    wasOpen          : bool;
    wasClose         : bool;
    Idle             : bool;
    t0               : TON;  (*_TIM_REAL_;*)
    t1               : TON;  (*_TIM_REAL_;*)
    ps               : _STEP_CONTROL_POS_SIM_;
  END_VAR
END_FUNCTION_BLOCK

TYPE TGeneratorSignalType : 
  (gst_Sin,
   gst_Square,
   gst_Saw,
   gst_DblSaw 
  );
END_TYPE

__DECL FUNCTION_BLOCK fbGenerator
(*Generátor signálu*)
  VAR_INPUT
    Zero             : real;  (*Posun nuly generovaného signálu*)
    Amp              : real :=  1.0;  (*Amplituda vıstupního signálu*)
    Per              : real :=  1.0;  (*Perioda vıstupního signálu*)
    SType            : TGeneratorSignalType;  (*Typ vıstupního signálu*)
    Reset            : bool R_EDGE;  (*Reset generátoru*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*Vıstup generátoru*)
  END_VAR
  VAR
    Init             : bool;
    Start            : time;
    Phase            : real;
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\COMLIB_V24_20161019.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : C:\TecoLib\ComLib_V24_20161019.mlb *)
(* Knihovna : ComLib 2.4 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c) 2016 Teco a.s. *)
(* Verze IEC pøekladaèe : 3.12.3.1 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : ComLib 2.4  }
(* Historie: *)
(*
v1.0 23.03.2009 Nem první verze knihovny
v1.1 27.03.2009 Nem doplnìna chyba, pokud je nulova délka vysilanıch dat 
v1.2 24.06.2009 Nem doplnìn pøíjem a vysílání pro ETH2_uni 
v1.3 24.09.2009 Nem funkce GetMACaddress povolena i pro ETH2, doplnìny funkce 
                    SetDHCPsupport(), STRING_TO_IPADR() a IPADR_TO_STRING()
v1.4 08.02.2010 Nem doplnìna funkce GetChanStat() 18.02.2010 doplnìny funkce 
                    GetChanSettings() a SetChanSettings() 
v1.5 02.08.2010 Nem zkompletovány komentáøe pro èeskou a anglickou verzi
v1.6 08.08.2011 Nem ve fbSendTo() ošetøeno pøeplnìní bufferu TCP socketu 
v1.7 23.01.2012 Nem doplnìny funkce SetDNS_IP(), GetDNS_IP() a fbRecvTxt()
v1.8 18.04.2012 Nem do funkèního bloku fbRecvTxt() doplnìn vıstup error
                    doplnìny deklarace ETH3_uni0,...,ETH4_uni7
                Byd doplnìn funkèní blok fbRecvTxtChar()
v2.0 14.03.2013 Nem doplnìna deklarace link do struktury TEthStat
		    (síovı kabel pøipojen)
v2.1 28.05.2013 Nem doplnìny globální promìnné ETH3_STAT a ETH4_STAT
                    doplnìna funkce GetWebServerAccess() 
                    a funkèní blok fbKeepAliveTCP() - poadovaná 
                    verze FW centrální jednotky je 7.7 nebo vyšší
     22.08.2013 Nem v bloku fbSendTo() oprava kontroly max. délky vysílanıch dat 
v2.2 03.07.2015 Nem doplnìny funkce SetRTS() a GetRTS()
v2.3 19.10.2016 Nem doplnìna funkce CheckGatewayIP()
v2.4 12.12.2016 Nem doplnìna funkce MACADR_TO_STRING()
*)

(*----------------------------------------------------------------------------*)

TYPE TUniDesc :
  STRUCT  (*popis kanálu v univerzálním reimu*)
    modeChan         : byte;  (*reim kanálu*)
    res              : byte;  (*rezerva*)
    adrUniStat       : udint;  (*adresa stavové zóny*)
    lenUniStat       : uint;  (*délka stavové zóny*)
    adrUniCont       : udint;  (*adresa øídící zóny*)
    lenUniCont       : uint;  (*délka øídící zóny*)
    adrUniIn         : udint;  (*adresa pøijímací zóny*)
    lenUniIn         : uint;  (*délka pøijímací zóny*)
    adrUniOut        : udint;  (*adresa vysílací zony*)
    lenUniOut        : uint;  (*délka vysílací zony*)
  END_STRUCT;
END_TYPE

TYPE  TIPadr : ARRAY [0..3] OF usint;  (*IP adresa*)
END_TYPE

TYPE TLocalEthAdr :
  STRUCT  (*struktura lokální IP adresy*)
    IP               : TIPadr;  (*IP adresa*)
    IM               : TIPadr;  (*maska sítì*)
    GW               : TIPadr;  (*adresa brány*)
  END_STRUCT;
END_TYPE

TYPE TRemoteEthAdr :
  STRUCT  (*struktura vzdálené IP adresy*)
    remoteIP         : TIPadr;  (*vzdálená IP adresa*)
    remotePort       : uint;  (*vzdálenı port*)
    localPort        : uint;  (*lokální port*)
  END_STRUCT;
END_TYPE

TYPE  TMacAdr : ARRAY [0..5] OF byte;  (*MAC adresa*)
END_TYPE

TYPE TChanSettings :
  STRUCT  (*struktura parametru pro seriovy kanal v rezimu UNI*)
    modeChan         : usint;  (*reim kanálu (uni = 5)*)
    address          : usint;  (*adresa kanálu*)
    speed            : usint;  (*komunikaèní rychlost*)
    rxTimeout        : usint;  (*timeout pøíjmu*)
    txTimeout        : usint;  (*timeout vysílání*)
    lineControl      : usint;  (*nastavení parity*)
    modemControl     : usint;  (*modemové signály*)
    rez              : usint;  (*rezerva*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 MODE_OFF : usint :=  16#00;  (*kanál je vypnutı*)
 MODE_PC : usint :=  16#02;  (*reim EPSNET slave*)
 MODE_UNI : usint :=  16#05;  (*univerzální reim*)
 MODE_MPC : usint :=  16#06;  (*reim EPSNET multimaster*)
 MODE_MDB : usint :=  16#07;  (*reim MODBUS slave*)
 MODE_PFB : usint :=  16#08;  (*reim PROFIBUS DP master*)
 BAUD_50 : usint :=  16#01;  (*50 Baud*)
 BAUD_100 : usint :=  16#02;  (*100 Baud*)
 BAUD_200 : usint :=  16#03;  (*200 Baud*)
 BAUD_300 : usint :=  16#04;  (*300 Baud*)
 BAUD_600 : usint :=  16#05;  (*600 Baud*)
 BAUD_1200 : usint :=  16#06;  (*1200 Baud*)
 BAUD_2400 : usint :=  16#07;  (*2400 Baud*)
 BAUD_4800 : usint :=  16#08;  (*4800 Baud*)
 BAUD_9600 : usint :=  16#0A;  (*9600 Baud*)
 BAUD_14400 : usint :=  16#0B;  (*14400 Baud*)
 BAUD_19200 : usint :=  16#0C;  (*19200 Baud*)
 BAUD_28800 : usint :=  16#0D;  (*28800 Baud*)
 BAUD_38400 : usint :=  16#0E;  (*38400 Baud*)
 BAUD_57600 : usint :=  16#10;  (*57600 Baud*)
 BAUD_76800 : usint :=  16#12;  (*76800 Baud*)
 BAUD_93750 : usint :=  16#13;  (*937500 Baud*)
 BAUD_115200 : usint :=  16#14;  (*115200 Baud*)
 NO_PARITY : usint :=  16#00;  (*bez parity (lineControl kod)*)
 PARITY_ODD : usint :=  16#08;  (*lichá parita (lineControl kod)*)
 PARITY_EVEN : usint :=  16#18;  (*sudá parita (lineControl kod)*)
 PARITY_0 : usint :=  16#28;  (*parita pevnì 0 (lineControl kod)*)
 PARITY_1 : usint :=  16#38;  (*parita pevnì 1 (lineControl kod)*)
 SEVEN_BITS : usint :=  16#40;  (*7 datovıch bitù (lineControl kod)*)
 EIGHT_BITS : usint :=  16#00;  (*8 datovıch bitù (lineControl kod)*)
 ONE_STOP_BIT : usint :=  16#00;  (*1 stop bit*)
 TWO_STOP_BITS : usint :=  16#80;  (*2 stop bity*)
 RTS_0 : usint :=  16#00;  (*RTS pevnì 0 (modemControl kod)*)
 RTS_1 : usint :=  16#02;  (*RTS pevnì 1 (modemControl kod)*)
 RTS_MAN : usint :=  16#40;  (*RTS øízené z uivatelského programu (modemControl kod)*)
 RTS_AUTO : usint :=  16#80;  (*automatická hodnota RTS (modemControl kod)*)
 RTS_CTS_AUTO : usint :=  16#C0;  (*RTS auto + pøíjem podmínìn signálem CTS (modemControl kod)*)
 HALF_DUPLEX : usint :=  16#08;  (*zákaz pøíjmu bìhem vysílání (modemControl kod)*)

END_VAR

TYPE TCHxStatistic {HIDDEN} :
  STRUCT
    STAT             : usint;
    ERR              : usint;
    trueMes          : udint;
    falseMes         : udint;
  END_STRUCT;
END_TYPE

TYPE TCHxControl {HIDDEN} :
  STRUCT
    CONTROL          : uint;
  END_STRUCT;
END_TYPE

TYPE TUni_STAT :
  STRUCT
    DSR              : bool;
    CTS              : bool;
    dummy1           : bool;
    TRO              : bool;
    RCF              : bool;
    ROV              : bool;
    TRF              : bool;
    ARC              : bool;
  END_STRUCT;
END_TYPE

TYPE TUni_CONT {HIDDEN} :
  STRUCT
    dummy0           : bool;
    dummy1           : bool;
    dummy2           : bool;
    dummy3           : bool;
    dummy4           : bool;
    TRG              : bool;
    CLR              : bool;
    ACN              : bool;
  END_STRUCT;
END_TYPE

TYPE TUni_SIGN {HIDDEN} :
  STRUCT
    DTR              : bool;
    RTS              : bool;
  END_STRUCT;
END_TYPE

TYPE  TUni_BUFF : ARRAY [0..1400] OF usint;
END_TYPE

TYPE TUni_IN {HIDDEN} :
  STRUCT  (*pøijímací datová struktura kanálu v univerzálním reimu*)
    STAT             : TUni_STAT;  (*stav pøíjmu*)
    ERR              : usint;  (*chybovı kód*)
    NUMR             : uint;  (*poèet pøijatıch bytù*)
    DATA             : TUni_BUFF;  (*pøijatá data*)
  END_STRUCT;
END_TYPE

TYPE TUni_OUT {HIDDEN} :
  STRUCT  (*vysílací datová struktura kanálu v univerzálním reimu*)
    CONT             : TUni_CONT;  (*øízení vysílání*)
    SIGN             : TUni_SIGN;  (*øízení modemovıch signálù*)
    NUMT             : uint;  (*poèet vysílanıch bytù*)
    DATA             : TUni_BUFF;  (*vysílaná data*)
  END_STRUCT;
END_TYPE

TYPE TEthStat :
  STRUCT  (*status Ethernet kanálu*)
    chan_present     : bool;  (*kanál pøítomen*)
    DHCP_enabled     : bool;  (*poadováno automatické pøidelení IP adresy DHCP serverem*)
    IP_obtained      : bool;  (*IP adresa získána od DHCP serveru*)
    IP_expired       : bool;  (*platnost automaticky pøidìlené IP adresy vypršela*)
    link             : bool;  (*síovı kabel pøipojen*)
    reserved         : usint;  (*rezerva*)
    trueMes          : udint;  (*celkovı poèet dobrıch zpráv*)
    falseMes         : udint;  (*celkovı poèet špatnıch zpráv*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL
 ETH1_STAT AT %S356 : TEthStat;  (*status Ethernet kanálu ETH1*)
 ETH2_STAT AT %S368 : TEthStat;  (*status Ethernet kanálu ETH2*)
 ETH3_STAT AT %S380 : TEthStat;  (*status Ethernet kanálu ETH3*)
 ETH4_STAT AT %S392 : TEthStat;  (*status Ethernet kanálu ETH4*)

END_VAR

VAR_GLOBAL CONSTANT
 ANY_IP : TIPadr :=  [0];  (*IP adresa 0.0.0.0*)
 ETH1_uni0 : uint :=  16#07E1;  (*Ethernet ETH1, reim uni, spojení uni0*)
 ETH1_uni1 : uint :=  16#17E1;  (*Ethernet ETH1, reim uni, spojení uni1*)
 ETH1_uni2 : uint :=  16#27E1;  (*Ethernet ETH1, reim uni, spojení uni2*)
 ETH1_uni3 : uint :=  16#37E1;  (*Ethernet ETH1, reim uni, spojení uni3*)
 ETH1_uni4 : uint :=  16#47E1;  (*Ethernet ETH1, reim uni, spojení uni4*)
 ETH1_uni5 : uint :=  16#57E1;  (*Ethernet ETH1, reim uni, spojení uni5*)
 ETH1_uni6 : uint :=  16#67E1;  (*Ethernet ETH1, reim uni, spojení uni6*)
 ETH1_uni7 : uint :=  16#77E1;  (*Ethernet ETH1, reim uni, spojení uni7*)
 ETH2_uni0 : uint :=  16#07E2;  (*Ethernet ETH2, reim uni, spojení uni0*)
 ETH2_uni1 : uint :=  16#17E2;  (*Ethernet ETH2, reim uni, spojení uni1*)
 ETH2_uni2 : uint :=  16#27E2;  (*Ethernet ETH2, reim uni, spojení uni2*)
 ETH2_uni3 : uint :=  16#37E2;  (*Ethernet ETH2, reim uni, spojení uni3*)
 ETH2_uni4 : uint :=  16#47E2;  (*Ethernet ETH2, reim uni, spojení uni4*)
 ETH2_uni5 : uint :=  16#57E2;  (*Ethernet ETH2, reim uni, spojení uni5*)
 ETH2_uni6 : uint :=  16#67E2;  (*Ethernet ETH2, reim uni, spojení uni6*)
 ETH2_uni7 : uint :=  16#77E2;  (*Ethernet ETH2, reim uni, spojení uni7*)
 ETH3_uni0 : uint :=  16#07E3;  (*Ethernet ETH3, reim uni, spojení uni0*)
 ETH3_uni1 : uint :=  16#17E3;  (*Ethernet ETH3, reim uni, spojení uni1*)
 ETH3_uni2 : uint :=  16#27E3;  (*Ethernet ETH3, reim uni, spojení uni2*)
 ETH3_uni3 : uint :=  16#37E3;  (*Ethernet ETH3, reim uni, spojení uni3*)
 ETH3_uni4 : uint :=  16#47E3;  (*Ethernet ETH3, reim uni, spojení uni4*)
 ETH3_uni5 : uint :=  16#57E3;  (*Ethernet ETH3, reim uni, spojení uni5*)
 ETH3_uni6 : uint :=  16#67E3;  (*Ethernet ETH3, reim uni, spojení uni6*)
 ETH3_uni7 : uint :=  16#77E3;  (*Ethernet ETH3, reim uni, spojení uni7*)
 ETH4_uni0 : uint :=  16#07E4;  (*Ethernet ETH4, reim uni, spojení uni0*)
 ETH4_uni1 : uint :=  16#17E4;  (*Ethernet ETH4, reim uni, spojení uni1*)
 ETH4_uni2 : uint :=  16#27E4;  (*Ethernet ETH4, reim uni, spojení uni2*)
 ETH4_uni3 : uint :=  16#37E4;  (*Ethernet ETH4, reim uni, spojení uni3*)
 ETH4_uni4 : uint :=  16#47E4;  (*Ethernet ETH4, reim uni, spojení uni4*)
 ETH4_uni5 : uint :=  16#57E4;  (*Ethernet ETH4, reim uni, spojení uni5*)
 ETH4_uni6 : uint :=  16#67E4;  (*Ethernet ETH4, reim uni, spojení uni6*)
 ETH4_uni7 : uint :=  16#77E4;  (*Ethernet ETH4, reim uni, spojení uni7*)
 CH1_uni : uint :=  16#0101;  (*Sériovı kanál CH1, reim uni*)
 CH2_uni : uint :=  16#0202;  (*Sériovı kanál CH2, reim uni*)
 CH3_uni : uint :=  16#0103;  (*Sériovı kanál CH3, reim uni*)
 CH4_uni : uint :=  16#0204;  (*Sériovı kanál CH4, reim uni*)
 CH5_uni : uint :=  16#0105;  (*Sériovı kanál CH5, reim uni*)
 CH6_uni : uint :=  16#0206;  (*Sériovı kanál CH6, reim uni*)
 CH7_uni : uint :=  16#0107;  (*Sériovı kanál CH7, reim uni*)
 CH8_uni : uint :=  16#0208;  (*Sériovı kanál CH8, reim uni*)
 CH9_uni : uint :=  16#0109;  (*Sériovı kanál CH9, reim uni*)
 CH10_uni : uint :=  16#020A;  (*Sériovı kanál CH10, reim uni*)
 ETH1 : usint :=  16#E1;  (*Ethernet ETH1*)
 ETH2 : usint :=  16#E2;  (*Ethernet ETH2*)
 ETH3 : usint :=  16#E3;  (*Ethernet ETH3*)
 ETH4 : usint :=  16#E4;  (*Ethernet ETH4*)
 SCH1 : usint :=  16#01;  (*Sériovı kanál CH1*)
 SCH2 : usint :=  16#02;  (*Sériovı kanál CH2*)
 SCH3 : usint :=  16#03;  (*Sériovı kanál CH3*)
 SCH4 : usint :=  16#04;  (*Sériovı kanál CH4*)
 SCH5 : usint :=  16#05;  (*Sériovı kanál CH5*)
 SCH6 : usint :=  16#06;  (*Sériovı kanál CH6*)
 SCH7 : usint :=  16#07;  (*Sériovı kanál CH7*)
 SCH8 : usint :=  16#08;  (*Sériovı kanál CH8*)
 SCH9 : usint :=  16#09;  (*Sériovı kanál CH9*)
 SCH10 : usint :=  16#0A;  (*Sériovı kanál CH10*)
 COM_OK : usint :=  0;  (*bez chyby*)
 COM_ERR1 : usint :=  1;  (*kanál není v reimu uni*)
 COM_ERR2 : usint :=  2;  (*vysílaná data jsou pøíliš dlouhá*)
 COM_ERR3 : usint :=  3;  (*pøijatá data jsou pøíliš dlouhá*)
 COM_ERR4 : usint :=  4;  (*chybnı kód kanálu*)
 COM_ERR5 : usint :=  5;  (*pøedchozí zpráva není ještì odvysílaná*)
 COM_ERR6 : usint :=  6;  (*nulová délka vysílanych dat*)
 COM_ERR7 : usint :=  7;  (*chybná pøenosová rychlost*)
 COM_ERR8 : usint :=  8;  (*kanál je vypnutı*)
 COM_ERR16 : usint :=  16#10;  (*chybnı poèáteèní znak*)
 COM_ERR17 : usint :=  16#11;  (*chyba parity*)
 COM_ERR18 : usint :=  16#12;  (*pøekroèena maximální délka zprávy*)
 COM_ERR19 : usint :=  16#13;  (*chybnı druhı byte potvrzení*)
 COM_ERR20 : usint :=  16#14;  (*chybnı druhı byte koncového znaku*)
 COM_ERR24 : usint :=  16#18;  (*chyba kontrolního souètu*)
 COM_ERR25 : usint :=  16#19;  (*chybnı koncovı znak*)
 COM_ERR49 : usint :=  16#31;  (*chybná délka vysílanıch dat*)
 COM_ERR50 : usint :=  16#32;  (*nulová délka vysílanıch dat*)
 COM_ERR64 : usint :=  16#40;  (*nedodren timeout*)
 COM_ERRc6 : usint :=  16#C6;  (*seriovı kanál neni v poadovaném reimu*)

END_VAR

__DECL FUNCTION GetChanDesc : TUniDesc
(*Získat popisovaè sériového kanálu

     Funkce testuje aktuální namapování sériového kanálu do pamìti PLC.
     Tato funkce je urèena pro vnitøní pouití v knihovnì.

     Funkce vrací popisovaè kanálu (strukturu TUniDesc).*)
  VAR_INPUT
    chanCode         : uint;  (*channel code (ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetChanIndex : int
(*Test existence komunikaèního kanálu

   Funkce kontroluje platnost promìnné chanCode.
   Tato funkce je urèena pro vnitøní pouití v knihovnì.

   Pokud je hodnota promìnné chanCode platná, vrací funkce
   index kanálu (kladné èíslo), jinak vrací -1.*)
  VAR_INPUT
    chanCode         : uint;  (*kód kanálu*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 ComErrorString : ARRAY [0..20] OF string [40] :=  [
       'No error                                ',
       'Channel is not in uni mode              ',
       'Sending data are too long               ',
       'Received data are too long              ',
       'Wrong channel code                      ',
       'Previous message is not sent yet        ',
       'Zero message length                     ',
       'Invalid communication speed             ',
       'Channel is disabled                     ',
       'Invalid start delimiter                 ',
       'Parity error                            ',
       'Maximum message length exceeded         ',
       'Invalid second byte of acknowledgment   ',
       'Invalid second byte of end delimiter    ',
       'Check sum error                         ',
       'Invalid end delimiter                   ',
       'Invalid length of sent data             ',
       'Sent data zero length                   ',
       'Timeout not held                        ',
       'Invalid channel mode                    ',
       'Unknown error                           '];

END_VAR

__DECL FUNCTION GetLastComErrTxt : string
(*errCode : USINT;         chybovı kód
  END_VAR*)
  VAR_INPUT
    errCode          : usint;  (*chybovı kód*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetChanSettings : bool
(*Test nastavení sériového kanálu

   Funkce testuje aktuální nastavení sériového kanálu
   (Pozor ! Kanál musí bıt v univerzálním reimu).

   Funkce vrací TRUE, pokud se podaøí zjistit nastavení
   sériového kanálu (nastavení je uloeno v promìnné chanSet),
   jinak vrací FALSE.*)
  VAR_INPUT
    serChan          : usint;  (*èíslo sériového kanálu (SCH1, ..., SCH10)*)
  END_VAR
  VAR_IN_OUT
    chanSet          : TChanSettings;  (*aktuální nastavení sériového kanálu*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetChanSettings : usint
(*Nastavení parametrù sériového kanálu

   Funkce nastavuje nové parametry sériového kanálu
   (rychlost komunikace, paritu, ...).

   Funkce vrací 0, pokud se podaøí nastavit nové parametry (bez chyby).
   V pøípadì, e se nepodaøí parametry nastavit, vrací funkce chybovı kód.*)
  VAR_INPUT
    rq               : bool;  (*ádost o nové nastavení*)
    serChan          : usint;  (*èíslo sériového kanálu (SCH1, ..., SCH10)*)
  END_VAR
  VAR_IN_OUT
    chanSet          : TChanSettings;  (*Nové natavení sériového kanálu*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetChanStat : TUni_STAT
(*Test stavu komunikaèního kanálu

   Funkce vrací strukturu TUni_STAT s informacemi o stavu kanálu.*)
  VAR CONSTANT
    initStat         : TUni_STAT :=  ( DSR := false,  CTS := false,  dummy1 := false,  TRO := false,
                              RCF := false,  ROV := false,  TRF := false,  ARC := false);
  END_VAR
  VAR_INPUT
    chanCode         : uint;  (*kód kanálu (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION EstabTCPconnection : usint
(*Navázat TCP spojení

   Funkce zahájí proces navazání TCP spojení.
   Tento proces mùe nìjakou dobu trvat.

   Funkce vrací 0, pokud se podaøilo zahájit navazování spojení.
   Jinak funkce vrací chybovı kód.*)
  VAR_INPUT
    chanCode         : uint;  (*kód kanálu (ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CloseTCPconnection : usint
(*Ukonèit TCP spojení

   Funkce zahájí proces uzavøení TCP spojení.
   Tato operace mùe nìjakou dobu trvat.

   Funkce vrací 0 pokud se podaøí zahájit uzavøení spojení.
   Jinak vrací chybovı kód.*)
  VAR_INPUT
    chanCode         : uint;  (*kód kanálu (ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION IsEstabTCPconnection : bool
(*Test stavu TCP spojení

   Funkce vrací TRUE, pokud je spojení navázáno.
   Jinak vrací FALSE.*)
  VAR_INPUT
    chanCode         : uint;  (*kód kanálu (ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetRemoteIPaddress : bool
(*Nastavení cílové IP adresy

   Funkce nastaví novou cílovou IP adresu,
   cílovı port a zdrojovı port pro zadanı kanál.
   Nové hodnoty definuje promìnná ethAdr.

   Funkce vrací TRUE, pokud se nové hodnoty podaøí nastavit.*)
  VAR_INPUT
    rq               : bool;  (*ádost o nové nastavení*)
    chanCode         : uint;  (*kód kanálu (ETH1_uni0, ..., ETH1_uni7)*)
  END_VAR
  VAR_IN_OUT
    ethAdr           : TRemoteEthAdr;  (*nové nastavení*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetRemoteIPaddress : bool
(*Test cílové IP adresy

   Funkce zjišuje aktuálnì nastavenou cílovou IP adresu,
   cílovı port a zdrojovı port pro zadanı kanál.

   Funkce vrací TRUE, pokud se nové hodnoty podaøí zjistit.
   Zjištené hodnoty jsou uloeny do promìnné ethAdr.*)
  VAR_INPUT
    chanCode         : uint;  (*kód kanálu (ETH1_uni0, ..., ETH1_uni7)*)
  END_VAR
  VAR_IN_OUT
    ethAdr           : TRemoteEthAdr;  (*aktuální nastavení*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 MAX_LENGHT_OF_WEB_USER_NAME : usint :=  10;
 HTTP_URI_SIZE : usint :=  65;

END_VAR

TYPE T_SESSION_STATE : 
  (SESSION_EMPTY,
   SESSION_LOGIN,
   SESSION_LOGIN_RUN,
   SESSION_ACTIVE,
   SESSION_LOGOUT 
  );
END_TYPE

TYPE TWebServerAccess :
  STRUCT
    state            : T_SESSION_STATE;  (*stav pøihlášení*)
    user             : string [10];  (*jméno uivatele*)
    level            : usint;  (*úroveò pøihlášení*)
    error            : usint;  (*kód chyby*)
    IP               : TIPadr;  (*IP adresa uivatele*)
    lastFile         : string [65];  (*název posledního poadovaného souboru*)
  END_STRUCT;
END_TYPE

TYPE  TWebServerAccessTable : ARRAY [0..7] OF TWebServerAccess;  (*pøístupová tabulka web serveru PLC*)
END_TYPE

__DECL FUNCTION GetWebServerAccess : bool
(*Vrací informace o pøístupech k web serveru PLC*)
  VAR_IN_OUT
    accessTable      : TWebServerAccessTable;
  END_VAR
END_FUNCTION

__DECL FUNCTION SetRTS : bool
(*Nastavit signál RTS (pro sériovı kanál)
   Funkce vrací TRUE pokud se podaøilo signál nastavit,
   v opaèném pøípadì vrací FALSE
   !!! Reim øízení signálu RTS musí bıt v HW konfiguraci
   nastaven na volbu "podle SIGN.1"*)
  VAR_INPUT
    chanCode         : uint;  (*kód kanálu (CH1_uni, ..., CH10_uni)*)
    value            : bool;  (*hodnota RTS*)
  END_VAR
  VAR
    pUniOut          : PTR_TO TUni_OUT;
  END_VAR
END_FUNCTION

__DECL FUNCTION GetRTS : bool
(*Testovat stav signálu RTS (pro sériovı kanál)
   Funkce vrací stav signál RTS*)
  VAR_INPUT
    chanCode         : uint;  (*kód kanálu (CH1_uni, ..., CH10_uni)*)
  END_VAR
  VAR
    pUniOut          : PTR_TO TUni_OUT;
  END_VAR
END_FUNCTION

__DECL FUNCTION MACADR_TO_STRING : string [18]
(*Pøevod MAC adresy na textovı øetìzec*)
  VAR_INPUT
    macAdr           : TMacAdr;  (*pole s MAC adresou*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbSendTo
(*Vysílání dat komunikaèním kanálem

   Funkèní blok vysílá obsah pole data[] komunikaèním kanálem,
   kterı je specifikován promìnnou chanCode. Poèet vysílanıch
   bytù urèuje promìnná lenTx.

   Funkèní blok vrací informace o stavu vysílání.
   Pokud pøi vysílání nedojde k chybì, vıstupní promìnná
   error je 0, jinak obsahuje kód chyby.*)
  VAR_INPUT
    rq               : bool;  (*ádost o vysílání*)
    chanCode         : uint;  (*kód kanálu (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH4_uni7)*)
    lenTx            : uint;  (*velikost zprávy (poèet bytù)*)
  END_VAR
  VAR_IN_OUT
    data             : TUni_BUFF;  (*buffer pro vysílanou zprávu*)
  END_VAR
  VAR_OUTPUT
    mesSent          : bool;  (*vysílání zprávy bylo zahájeno*)
    error            : usint;  (*chybovı kód*)
    lenData          : uint;  (*velikost skuteènì odvysílané zprávy*)
  END_VAR
  VAR
    pUniOut          : PTR_TO TUni_OUT;
    pUniIn           : PTR_TO TUni_IN;
    pUniOutData      : PTR_TO usint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRecvFrom
(*Pøíjem dat z komunikaèního kanálu

   Funkèní blok pøijímá data z komunikaèního kanálu,
   kterı je specifikován promìnnou chanCode.
   Pøijatá data jsou uloena do pole data[].
   Délku pøijatıch dat udává promìnná lenData.

   Funkèní blok vrací informace o stavu pøíjmu.
   Pokud pøi pøíjmu nedojde k chybì, vıstupní promìnná
   error je 0, jinak obsahuje kód chyby.*)
  VAR_INPUT
    rq               : bool;  (*ádost o pøíjem*)
    chanCode         : uint;  (*kód kanálu (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH4_uni7)*)
    lenRx            : uint;  (*max. moná délka pøijatıch dat*)
  END_VAR
  VAR_IN_OUT
    data             : TUni_BUFF;  (*buffer pro pøijatou zprávu*)
  END_VAR
  VAR_OUTPUT
    mesRec           : bool;  (*pøíznak novì pøijaté zprávy*)
    error            : usint;  (*chybovı kód*)
    lenData          : uint;  (*velikost skuteènì pøijaté zprávy (poèet bytù)*)
  END_VAR
  VAR
    pUniIn           : PTR_TO TUni_IN;
    pUniInData       : PTR_TO usint;
    oldARC           : bool;  (*ARRAY[0..39] OF BOOL;*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRecvTxt
(*Pøijímá data z komunikaèního kanálu konèící znaky CR LF*)
  VAR_INPUT
    getMes           : bool;  (*Vybere zprávu z bufferu*)
    reset            : bool;  (*Vymae buffer*)
    chanCode         : uint;  (*Kód kanálu (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH4_uni7)*)
    lenBuf           : uint;  (*Délka pracovniho bufferu*)
    lenTxt           : uint;  (*Délka txtMes*)
  END_VAR
  VAR_OUTPUT
    full             : bool;  (*Buffer je plnı, zprávy nebyly odebírány dostateènì rychle*)
    lenMes           : uint;  (*Délka pøijatého textu*)
    error            : usint;  (*chybovı kód*)
  END_VAR
  VAR
    actPos           : uint;
    RecvFrom         : fbRecvFrom;
  END_VAR
  VAR_IN_OUT
    buffer           : usint;  (*První byte pracovniho bufferu*)
    txtMes           : usint;  (*První znak pøijatého textu*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRecvTxtChar
(*Pøijímá data z komunikaèního kanálu konèící znakem uvedenım na vstupu 'delimiter'*)
  VAR_INPUT
    getMes           : bool;  (*Vybere zprávu z bufferu*)
    reset            : bool;  (*Vymae buffer*)
    chanCode         : uint;  (*Kód kanálu (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH4_uni7)*)
    lenBuf           : uint;  (*Délka pracovniho bufferu*)
    lenTxt           : uint;  (*Délka txtMes*)
    delimiter        : byte;  (*oddìlovací znak*)
  END_VAR
  VAR_OUTPUT
    full             : bool;  (*Buffer je plnı, zprávy nebyly odebírány dostateènì rychle*)
    lenMes           : uint;  (*Délka pøijatého textu*)
    error            : usint;  (*chybovı kód*)
  END_VAR
  VAR
    actPos           : uint;
    RecvFrom         : fbRecvFrom;
  END_VAR
  VAR_IN_OUT
    buffer           : usint;  (*První byte pracovniho bufferu*)
    txtMes           : usint;  (*První znak pøijatého textu*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION GetIPaddress : bool
(*Test aktuální IP adresy

   Funkce zjišuje aktuálnì nastavenou IP adresu,
   masku sítì a adresu brány pro zadanı kanál.

   Funkce vrací TRUE, pokud se adresy podaøí zjistit.
   Zjištené hodnoty jsou uloeny do promìnné ethAdr.*)
  VAR_INPUT
    ethChan          : usint;  (*èíslo Ethernet kanálu (ETH1, ETH2, ETH3)*)
  END_VAR
  VAR_IN_OUT
    ethAdr           : TLocalEthAdr;  (*aktuální IP adresa, maska a adresa brány sítì*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetIPaddress : bool
(*Nastavení vlastní IP adresy

   Funkce nastavuje novou IP adresu, masku sítì
   a adresu brány pro zadanı kanál.

   Funkce vrací TRUE, pokud se podaøí nastavit nové hodnoty.*)
  VAR_INPUT
    rq               : bool;  (*ádost o nastavení novıch hodnot*)
    ethChan          : usint;  (*èíslo Ethernet kanálu (ETH1, ETH2, ETH3)*)
  END_VAR
  VAR_IN_OUT
    ethAdr           : TLocalEthAdr;  (*nová IP adresa, maska sítì a adresa brány*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetMACaddress : bool
(*Test MAC adresy

   Funkce zjišuje MAC adresu zadaného Ethernet kanálu.

   Funkce vrací TRUE, pokud se MAC adresu podaøí zjistit.
   MAC adresa je uloena v promìnné MacAdr.*)
  VAR_INPUT
    ethChan          : usint;  (*èíslo Ethernet kanálu (ETH1, ETH2, ETH3)*)
  END_VAR
  VAR_IN_OUT
    MacAdr           : TMacAdr;  (*aktuální MAC adresa*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetDHCPsupport : bool
(*Zapnutí podpory pro DHCP

   Funkce zapne podporu DHCP.
   IP adresa bude pøidìlena DHCP serverem.

   Funkce vratí TRUE, pokud se podaøí zapnou podporu DHCP,
   jinak vrací FALSE.*)
  VAR_INPUT
    rq               : bool;  (*ádost o zapnutí podpory DHCP*)
    ethChan          : usint;  (*èíslo Ethernet kanálu (pouze ETH1)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetDNS_IP : TIPadr
(*Funkce vrací IP adresu DNS serveru*)
  VAR_INPUT
    ethChan          : usint;  (*èíslo Ethernet kanálu (pouze ETH1)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetDNS_IP : bool
(*Nastavení IP adresy DNS serveru

   Funkce vrátí TRUE, pokud se podaøí nastavit novou IP adresu DNS serveru,
   jinak vrací FALSE.*)
  VAR_INPUT
    rq               : bool;  (*ádost o nastavení nové IP adresy DNS serveru*)
    ethChan          : usint;  (*èíslo Ethernet kanálu (pouze ETH1)*)
    DNS_IP           : TIPadr;  (*IP adresa DNS serveru*)
  END_VAR
END_FUNCTION

__DECL FUNCTION STRING_TO_IPADR : TIPadr
(*Pøevod textového øetìzce na IP adresu*)
  VAR_INPUT
    IPAdr            : string [80];  (*øetìzec s IP adresou*)
  END_VAR
END_FUNCTION

__DECL FUNCTION IPADR_TO_STRING : string
  VAR_INPUT
    IPAdr            : TIPadr;  (*pole s IP adresou*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbKeepAliveTCP
(*Udrovat TCP spojení

   Pokud je navázané TCP spojení
   a nejsou ádná data pro vysílání,
   tak funkèní blok odesílá v zadanıch
   intervalech ACK pakety pro udrení spojení.

   Funkce vrací 0, pokud pokud je vše v poøádku.
   Jinak funkce vrací chybovı kód.*)
  VAR_INPUT
    rq               : bool;  (*ádost o udrování spojení*)
    chanCode         : uint;  (*kód kanálu (ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
    PT               : time;  (*interval odesílání udrovacích paketù (T#5s...T#60s)*)
  END_VAR
  VAR_OUTPUT
    error            : usint;  (*chybovı kód*)
  END_VAR
  VAR
    tick             : fbTick;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION CheckGatewayIP : bool
(*Zkontroluje, jestli je dobøe nastavená IP adresa brány sítì v PLC*)
  VAR_INPUT
    ethChan          : usint;  (*èíslo Ethernet kanálu (ETH1, ETH2, ETH3)*)
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\FILELIB_V22_20160316.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : C:\TecoLib\FileLib_V22_20160316.mlb *)
(* Knihovna : FileLib 2.2 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c) Teco a.s. *)
(* Verze IEC pøekladaèe : 3.11.3.0 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : FileLib 2.2  }
(* Historie: *)
(*
v1.0            nem   první verze
v1.1            nem   pøidaná funkce DiskInfo()
v1.2            nem   pøidaná funkce FindFreeCluster() a funkèní blok CreatePath()
                      funkce FindFreeCluster() pouita v CreatePath() a WriteFile()
v1.3            nem   nulování idle time ve WriteToFile() kdy busy je FALSE
                      pøidán funkèní blok WriteDbxToFile()
                      pøidán funkèní blok ReadDbxFromFile()
v1.4            nem   opraven help funkce DirCreate()
v1.5            nem   obráceno poøadí parametrù u FileOpen()   
                      pøidán funkèní blok WriteToFileSeq ()
v1.6            nem   automatické zvıšení doby cyklu ve funkcích 
                      DirCreate() a FileClose()
                      (u nìkterıch typù SD karet mùe tato operace trvat delší dobu)
v1.7 26.10.2010 nem   pøidány závislosti na knihovnách
v1.8 14.06.2011 nem   pøidána funkce FileInfo()
v1.9 11.12.2012 nem   pøidány funkce CloseAllFiles() a OpenFilesCount()
                      (potøebná verze FW je v7.5)
                      zdokonalen test konce souboru ve funkèním bloku 
                      ReadFromFile() a ReadDbxFromFile() 
v2.0 03.12.2013 nem   pøidán funkèní blok DeleteDirectories()
v2.1 02.10.2015 byd   pøidán funkèní blok ReadLine()
v2.2 16.03.2016 byd   upraveny bloky WriteToFile() a WriteDbxToFile() -
                      pøed otevøením nového souboru je uzavøen aktuálnì
                      otevøenı soubor (pokud existuje)
*)

(*----------------------------------------------------------------------------*)

TYPE  HANDLE : udint;  (*identifikátor souboru*)
END_TYPE

TYPE TDirStack :
  STRUCT
    hDir             : HANDLE;
    sDir             : string [12];
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 INVALID_HANDLE_VALUE : HANDLE :=  0;  (*neplatná hodnota identifikátoru*)
 MAX_PATH : uint :=  65;  (*max velikost cesty (poèet bytù)*)
 MAX_COUNT_OPEN_FILES : uint :=  16;  (*max poèet souèasnì otevøenıch souborù*)
 DIR_STACK_MAX_LEVEL : usint :=  4;  (*max hloubka vnoøení adresáøù pro mazání*)

END_VAR

TYPE TFileInfo :
  STRUCT
    creationTime     : dt;  (*èas vytvoøení souboru*)
    modifyTime       : dt;  (*èas poslední modifikace*)
    fileSize         : udint;  (*velikost souboru (poèet bytù)*)
    attrib           : dword;  (*atributy souboru*)
    fileName         : string [80];  (*jméno souboru*)
    empty {HIDDEN}   : byte;
  END_STRUCT;
END_TYPE

TYPE TDiskInfo :
  STRUCT
    TotalNumberOfKBytes : udint;  (*velikost disku (poèet kilobytù)*)
    TotalNumberOfFreeKBytes : udint;  (*volné místo na disku (poèet kilobytù)*)
  END_STRUCT;
END_TYPE

TYPE TF_MODE : 
  (F_READ,
   F_WRITE,
   F_APPEND,
   F_READ_PLUS 
  );
END_TYPE

__DECL FUNCTION FileOpen : HANDLE
(*Otevøení souboru

   Funkce FileOpen inicializuje datové struktury potøebné pro ètení
   nebo zápis do souboru.
   Vstupní parametry jsou jméno souboru a zpùsob pøístupu k souboru.
   Dostupné pøístupy k souboru jsou :
   F_READ   Otevøe soubor pro ètení. Operace skonèí s chybou, pokud
            soubor neexistuje nebo pokud nejsou dostateèná práva
            pro pøístup k souboru.
   F_WRITE  Otevøe soubor pro zápis. Zápis bude probíhat od zaèátku souboru.
            Tato operace vdy zaloí novı soubor. Pokud soubor zadaného jména
            existuje, jeho obsah je smazán.
   F_APPEND Otevøe soubor pro zápis. Data budou zapsána na konec souboru.
            Pokud soubor neexistuje, tak bude zaloen novı soubor.
            Pokud se soubor otevøe tímto zpùsobem, tak nelze pouít
            funkci FileSetPos - data budou vdy pøipojena na konec souboru.

   Funkce vrací identifikátor otevøeného souboru. Pokud se soubor nepodaøí
   otevøít je vrácen neplatnı identifikátor ( INVALID_HANDLE_VALUE)*)
  VAR_INPUT
    mode             : TF_MODE;  (*zpùsob pøístupu k souboru (F_READ / F_WRITE / F_APPEND)*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*jméno souboru (vèetnì cesty)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileClose : bool
(*Zavøení souboru

   Funkce uzavøe soubor se zadanım identifikátorem,
   pokud je tento otevøen.
   
   Funkce vrací TRUE pokud je soubor úspìšnì uzavøen,
   FALSE v ostatních pøípadech*)
  VAR_INPUT
    hFile            : HANDLE;  (*identifikátor souboru*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileDelete : bool
(*Vymazání souboru

   Funkce smae soubor soubor zadaného jména.
   Tuto funkci lze pouít i pro smazání adresáøe.
   Pro úspìšné smazání adresáøe je nezbytné,
   aby byl adresáø prázdnı.

   Funkce vrací TRUE pokud je soubor/adresáø smazán,
   FALSE v ostatních pøípadech*)
  VAR_IN_OUT
    fileName         : string [80];  (*jméno souboru (vèetnì cesty)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileRead : udint
(*Ètení souboru

   Funkce zkopíruje zadanı poèet znakù ze souboru do promìnné v pamìti PLC.
   Funkce mùe zkopírovat i menší poèet znakù ne je poadováno v pøípadì,
   e dojde k chybì pøi ètení souboru nebo je dosaeno konce souboru.
   Funkce posouvá aktuální pozici pro ètení/zápis do souboru podle
   pozice naposledy pøeèteného znaku.
   
   Funkce vrací skuteènı poèet úspìšnì naètenıch znakù.*)
  VAR_INPUT
    hFile            : HANDLE;  (*identifikátor souboru*)
    adrBuf           : udint;  (*adresa promìnné, do které budou zkopírovaná data ze souboru*)
    size             : udint;  (*délka ètenıch dat (poèet bytù)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileWrite : udint
(*Zápis do souboru

   Funkce zkopíruje zadanı poèet znakù z promìnné v pamìti PLC do souboru.
   Funkce mùe zkopírovat i menší ne zadanı poèet znakù, pokud dojde
   k chybì pøi zápisu do souboru.
   Funkce posouvá aktuální pozici pro ètení/zápis do souboru podle
   pozice naposledy zapsaného znaku.

   Funkce vrací skuteènı poèet úspìšnì zapsanıch znakù*)
  VAR_INPUT
    hFile            : HANDLE;  (*identifikátor souboru*)
    adrBuf           : udint;  (*adresa promìnné, ze které budou zkopírovaná data do souboru*)
    size             : udint;  (*délka zapisovanıch dat (poèet bytù)*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 BEGIN_POS : udint :=  0;  (*pozice na zaèátku souboru*)
 END_POS : udint :=  16#FFFF_FFFF;  (*pozice na konci souboru*)

END_VAR

__DECL FUNCTION FileSetPos : bool
(*Nastavit pozici v souboru

   Funkce umoòuje nastavit pozici pro ètení resp. pro zápis do souboru.
   Pozice je offset dat od zaèátku souboru.
   Pro nastavení pozice na zaèátek souboru lze pouít konstantu BEGIN_POS.
   Pro nastavení pozice na konec souboru lze pouít konstantu END_POS.
   
   Funkce vrací TRUE, pokud se podaøí nastavit ádanou pozici v souboru.
   Jinak vrací FALSE.*)
  VAR_INPUT
    hFile            : HANDLE;  (*identifikátor souboru*)
    offset           : udint;  (*pozice v souboru*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileExists : bool
(*Test existence souboru

   Funkce zjistí zda existuje soubor nebo adresáø zadaného jména.
   
   Funkce vrátí TRUE pokud soubor resp. adresáø existuje,
   FALSE v ostatních pøípadech*)
  VAR_IN_OUT
    fileName         : string [80];  (*jméno souboru (vèetnì cesty)*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 UNKNOWN_SIZE : udint :=  16#FFFF_FFFF;  (*neznámá velikost*)

END_VAR

__DECL FUNCTION FileSize : udint
(*Zjistit velikost souboru

   Funkce FileSize zjistí velikost souboru
   
   Funkce vrací aktuální velikost souboru.
   Pøi chybì vrací UKNOWN_SIZE, tj. 16#FFFF_FFFF*)
  VAR_INPUT
    hFile            : HANDLE;  (*identifikátor souboru*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirOpen : HANDLE
(*Otevøení adresáøe

   Funkce otevøe adresáø zadaného jména.
   Poté zjistí informace o prvním souboru v adresáøi
   a tyto informace zapíše do promìnné dirInfo.
   Informace o dalších souborech v adresáøi lze zjistit funkcí DirRead.
   
   Funkce vrací identifikátor otevøeného adresáøe.
   Pokud se adresáø nepodaøí otevøít je vrácen neplatnı identifikátor
   (INVALID_HANDLE_VALUE)*)
  VAR_IN_OUT
    dirName          : string [80];  (*jméno adresáøe (vèetnì cesty)*)
    dirInfo          : TFileInfo;  (*struktura s informacemi o prvním souboru v adresáøi*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirClose : bool
(*Uzavøení adresáøe

   Funkce uzavøe adresáø.
   
   Funkce vrací TRUE pokud je adresáø úspìšnì uzavøen,
   FALSE v ostatních pøípadech*)
  VAR_INPUT
    hDir             : HANDLE;  (*identifikátor souboru*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirRead : bool
(*Ètení z adresáøe

   Funkce zjistí informace o dalším souboru v adresáøi
   a tyto informace zapíše do promìnné dirInfo.
   Pøed voláním této funkce musí bıt adresáø otevøen funkcí DirOpen.

   Funkce vrací TRUE pokud operace dopadne úspìšnì,
   FALSE v ostatních pøípadech*)
  VAR_INPUT
    hDir             : HANDLE;  (*identifikátor souboru*)
  END_VAR
  VAR_IN_OUT
    dirInfo          : TFileInfo;  (*struktura s informacemi o dalším souboru v adresáøi*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirCreate : bool
(*Vytvoøení adresáøe

   Funkce vytvoøí adresáø zadaného jména.
   
   Funkce vrací TRUE pokud je adresáø úspìšnì vytvoøen,
   FALSE v ostatních pøípadech*)
  VAR_IN_OUT
    dirName          : string [80];  (*jméno adresáøe (vèetnì cesty)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirDelete : bool
(*Vymazání adresáøe

   Funkce smae adresáø zadaného jména.
   Pro úspìšné smazání adresáøe je nezbytné,
   aby byl adresáø prázdnı (aby neobsahoval ádné soubory).
   
   Funkce vrací TRUE pokud je adresáø smazán,
   FALSE v ostatních pøípadech*)
  VAR_IN_OUT
    dirName          : string [80];  (*jméno adresáøe (vèetnì cesty)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetLastErr : udint
(*Zjistit kód poslední chyby

   Funkce vrátí kód poslední zaznamenané chyby vzniklé
   pøi souborové operaci. Tento kód mùe bıt pouit jako
   parametr funkce GetLastErrTxt, která pak vrátí textovı popis chyby

   Funkce vrátí kód poslední chyby pøi souborové operaci*)
END_FUNCTION

__DECL FUNCTION GetLastErrTxt : bool
(*Popis
   Funkce zapíše textovı popis chyby do promìnné errMessage.
   Textovı popis chyby odpovídá kódu chyby,
   kterı je specifikován promìnnou errCode.

   Návratová hodnota
   Funkce vrací Vrací TRUE, pokud existuje popis chyby,
   jinak vrací FALSE.*)
  VAR_INPUT
    errCode          : udint;  (*chybovı kód*)
  END_VAR
  VAR_IN_OUT
    errMessage       : string [80];  (*textovı popis chyby*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DiskInfo : bool
(*Zjistit informace o disku

   Funkce zjistí celkovou velikost disku a volné místo na disku
   
   Funkce vrací TRUE, pokud se podaøí zjistit informace
   o zadaném disku.V opaèném pøípadì vrací FALSE.
   Funkce DiskInfo naplní poloky TotalNumberOfKBytes
   a TotalNumberOfFreeKBytes v promìnné diskDesc.
   Obì hodnoty jsou v KiloBytech.*)
  VAR_IN_OUT
    diskName         : string [80];  (*název disku (prázdnı string pro default disk)*)
    diskDesc         : TDiskInfo;  (*informace o disku*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FindFreeCluster : byte
(*Najít volné místo na disku

   Funkce hledá volné místo na disku.
   Úèelem funkce je zrychlit následnı zápis dat do souboru.
   Tato funkce je vyuívána napø. funkèním blokem CreatePath.
   
   Funkce vrací 0 pokud je volné místo nalezeno
   nebo 13 pokud se v hledání má pokraèovat v pøíštím cyklu PLC
   nebo jiné èíslo pokud dojde k nìjaké chybì.*)
  VAR_IN_OUT
    fileName         : string [80];  (*jméno souboru (vèetnì cesty)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileInfo : bool
(*Zjistit informace o souboru

   Funkce zjistí následující informace o souboru :
   èas vytvoøení souboru, èas poslední modifikace,
   velikost souboru (poèet bytù) a atributy souboru
   Tyto informace zapíše do promìnné fileDesc.
   Funkce vrací TRUE pokud soubor existuje a informace
   se podaøilo zjistit, v ostatních pøípadech vrací FALSE*)
  VAR_IN_OUT
    fileName         : string [80];  (*jméno adresáøe (vèetnì cesty)*)
    fileDesc         : TFileInfo;  (*struktura s informacemi o souboru*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CloseAllFiles : bool
(*Uzavøení všech otevøenıch souborù

   Funkce uzavøe všechny aktuálnì otevøené soubory.
   Funkce vrací TRUE.*)
END_FUNCTION

__DECL FUNCTION OpenFilesCount : uint
(*Poèet aktuálnì otevøenıch souborù

   Funkce vrací poèet aktuálnì otevøenıch souborù*)
END_FUNCTION

__DECL FUNCTION_BLOCK ReadFromFile
(*Pøenos dat ze souboru do promìnné v PLC

   Funkèní blok pøeète data ze souboru a uloí je do promìnné v pamìti PLC
   
   Funkèní blok nastaví TRUE do promìnné done v okamiku,
   kdy se naète poslední blok dat ze souboru.
   Bìhem naèítání dat má promìnná done hodnotu FALSE
   a promìnná busy hodnotu TRUE.
   Poèet skuteènì naètenıch bytù udává promìnná actSize.
   Pokud bylo ètení bez chyby, promìnná err má hodnotu FALSE,
   v pøípadì chyby má hodnotu TRUE a v promìnné errID
   je uloen chybovı kód. Ten mùe bıt pouit jako
   vstupní promìnná funkce GetLastErrTxt pro získání
   textového popisu vzniklé chyby*)
  VAR_IN_OUT
    fileName         : string [80];  (*jméno souboru (vèetnì cesty)*)
    dstVar           : udint;  (*adresa promìnné, do které budou uloena data pøeètená ze souboru*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*ádost o ètení = nábìná hrana zahájí ètení ze souboru*)
    seek             : udint;  (*offset od zaèátku souboru, od kterého je ètení zahájeno*)
    size             : udint;  (*Poadovaná velikost ètenıch dat (poèet bytù)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*ètení ze souboru je ukonèeno*)
    busy             : bool;  (*probíhá ètení ze souboru*)
    err              : bool;  (*pøíznak chyby pøi ètení ze souboru*)
    errID            : udint;  (*chybovı kód (0 = bez chyby)*)
    actSize          : udint;  (*poèet skuteènì naètenıch bytù*)
  END_VAR
  VAR
    execTrig         : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK WriteToFile
(*Pøenos dat z promìnné v PLC do souboru

   Funkèní blok zapíše obsah promìnné PLC do souboru.
   
   Funkèní blok nastaví TRUE do promìnné done v okamiku,
   kdy se zapíše poslední blok dat do souboru.
   Bìhem zápisu dat má promìnná done hodnotu FALSE
   a promìnná busy hodnotu TRUE.
   Poèet skuteènì zapsanıch bytù udává promìnná actSize.
   Pokud byl zápis do souboru bez chyby, promìnná err
   má hodnotu FALSE, v pøípadì chyby má hodnotu TRUE
   a v promìnné errID je uloen chybovı kód.
   Ten mùe bıt pouit jako vstupní promìnná funkce GetLastErrTxt
   pro získání textového popisu vzniklé chyby.*)
  VAR_IN_OUT
    fileName         : string [80];  (*jméno souboru (vèetnì cesty)*)
    srcVar           : udint;  (*adresa promìnné, její obsah bude zapsán souboru*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*ádost o zápis = nábìná hrana zahájí zápis do souboru*)
    seek             : udint;  (*offset v souboru, od kterého je zahájen zápis*)
    size             : udint;  (*velikost zapisovanıch dat (poèet bytù)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*zápis do souboru byl dokonèen*)
    busy             : bool;  (*probíhá zápis do souboru*)
    err              : bool;  (*pøíznak chyby pøi zápisu do souboru*)
    errID            : udint;  (*chybovı kód (0 = bez chyby)*)
    actSize          : udint;  (*poèet skuteènì zapsanıch bytù*)
  END_VAR
  VAR
    eTrig            : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
    idle             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK CreatePath
(*Zaloit adresáø (vèetnì cesty)

   Funkèní blok zkontroluje zadanou cestu a pokud neexistuje,
   tak ji na disku vytvoøí (zaloí potøebné adresáøe).
   Jméno cesty udává promìnná fileName.
   Kontrola bude zahájena na nábìnou hranu promìnné exec.

   Funkèní blok nastaví TRUE do promìnné done v okamiku,
   kdy je zadaná cesta na disku dostupná.
   Bìhem kontroly resp. vytváøení cesty má promìnná done
   hodnotu FALSE a promìnná busy hodnotu TRUE.
   Pokud bìhem práce nebyla detekována ádná chyba
   promìnná err má hodnotu FALSE, v pøípadì chyby
   má hodnotu TRUE a v promìnné errID je uloen chybovı kód.
   Ten mùe bıt pouit jako vstupní promìnná funkce GetLastErrTxt
   pro získání textového popisu vzniklé chyby.*)
  VAR_INPUT
    exec             : bool;  (*ádost o vytvoøení cesty = nábìná hrana zahájí kontrolu resp. vytváøení cesty*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*jméno adresáøe vèetnì cesty (napø. WWW/NEW_DIR/)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*cesta byla vytvoøena*)
    busy             : bool;  (*probíhá vytváøení cesty*)
    err              : bool;  (*pøíznak chyby pøi vytváøení cesty*)
    errID            : udint;  (*chybovı kód (0 = bez chyby)*)
  END_VAR
  VAR
    eTrig            : R_TRIG;  (*rising edge of exec*)
    errTrig          : R_TRIG;  (*rising edge of err*)
    createDir        : bool;
    path             : string [80];
    copy             : string [80];
    idle             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK WriteDbxToFile
(*Pøenos dat z pamìti DataBox do souboru

   Funkèní blok zapíše obsah pamìti DataBox do souboru.
   Pokud soubor neexistuje, tak je vytvoøen.
   Pokud soubor existuje, jeho obsah je pøepsán.
   Funkèní blok je podporován na CPM øady K od verze 4.5.
   
   Funkèní blok nastaví TRUE do promìnné done v okamiku,
   kdy se zapíše poslední blok dat do souboru.
   Bìhem zápisu dat má promìnná done hodnotu FALSE
   a promìnná busy hodnotu TRUE.
   Poèet skuteènì zapsanıch bytù udává promìnná actSize.
   Pokud byl zápis do souboru bez chyby,
   promìnná err má hodnotu FALSE,
   v pøípadì chyby má hodnotu TRUE a v promìnné errID
   je uloen chybovı kód. Ten mùe bıt pouit jako
   vstupní promìnná funkce GetLastErrTxt pro získání
   textového popisu vzniklé chyby.*)
  VAR_IN_OUT
    fileName         : string [80];  (*jméno souboru (vèetnì cesty)*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*ádost o zápis = nábìná hrana zahájí zápis do souboru*)
    seek             : udint;  (*offset v souboru, od kterého je zahájen zápis*)
    srcAdr           : udint;  (*adresa v DataBoxu, kde zaèínají data, která budou uloena do souboru*)
    size             : udint;  (*velikost zapisovanıch dat (poèet bytù)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*dokonèen zápis do souboru*)
    busy             : bool;  (*probíhá zápis do souboru*)
    err              : bool;  (*pøíznak chyby pøi zápisu do souboru*)
    errID            : udint;  (*chybovı kód (0 = bez chyby)*)
    actSize          : udint;  (*poèet skuteènì zapsanıch bytù*)
  END_VAR
  VAR
    eTrig            : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
    idle             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK ReadDbxFromFile
(*Pøenos dat ze souboru do pamìti DataBox

   Funkèní blok pøeète data ze souboru a uloí je do pamìti DataBox.
   Funkèní blok je podporován na CPM øady K od verze 4.5.

   Funkèní blok nastaví TRUE do promìnné done v okamiku,
   kdy se naète poslední blok dat ze souboru.
   Bìhem naèítání dat má promìnná done hodnotu FALSE
   a promìnná busy hodnotu TRUE.
   Poèet skuteènì naètenıch bytù udává promìnná actSize.
   Pokud bylo ètení bez chyby, promìnná err má hodnotu FALSE,
   v pøípadì chyby má hodnotu TRUE a v promìnné errID je uloen
   chybovı kód. Ten mùe bıt pouit jako vstupní promìnná funkce
   GetLastErrTxt pro získání textového popisu vzniklé chyby.*)
  VAR_IN_OUT
    fileName         : string [80];  (*jméno souboru (vèetnì cesty)*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*ádost o ètení = nábìná hrana zahájí ètení ze souboru*)
    seek             : udint;  (*offset od zaèátku souboru, od kterého je zahájeno ètení*)
    dstAdr           : udint;  (*adresa DataBoxu, od které budou uloena data pøeètená ze souboru*)
    size             : udint;  (*velikost ètenıch dat (poèet bytù)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*ètení ze souboru je ukonèeno*)
    busy             : bool;  (*probíhá ètení ze souboru*)
    err              : bool;  (*pøíznak chyby pøi ètení ze souboru*)
    errID            : udint;  (**)
    actSize          : udint;  (*poèet skuteènì naètenıch bytù*)
  END_VAR
  VAR
    execTrig         : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK WriteToFileSeq
(*Sekvenèní zápis dat do souboru

   Funkèní blok zapíše obsah promìnné PLC do souboru pøi kadém volání,
   kdy je promìnná write nastavena na hodnotu TRUE.
   Data jsou zapisována sekvenènì za sebe, a do doby
   ne je soubor uzavøen nastavení vstupu close na hodnotu TRUE.

   Promìnné open signalizuje, e je otevøen soubor pro zápis
   a bude jej nutné pøi nebo po posledním zápisu nastavením
   vstupu close zavøít.
   Poèet všech zapsanıch bytù udává promìnná actSize.
   Pokud byl zápis do souboru bez chyby, promìnná err má hodnotu FALSE,
   v pøípadì chyby má hodnotu TRUE a v promìnné errID je uloen chybovı kód.
   Ten mùe bıt pouit jako vstupní promìnná funkce GetLastErrTxt
   pro získání textového popisu vzniklé chyby.*)
  VAR_IN_OUT
    fileName         : string [80];  (*jméno souboru (vèetnì cesty)*)
    srcVar           : udint;  (*adresa promìnné, její obsah bude zapsán souboru*)
  END_VAR
  VAR_INPUT
    write            : bool;  (*ádost o zápis do souboru*)
    close            : bool;  (*ádost o uzavøení souboru*)
    size             : udint;  (*velikost zapisovanıch dat (poèet bytù)*)
  END_VAR
  VAR_OUTPUT
    open             : bool;  (*soubor je aktuálnì otevøen pro zápis*)
    err              : bool;  (*pøíznak chyby pøi zápisu do souboru*)
    errID            : udint;  (*chybovı kód (0 = bez chyby)*)
    actSize          : udint;  (*aktuální velikost souboru (poèet bytù)*)
  END_VAR
  VAR
    errTrig          : R_TRIG;
    wrSize           : udint;
    hnd              : HANDLE;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK DeleteDirectories
(*Vymazat obsah adresáøe vèetnì obsahu vloenıch podadresáøù

   Smae všechny soubory v adresáøi.
   Max. poèet vnoøenıch podadresáøù = 4*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*ádost o smazání*)
  END_VAR
  VAR_IN_OUT
    dirName          : string [80];  (*jméno adresáøe (vèetnì cesty)*)
  END_VAR
  VAR
    dirStack         : ARRAY [0..4] OF TDirStack;
    CurrFile         : string [80];
    dirStackLev      : usint;
    i                : usint;
    lLocalFileInfo   : TFileInfo;
  END_VAR
  VAR_OUTPUT
    Done             : bool;
    Busy             : bool;
    Err              : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK ReadLine
(*Naète jeden øádek ze souboru
        Èíslo poadovaného øádku v souboru udává vstupní promìnná line.
        První øádek v souboru má èíslo 1.
        Poadovanı øádek je zapsán do promìnné txtLine vèetnì znakù CR a LF.
        Promìnná txtLine musí bıt typu STRING s délkou rovnou nebo vìtší ne maxLen.
        Hledání øádku v souboru mùe trvat více cyklù PLC.
        Bìhem hledání je vıstup busy nastaven na TRUE,
        pøi nalezení øádku se nastaví vıstup done na TRUE (na 1 cykl PLC).
        Pokud je øádek delší ne maxLen znakù, je nastaven vıstup lineContinues
        a øádek je pøedáván po èástech, kadı cykl jedna èást, poslední
        èást má vıstup lineContinues nastaven na FALSE
        (vıstup done je nastaven na TRUE u všech èástí dlouhého øádku).
        Pokud vznikne nìjaká chyba pøi ètení souboru je nastaven chybovı
        kód do vıstupu errID a promìnná errTxt obsahuje popis chyby.
        Funkèní blok ReadLine pøedpokládá, e øádky v souboru konèí znaky CRLF (16#0D,16#0A).*)
  VAR_INPUT
    line             : udint;  (*Èíslo ádaného øádku (1..n)*)
    maxLen           : udint;  (*Maximalní délka øádku*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*Jméno souboru i s cestou*)
    txtLine          : string [255];  (*Naètenı øádek ze souboru*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*Ètení ze souboru je ukonèeno*)
    busy             : bool;  (*Zaneprázdnìn ètením ze souboru*)
    err              : bool;  (*Pøíznak chyby*)
    lineContinues    : bool;  (*Øádek byl delší ne maximální délka a bude pokraèovat*)
    actLine          : udint;  (*Èíslo aktuálnì naèteného øádku*)
    errID            : udint;  (*Chybovı kód (0 = bez chyby)*)
    errTxt           : string [80];  (*Text poslední chyby*)
  END_VAR
  VAR
    lastLine         : udint;  (*cislo naposled hledaneho radku*)
    lastFile         : string [80];  (*jmeno souboru, se kterym se naposledy pracovalo*)
    actPos           : udint;  (*aktualni pozice v souboru (offset od zacatku)*)
    actSize          : udint;  (*pocet znaku nactenych ze souboru*)
    i                : int;
    index            : int;
    outidx           : uint;
    bufTxtReady      : bool;
    newFile          : bool;
    newFileTest      : bool;
    fileInf          : TFileInfo;  (*struktura s informacemi o souboru*)
    empty            : word;
    ReadFile         : ReadFromFile;
  END_VAR
  VAR CONSTANT
    SEPARATOR        : ARRAY [0..1] OF byte :=  [ 16#0A, 0];
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\TOSTRINGLIB_V13_20110203.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : c:\Program Files\Common Files\Mosaic\Lib\ToStringLib_V13_20110203.mlb *)
(* Knihovna : ToStringLib 1.3 *)
(* Autor : Teco a.s. Kolin *)
(* Autorská práva : (c) 2004..2009 Teco a.s. *)
(* Verze IEC pøekladaèe : 3.8.13.3 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : ToStringLib 1.3  }
(* Historie: *)
(*
v1.0 04.02.2009 Nem  úvodní verze knihovny 
v1.1 27.10.2010 Nem  doplnìny komentáøe v èestinì 
v1.2 06.12.2010 Nem  doplnìny anglické komentáøe
v1.3 03.02.2011 Nem  doplnìna funkce BOOL_TO_STRINGF
*)

(*----------------------------------------------------------------------------*)

__DECL FUNCTION USINT_TO_STRINGF : string
(*
  Pøevod USINT na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%4u'
*)
  VAR_INPUT
    in               : usint;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SINT_TO_STRINGF : string
(*
  Pøevod SINT na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%4d'
*)
  VAR_INPUT
    in               : sint;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION UINT_TO_STRINGF : string
(*
  Pøevod UINT na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%5u'
*)
  VAR_INPUT
    in               : uint;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION INT_TO_STRINGF : string
(*
  Pøevod INT na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%5d'
*)
  VAR_INPUT
    in               : int;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION UDINT_TO_STRINGF : string
(*
  Pøevod UDINT na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%6u'
*)
  VAR_INPUT
    in               : udint;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DINT_TO_STRINGF : string
(*
  Pøevod DINT na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%6d'
*)
  VAR_INPUT
    in               : dint;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION REAL_TO_STRINGF : string
(*
  Pøevod REAL na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%6.1f'
*)
  VAR_INPUT
    in               : real;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION LREAL_TO_STRINGF : string
(*
  Pøevod LREAL na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%6.1f'
*)
  VAR_INPUT
    in               : lreal;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION BYTE_TO_STRINGF : string
(*
  Pøevod BYTE na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%02X'
*)
  VAR_INPUT
    in               : byte;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION WORD_TO_STRINGF : string
(*
  Pøevod WORD na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%04X'
*)
  VAR_INPUT
    in               : word;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DWORD_TO_STRINGF : string
(*
  Pøevod DWORD na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%08X'
*)
  VAR_INPUT
    in               : dword;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DATE_TO_STRINGF : string
(*
  Pøevod DATE na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%TYYYY-MM-DD'
*)
  VAR_INPUT
    in               : date;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DT_TO_STRINGF : string
(*
  Pøevod DATE_AND_TIME na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%TYYYY-MM-DD-hh:mm:ss'
*)
  VAR_INPUT
    in               : dt;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION TIME_TO_STRINGF : string
(*
  Pøevod TIME na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%Thh:mm:ss.zzz'
*)
  VAR_INPUT
    in               : time;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION TOD_TO_STRINGF : string
(*
  Pøevod TIME_OF_DAY na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%Thh:mm:ss.zzz'
*)
  VAR_INPUT
    in               : tod;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION

__DECL FUNCTION BOOL_TO_STRINGF : string
(*
  Pøevod BOOL na formátovanı STRING
  Pøíklad formátovacího øetìzce : '%b'
*)
  VAR_INPUT
    in               : bool;
    format           : string [80];  (* formátovací øetìzec*)
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\TIMELIB_V15_20170216.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : D:\TecoUserLibs\TimeLib_V15_20170216.mlb *)
(* Knihovna : TimeLib 1.5 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c) 2010 - 2017 Teco a.s. *)
(* Verze IEC pøekladaèe : 3.12.10.2 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : TimeLib 1.5  }
(* Historie: *)
(*
v1.0 18.11.2010 Nem Úvodni verze knihovny
v1.1 20.01.2011 Nem Oprava fce Year_of_DT()
v1.2 10.06.2011 Nem Pøidaná funkce GetDateAndTime_RFC2822()
v1.3 30.11.2012 Nem Pøidané funkce WeekNumber() a TIME_TO_REALsec()
v1.4 24.07.2013 Byd Pøidány funkce pro LONG_TIME
v1.5 16.02.2017 Byd Upravena funkce GetDateAndTime_RFC2822() pro záporné posuny èasového pásma
*)

(*----------------------------------------------------------------------------*)

TYPE LONGTIME :
  STRUCT  (*Typ pro popis dlouhıch èasovıch úsekù*)
    Days             : dint;  (*Poèet dnù*)
    TimeOfDay        : time;  (*Èas ve dni*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION DATE_OF_DT : date
(*Vrací datum z promìnné DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION TIME_OF_DT : time
(*Vrací èas z promìnné DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION YEAR_OF_DT : uint
(*Vrací rok z promìnné DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Vstupní promìnná*)
  END_VAR
  VAR
    s                : string [30];
  END_VAR
END_FUNCTION

__DECL FUNCTION MONTH_OF_DT : usint
(*Vrací mìsíc z promìnné DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DAY_OF_DT : usint
(*Vrací den z promìnné DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION HOUR_OF_DT : usint
(*Vrací hodiny z promìnné DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MIN_OF_DT : usint
(*Vrací minuty z promìnné DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SEC_OF_DT : usint
(*Vrací sekundy z promìnné DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MSEC_OF_DT : uint
(*Vrací milisekundy z promìnné DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CutMSec_From_DT : dt
(*Odøízne milisekundy z promìnné DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CutSec_From_DT : dt
(*Odøízne sekundy z promìnné DATE_AND_TIME*)
  VAR_INPUT
    in               : dt;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION YEAR_OF_DATE : uint
(*Vrací rok z promìnné DATE*)
  VAR_INPUT
    in               : date;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MONTH_OF_DATE : usint
(*Vrací mìsíc z promìnné DATE*)
  VAR_INPUT
    in               : date;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DAY_OF_DATE : usint
(*Vrací den z promìnné DATE*)
  VAR_INPUT
    in               : date;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DAY_OF_YEAR : uint
(*Vrací den v roce z promìnné DATE*)
  VAR_INPUT
    in               : date;  (*Vstupní promìnná*)
  END_VAR
  VAR
    year             : uint;
    tmp              : string [80];
    yearD            : date;
    secOfYear        : lreal;
  END_VAR
END_FUNCTION

__DECL FUNCTION HOUR_OF_TIME : usint
(*Vrací hodiny z promìnné TIME*)
  VAR_INPUT
    in               : time;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MIN_OF_TIME : usint
(*Vrací minuty z promìnné TIME*)
  VAR_INPUT
    in               : time;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SEC_OF_TIME : usint
(*Vrací sekundy z promìnné TIME*)
  VAR_INPUT
    in               : time;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MSEC_OF_TIME : uint
(*Vrací milisekundy z promìnné TIME*)
  VAR_INPUT
    in               : time;  (*Vstupní promìnná*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DecodeTime : bool
(*Pøevede TIME na hodiny, minuty, sekundy a milisekundy*)
  VAR_INPUT
    in               : time;  (*Vstupní promìnná*)
  END_VAR
  VAR_IN_OUT
    H                : usint;  (*Hodiny*)
    M                : usint;  (*Minuty*)
    S                : usint;  (*Sekundy*)
    Ms               : uint;  (*Milisekundy*)
  END_VAR
END_FUNCTION

__DECL FUNCTION EncodeTime : time
(*Pøevede hodiny, minuty, sekundy a milisekundy na TIME*)
  VAR_INPUT
    H                : usint;  (*Hodiny*)
    M                : usint;  (*Minuty*)
    S                : usint;  (*Sekundy*)
    Ms               : uint;  (*Milisekundy*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MUL_TIME_REAL : time
(*Vrací vısledek násobení èasu IN1, èíslem IN2*)
  VAR_INPUT
    IN1              : time;  (*Èase k vynásobení*)
    IN2              : real;  (*Násobitel*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MUL_TIME_LREAL : time
(*Vrací vısledek násobení èasu IN1, èíslem IN2*)
  VAR_INPUT
    IN1              : time;  (*Èase k vynásobení*)
    IN2              : lreal;  (*Násobitel*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DIV_TIME_REAL : time
(*Vrací vısledek dìlení èasu IN1, èíslem IN2*)
  VAR_INPUT
    IN1              : time;  (*Èase k vydìlení*)
    IN2              : real;  (*Dìlitel*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DIV_TIME_LREAL : time
(*Vrací vısledek dìlení èasu IN1, èíslem IN2*)
  VAR_INPUT
    IN1              : time;  (*Èase k vydìlení*)
    IN2              : lreal;  (*Dìlitel*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 MonthsNamesRFC2822 : ARRAY [1..12] OF string [3] :=   ['Jan', 'Feb', 'Mar', 'Apr',
                                                       'May', 'Jun', 'Jul', 'Aug',
                                                       'Sep', 'Oct', 'Nov', 'Dec'];

END_VAR

__DECL FUNCTION GetDateAndTime_RFC2822 : string [26]
(*vrací datum a èas dle RFC2822

  datum èas

  datum           =       den mìsíc rok
  rok             =       4 èísla
  mìsíc           =       jméno-mìsíce
  jméno-mìsíce    =       "Jan" / "Feb" / "Mar" / "Apr" /
                          "May" / "Jun" / "Jul" / "Aug" /
                          "Sep" / "Oct" / "Nov" / "Dec"
  den             =       1-2 èísla
  èas             =       èas-ve-dni zóna
  èas-ve-dni      =       hodina ":" minuta ":" sekunda
  hodina          =       2 èísla
  minuta          =       2 èísla
  sekunda         =       2 èísla
  zóna            =       (( "+" / "-" ) 4 èísla)*)
  VAR_INPUT
    UtcOff           : int;  (*Posun èasového pásma v minutách*)
  END_VAR
  VAR
    Format           : string [80];
  END_VAR
END_FUNCTION

__DECL FUNCTION WeekNumber : usint
(*Èísla tıdnù podle ISO-8601, tıdny zaèínají pondìlím*)
  VAR_INPUT
    IN               : dt;  (*Èas ke kterému se vypoète èíslo tıdnu*)
  END_VAR
END_FUNCTION

__DECL FUNCTION TIME_TO_REALsec : real
(*Pøevod èasu na sekundy*)
  VAR_INPUT
    IN               : time;  (*Èas*)
  END_VAR
END_FUNCTION

__DECL FUNCTION LONGTIME_TO_LREAL : lreal
(*Pøevod typu LONGTIME na sekundy*)
  VAR_INPUT
    IN               : LONGTIME;
  END_VAR
END_FUNCTION

__DECL FUNCTION LREAL_TO_LONGTIME : LONGTIME
(*Pøevod sekund na typ LONGTIME*)
  VAR_INPUT
    IN               : lreal;
  END_VAR
END_FUNCTION

__DECL FUNCTION ADD_DT_LONGTIME : dt
(*Vrací souèet IN1 a IN2 jako DATE_AND_TIME*)
  VAR_INPUT
    IN1              : dt;  (*První èas k seètení*)
    IN2              : LONGTIME;  (*Druhı èas k seètení*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ADD_LONGTIME : LONGTIME
(*Vrací souèet IN1 a IN2 jako LONGTIME*)
  VAR_INPUT
    IN1              : LONGTIME;  (*První èas k seètení*)
    IN2              : LONGTIME;
  END_VAR
END_FUNCTION

__DECL FUNCTION ADD_LONGTIME_TIME : LONGTIME
(*LONGTIME := LONGTIME + TIME;*)
  VAR_INPUT
    IN1              : LONGTIME;  (*První èas k seètení*)
    IN2              : time;  (*Druhı èas k seètení*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DIV_LONGTIME : LONGTIME
(*Vrací vısledek dìlení èasu IN1, èíslem IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*Èase k vydìlení*)
    IN2              : real;  (*Dìlitel*)
  END_VAR
END_FUNCTION

__DECL FUNCTION EQ_LONGTIME : bool
(*Rovnost, vrací TRUE, kdy IN1 = IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*První èas k porovnání*)
    IN2              : LONGTIME;  (*Druhı èas k porovnání*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GE_LONGTIME : bool
(*Vìtší ne nebo rovno, vrací TRUE, kdy IN1 >= IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*První èas k porovnání*)
    IN2              : LONGTIME;  (*Druhı èas k porovnání*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GT_LONGTIME : bool
(*Vìtší ne, vrací TRUE, kdy IN1 > IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*První èas k porovnání*)
    IN2              : LONGTIME;  (*Druhı èas k porovnání*)
  END_VAR
END_FUNCTION

__DECL FUNCTION LE_LONGTIME : bool
(*Menší ne nebo rovno, vrací TRUE, kdy IN1 <= IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*První èas k porovnání*)
    IN2              : LONGTIME;  (*Druhı èas k porovnání*)
  END_VAR
END_FUNCTION

__DECL FUNCTION LT_LONGTIME : bool
(*Menší ne, vrací TRUE, kdy IN1 < IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*První èas k porovnání*)
    IN2              : LONGTIME;  (*Druhı èas k porovnání*)
  END_VAR
END_FUNCTION

__DECL FUNCTION MUL_LONGTIME : LONGTIME
(*Vrací vısledek násobení èasu IN1, èíslem IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*Èase k vynásobení*)
    IN2              : real;  (*Násobitel*)
  END_VAR
END_FUNCTION

__DECL FUNCTION NE_LONGTIME : bool
(*Nerovnost, vrací TRUE, kdy IN1 <> IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*První èas k porovnání*)
    IN2              : LONGTIME;  (*Druhı èas k porovnání*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DATE_DATE_LONG : LONGTIME
(*Vrací rozdíl IN1 a IN2 jako LONGTIME*)
  VAR_INPUT
    IN1              : date;  (*Datum od kterého se odeèítá*)
    IN2              : date;  (*Datum které se odeèítá*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DT_DT_LONG : LONGTIME
(*Vrací rozdíl IN1 a IN2 jako LONGTIME*)
  VAR_INPUT
    IN1              : dt;  (*Datum a èas od kterého se odeèítá*)
    IN2              : dt;  (*Datum a èas kterı se odeèítá*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_DT_LONGTIME : dt
(*Vrací rozdíl IN1 a IN2 jako LONGTIME*)
  VAR_INPUT
    IN1              : dt;  (*Datum a èas od kterého se odeèítá*)
    IN2              : LONGTIME;  (*Èas kterı se odeèítá*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_LONGTIME : LONGTIME
(*Vrací rozdíl IN1 a IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*Èas od kterého se odeèítá*)
    IN2              : LONGTIME;  (*Èas kterı se odeèítá*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SUB_LONGTIME_TIME : LONGTIME
(*Vrací rozdíl IN1 a IN2*)
  VAR_INPUT
    IN1              : LONGTIME;  (*Èas od kterého se odeèítá*)
    IN2              : time;  (*Èas kterı se odeèítá*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK AbsoluteTON
(*Èasovaè TON (zpodìní nábìné hrany) pro dlouhé èasy
      Èasovaè mùe pokraèovat i po vypnutí systému, pokud je èasová znaèka TS definována jako RETAIN a signál IN je po zapnutí stále TRUE*)
  VAR_INPUT
    IN               : bool;  (*vstup èasovaèe*)
    PT               : LONGTIME;  (*pøedvolba èasovaèe*)
  END_VAR
  VAR_IN_OUT
    TS               : dt;  (*èasová znaèka (musí bıt RETAIN)*)
  END_VAR
  VAR_OUTPUT
    Q                : bool;  (*vıstup èasovaèe*)
    ET               : LONGTIME;  (*aktuální hodnota èasovaèe*)
  END_VAR
  VAR
    RT               : R_TRIG;
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\ENCRYPTLIB_V12_20160923.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : D:\TecoUserLibs\EncryptLib_V12_20160923.mlb *)
(* Knihovna : EncryptLib 1.2 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c) 2016 Teco a.s. *)
(* Verze IEC pøekladaèe : 3.11.8.1 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : EncryptLib 1.2  }
(* Historie: *)
(*
v1.0 22.06.2014 nem první verze knihovny
                    funkce: AES128_encrypt(), AES128_decrypt(), RC4(), 
                            SHA1_hash(), Base64_encode(), Base64_decode()
                    je tøeba Foxtrot firmware v8.8 nebo vyšší 
v1.1 19.01.2016 nem pøidána funkce SHA256_hash(), která potøebuje 
                    Foxtrot firmware v9.7 nebo vyšší
v1.2 23.09.2016 byd pøidána funkce Base64_encode_string a Base64_encode_ptr_string pro kódování textovıch øetìzcù a dat do base64 øetìzcù
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\SYSLIB_V33_20130621.MLB"}

__DECL FUNCTION AES128_encrypt : uint
(*AES-128 CBC šifrování*)
  VAR_INPUT
    dataLen          : uint;  (*délka vstupních dat v bytech (musí bıt dìlitelná 16)*)
    bufferLen        : uint;  (*velikost datového bufferu v bytech*)
  END_VAR
  VAR_IN_OUT
    key              : usint;  (*šifrovací klíè (16 bytù)*)
    iv               : usint;  (*inicializaèní vektor (16 bytù)*)
    data             : usint;  (*šifrovaná data (vstup i vıstup)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION AES128_decrypt : uint
(*AES-128 CBC dešifrování*)
  VAR_INPUT
    dataLen          : uint;  (*délka vstupních dat v bytech (musí bıt dìlitelná 16)*)
  END_VAR
  VAR_IN_OUT
    key              : usint;  (*dešifrovací klíè (16 bytù)*)
    iv               : usint;  (*inicializaèní vektor (16 bytù)*)
    data             : usint;  (*dešifrovaná data (vstup i vıstup)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION RC4 : uint
(*RC4 šifrování / dešifrování*)
  VAR_INPUT
    dataLen          : uint;  (*délka vstupních dat v bytech*)
    keyLen           : uint;  (*délka šifrovacího / dešifrovacího klíèe v bytech*)
    skip             : uint;  (*kolik bytù RC4 generátoru je pøeskoèeno*)
  END_VAR
  VAR_IN_OUT
    key              : usint;  (*šifrovací / dešifrovací klíè*)
    data             : usint;  (*šifrovaná data (vstup i vıstup)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Base64_encode : uint
(*Zakódování binárních dat pomocí ASCII znakù
         Funkce vrací velikost zakódovaného textu v bytech*)
  VAR_INPUT
    dataLen          : uint;  (*délka vstupních dat v bytech*)
    bufferLen        : uint;  (*velikost datového bufferu v bytech*)
  END_VAR
  VAR_IN_OUT
    data             : usint;  (*vstupní data*)
    out              : usint;  (*zakódovanı text*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Base64_decode : uint
(*Dekódování ASCII textu na binární data
         Funkce vrací velikost dekódovanıch dat v bytech*)
  VAR_INPUT
    dataLen          : uint;  (*délka vstupních dat v bytech*)
  END_VAR
  VAR_IN_OUT
    data             : usint;  (*vstupní text*)
    out              : usint;  (*dekódovaná data*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SHA1_hash : uint
(*Secure Hash Algorithm
         Funkce vytvárí ze vstupních dat hash (otisk) fixní délky 160 bitù reprezentovanı jako øetìzec hexadecimálních cifer (40 znakù).
         Funkce vrací velikost vytvoøeného otisku v bytech
         Velikost promìnné hash musí bıt minimálnì 41 bytù, jinak funkce vrátí 0*)
  VAR_INPUT
    dataLen          : uint;  (*délka vstupních dat v bytech*)
    bufferLen        : uint;  (*velikost bufferu pro hash v bytech (minimálnì 41 bytù)*)
  END_VAR
  VAR_IN_OUT
    data             : usint;  (*vstupní data*)
    hash             : string [80];  (*vıslednı hash*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SHA256_hash : uint
(*Secure Hash Algorithm SHA256
         Funkce vytvárí ze vstupních dat hash (otisk) fixní délky 256 bitù reprezentovanı jako øetìzec hexadecimálních cifer (64 znakù).
         Funkce vrací velikost vytvoøeného otisku v bytech
         Velikost promìnné hash musí bıt minimálnì 65 bytù, jinak funkce vrátí 0*)
  VAR_INPUT
    dataLen          : uint;  (*délka vstupních dat v bytech*)
    bufferLen        : uint;  (*velikost bufferu pro hash v bytech (minimálnì 65 bytù)*)
  END_VAR
  VAR_IN_OUT
    data             : usint;  (*vstupní data*)
    hash             : string [80];  (*vıslednı hash*)
  END_VAR
END_FUNCTION

__DECL FUNCTION HMAC_SHA256 : uint
(*Secure Hash Algorithm HMAC-SHA256
         Funkce vytvárí ze vstupních dat hash (otisk) fixní délky 256 bitù reprezentovanı jako pole 32 bytù.
         Funkce vrací velikost vytvoøeného otisku v bytech
         Velikost promìnné hash musí bıt minimálnì 32 bytù, jinak funkce vrátí 0*)
  VAR_INPUT
    keyLen           : uint;  (*délka klíèe v bytech*)
    dataLen          : uint;  (*délka vstupních dat v bytech*)
    bufferLen        : uint;  (*velikost bufferu pro hash v bytech (minimálnì 32 bytù)*)
  END_VAR
  VAR_IN_OUT
    key              : usint;  (*klíè*)
    data             : usint;  (*vstupní data*)
    hash             : string [80];  (*vıslednı hash*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Base64_encode_string : string
(*Kóduje ASCII String na Base64 String*)
  VAR_INPUT
    data             : string [60];  (*vstupní ASCII øetìzec o max. délce 60 znakù*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Base64_encode_ptr_string : string
(*Kóduje ASCII String na Base64 String*)
  VAR_INPUT
    data             : PTR_TO usint;  (*pointer to first byte of data to encode*)
    dataLen          : uint;  (*délka vstupních dat v bytech (max. 60)*)
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\INTERNETLIB_V41_20170502.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : D:\TecoUserLibs\InternetLib_V41_20170502.mlb *)
(* Knihovna : InternetLib 4.1 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c) 2010 - 2017 *)
(* Verze IEC pøekladaèe : 3.12.13.1 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : InternetLib 4.1  }
(* Historie: *)
(*
v4.1 02.05.2017 Byd
  fbSmtp : Pøidána monost urèit typ pøílohy a generovat Message-ID pro blok 
  fbSmtp : Opravena definice hranice, která byla delší ne doporuèenıch 80 znakù v fbSmtp
  fbSmtp : Øádky pøílohy kódované Base64 zkráceny na 76 znakù, aby vyhovovaly bìnım zvyklostem
v4.0 16.02.2017 Byd
  Upraven blok fbSmtp pro záporné posunutí èasového pásma
v3.9 09.12.2016 Byd
  Pøidán blok pro získání souboru z FTP serveru fbRetriveFromFtp  
v3.8 19.10.2016 Nem
  Pøidány bloky fbPingIP a fbPing - nutnı Foxtrot FW v9.9 nebo vyšší
v3.7 23.09.2016 Byd
  Kódování do Base64 vyuívá EncryptLib - nutnı firmware firmware v8.8
  Pøidán blok fbRetriveFromFtp pro získání souboru z FTP serveru
  Upraven blok fbSplitUrlAddress, aby dokázal pracovat s adresou vèetnì jména a hesla pro základní autentifikaci
  Pøidána monost aktivnì uzavøít spojení pro bloky fbHttpRequest, fbHttpRequestL a fbHttpRequestL2
  U bloku fbSmtp je moné zadat znakovou sadu, která se uplatní pro pøedmìt a tìlo zprávy
v3.6 16.05.2016 Byd
  Blok fbSmtp rozšíøen o monost skryté kopie (adresa pøed kterou je uvedena teèka není pøíjemci zobrazen
v3.5 20.11.2015 Byd
  Bloky HttpRequest nastavují vıstup Busy ve stejném cyklu, kdy opouští stav Idle
v3.4 26.10.2015 Byd
  Pøídán blok fbSplitUrlAddress
v3.3 18. 9.2015 Byd
  Úprava bloku fbSMTP - pouití EHLO místo HELO
v3.2  4. 9.2015 Byd
  Vynechán KeyID a Message Authentication Code ze SNTP
v3.1 22. 4.2014 Byd
  Blok fbStoreToFtp kontroluje pøeplnìní odesílacího TCP bufferu (vyaduje ComLib 
1.4)
v3.0  2. 4.2014 Byd
  Vıstup Done bloku fbSmtp byl nastaven i v pøípadì, kdy se nepovedlo zprávu úspìšnì 
odeslat.
  Rychlejší kódovaní Base64
  Odstranìnı hazard pøi odesílání dlouhıch pøíloh z verze 2.8
v2.9 22.10.2013 Byd
  Pøidán funkèní blok fbHttpRequestL2 s moností zadat typ obsahu (Content-Type)
v2.8  6.6.2013 Byd
  Blok fbStoreToFtp udruje øídící spojení bìhem vysílání dat (vyaduje firmware 
7.7)
  Blok fbSmtp podporuje víceøádkové odpovìdi serveru
v2.7 29.5.2013 Byd
  Blok fbStoreToFtp akceptuje pøi pøístupu na neexistující soubor všechny negativní 
odpovìdi s kódem 5xx
  Blokování timeoutu u fbStoreToFtp pøi pøenosu velkıch souborù
v2.6 27.2.2013 Byd
  Úprava bloku fbSntp pro záporné ofsety èasu od UTC
  Prodlouení timeoutu pro HTTP protokol
v2.5 16.1.2013 Byd
  Oprava chyby bloku fbHttpRequestL zanesená ve verzi 2.4 (blok odesílal jen 
hlavièku)
V2.4 5.10.2012 Byd
  Pøidána podpora základní autentifikace pøedaná v URI jmeno:heslo@domain
V2.3 21.8.2012 Byd
  Vytvoøení cesty na FTP serveru
  Monost nahrávat celé adresáøe na FTP
V2.2 6.3.2012 Byd
  Vypuštìn prázdnı pøíkaz v komunikaci se SMTP serverem (nìkteré servry vracely 
negativní odpovìï)
V2.1 13.2.2012 Byd
  Doplòen blok NsLookUpEx pro pøeklad doménovıch jmen s podporou firmware
  (vyaduje firmware 7.1 nebo vyšší)
  Opraveno chování vıstupù Done a Err v fbStoreToFtp 
V2.0  1.12.2011 Byd
  Funkce GetDateAndTime_RFC2822 pøesunuta do knihovny TimeLib  
V1.9  8.4.2011 Byd
  Doplnìno hlídání délky pøi odesílání dat pøes HTTP
  Doplnìn blok fbHttpRequestL pro odesílání dlouhıch dat metodou POST
  Doplnìn blok fbStringStream pro naplnìní pracovního buferu z promìnnıch typu 
STRING
V1.8 17.3.2010 Byd
  Doplnìna èasová znaèka pøi odesílání pøes SMTP
V1.7 8.12.2010 Byd
V1.6 1.12.2010 Byd
  Doplnìn kód odpovìdi 125 pokud je spojení s FTP serverem ji navázáno.
V1.5 2.9.2010 Byd
  Doplnìny závislosti na knihovnách.
V1.4 Byd 
  fbStoreToFtp - pøidáno chybìjící zavøení souboru v pøípadì chyby pøenosu. Mohlo 
zpùsobit a blokování file systému.
V1.3 Byd
  fbStoreToFtp - blok pro pøenos souboru na FTP server 
V1.2 Byd
  NsLookUp - rozšíøené pøíznaky chyb 2 a 16 odpovídají ResponseCode dle RFC1035 + 1
V1.1 Byd
  Smtp blok kontroluje pøeplnìní odesílacího TCP bufferu (vyaduje ComLib 1.4)
*)

(*----------------------------------------------------------------------------*)

VAR_GLOBAL CONSTANT
 INTERNETLIB_END_OF_LINE_ {HIDDEN} : string [2] :=  '$r$l';
 INTERNETLIB_EMPTY_STRING_ {HIDDEN} : string [1] :=  '';

END_VAR

__DECL FUNCTION _FindNextPathSeparator {HIDDEN} : bool
  VAR_IN_OUT
    In               : string [80];  (*string with path*)
    Pos              : udint;  (*start with zero*)
  END_VAR
END_FUNCTION

TYPE TDnsReplyHeader :
  STRUCT
    TransactionID    : uint;
    Recursion_des    : bool;
    Truncated        : bool;
    Authoritative    : bool;
    OpCode_0         : bool;
    OpCode_1         : bool;
    OpCode_2         : bool;
    OpCode_3         : bool;
    Response         : bool;
    ReplyCode_0      : bool;
    ReplyCode_1      : bool;
    ReplyCode_2      : bool;
    ReplyCode_3      : bool;
    Empty            : bool;
    Autheticated     : bool;
    Reseved          : bool;
    Recursion_ava    : bool;
    Question         : uint;
    AnswerRRs        : uint;
    AuthorityRRs     : uint;
    AdditionalRRs    : uint;
  END_STRUCT;
END_TYPE

TYPE TDnsReply :
  STRUCT
    Header           : TDnsReplyHeader;
    Data             : ARRAY [0..511] OF usint;
  END_STRUCT;
END_TYPE

TYPE TDnsQueryHeader :
  STRUCT
    TransactionID    : uint;
    Recursion_des    : bool;
    Truncated        : bool;
    Empty_6          : bool;
    OpCode_0         : bool;
    OpCode_1         : bool;
    OpCode_2         : bool;
    OpCode_3         : bool;
    Query            : bool;
    Empty_0          : bool;
    Empty_1          : bool;
    Empty_2          : bool;
    Empty_3          : bool;
    NonAutheticated  : bool;
    Empty_4          : bool;
    Reseved          : bool;
    Empty_5          : bool;
    Question         : uint;
    AnswerRRs        : uint;
    AuthorityRRs     : uint;
    AdditionalRRs    : uint;
  END_STRUCT;
END_TYPE

TYPE TDnsQuery :
  STRUCT
    Header           : TDnsQueryHeader;
    QueryString      : string [80];
  END_STRUCT;
END_TYPE

__DECL FUNCTION _internetlib_DnsLenOfDomainName {HIDDEN} : udint
  VAR_INPUT
    IN               : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _internetlib_DnsCodeDomainName {HIDDEN} : string
(*Kóduje jméno domény*)
  VAR_INPUT
    IN               : string [80];
  END_VAR
  VAR
    I                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION _internetlib_DnsDecodeDomainName {HIDDEN} : string
(*Dekóduje jméno domény*)
  VAR_INPUT
    IN               : PTR_TO usint;
    BG               : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbNsLookUp
(*Získá IP adresu zadaného doménového jména*)
  VAR_INPUT
    getIP            : bool R_EDGE;  (*Získat IP adresu dle jména*)
    chanCode         : uint;  (*pøenosovı kanál  UDP, lport: 0, rport: 53, in: 524, out: 93*)
    DnsIP            : TIPadr;  (*IP adresa DNS serveru*)
  END_VAR
  VAR_IN_OUT
    Name             : string [80];  (*Doménove jméno*)
    IP               : TIPadr;  (*Získaná IP adresa*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*IP adresa obdrena úspìsnì*)
    Busy             : bool;  (*Operace probíha*)
    Err              : bool;  (*Nastala chyba*)
    ErrId            : usint;  (*Èíslo chyby*)
  END_VAR
  VAR
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    timeout          : TON;
    timeout2         : TON;
    netDnsQuery      : TDnsQuery;
    netDnsReply      : TDnsReply;
    TransID          : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbNsLookUpEx
(*Získá IP adresu zadaného doménového jména*)
  VAR_INPUT
    getIP            : bool R_EDGE;  (*Získat IP adresu dle jména*)
    dnsIP            : TIPadr;  (*IP adresa DNS serveru*)
    Name             : string [80];  (*Doménove jméno*)
  END_VAR
  VAR_IN_OUT
    IP               : TIPadr;  (*Získaná IP adresa*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*IP adresa obdrena úspìsnì*)
    Busy             : bool;  (*Operace probíha*)
    Err              : bool;  (*Nastala chyba*)
    ErrId            : usint;  (*Èíslo chyby*)
  END_VAR
  VAR
    CurrName         : string [80];  (*current domain name*)
  END_VAR
END_FUNCTION_BLOCK

TYPE  THttpBuffer : ARRAY [0..511] OF usint;
END_TYPE

TYPE THttpState : 
  (hs_HttpIdle,
   hs_HttpSetIP,
   hs_HttpConnect,
   hs_HttpSend,
   hs_HttpReceivingData,
   hs_HttpSendPost 
  );
END_TYPE

__DECL FUNCTION_BLOCK fbHttpRequest
(*Vysílá metody GET a POST pøes HTTP protokol*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*vyslat data metodou POST*)
    Get              : bool R_EDGE;  (*získat data metodu GET*)
    Cancel           : bool R_EDGE;  (*zrušit probíhající operaci*)
    chanCode         : uint;  (*pøenosovı kanál TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*IP adresa vzdáleneho serveru*)
    port             : uint :=  80;  (*Èíslo portu vzdáleného serveru*)
    Close            : bool;  (*Pokud je nastaveno, blok neèeká na server a zavøe spojení a zavøe jej aktivnì jakmile získá všechny data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*Cesta k datùm na serveru (vdy zaèíná znakem '/')*)
    Host             : string [80];  (*Jméno hostitele*)
    Data             : string [80];  (*Data pro metodu POST*)
    RecvData         : THttpBuffer;  (*Bufer dat 512 bytù*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Operace ukonèena*)
    Busy             : bool;  (*Operace probíha*)
    Err              : bool;  (*Chyba komunikace*)
    ErrId            : usint;  (*Èíslo chyby*)
    DataReady        : bool;  (*Pøijata nová data*)
    DataLen          : uint;  (*Délka dat*)
    State            : THttpState;  (*Stav komunikace*)
    Result           : int;  (*HTTP kod*)
    Progress         : sint;  (*Prùbìh stahování dat*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    WasEOL           : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lHost            : string [80];
  END_VAR
END_FUNCTION_BLOCK

TYPE TSmtpState : 
  (ss_SmtpInit,
   ss_SmtpIdle,
   ss_SmtpSetIP,
   ss_SmtpTxConnect,
   ss_SmtpRxConnect,
   ss_SmtpTxHelo,
   ss_SmtpRxHelo,
   ss_SmtpTxAuthlogin,
   ss_SmtpRxAuthlogin,
   ss_SmtpTxUserName,
   ss_SmtpRxUserName,
   ss_SmtpTxPassword,
   ss_SmtpRxPassword,
   ss_SmtpTxMailFrom,
   ss_SmtpRxMailFrom,
   ss_SmtpTxRcptTo,
   ss_SmtpRxRcptTo,
   ss_SmtpTxData,
   ss_SmtpRxData,
   ss_SmtpTxDataFrom,
   ss_SmtpTxDataTo,
   ss_SmtpTxDataSubject,
   ss_SmtpTxMultipart,
   ss_SmtpTxDataText,
   ss_SmtpTxAttachement,
   ss_SmtpTxAttachementBody,
   ss_SmtpTxEndOfMail,
   ss_SmtpRxAck,
   ss_SmtpTxQuit,
   ss_SmtpRxClose,
   ss_SmtpRxTimeout,
   ss_SmtpRxError,
   ss_SmtpTxDate,
   ss_SmtpTxContentType,
   ss_SmtpTxMessageId 
  );
END_TYPE

VAR_GLOBAL CONSTANT
 SMTP_END_OF_LINE_2_ {HIDDEN} : string [3] :=  '>$r$l';

END_VAR

__DECL FUNCTION_BLOCK fbSmtp
(*Odesílá emailové zprávy pøes SMTP*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*spustí odeslání zprávy*)
    Auth             : bool;  (*vyaduje server authetifikaci?*)
    Cancel           : bool R_EDGE;  (*stornovat odesílání*)
    chanCode         : uint;  (*pøenosovı kanál  TCP Master, in: 255, out: 255*)
    IPadr            : TIPadr;  (*IP adresa SMTP serveru*)
    port             : uint :=  25;  (*Port SMTP serveru*)
    Lines            : usint;  (*poèet øádkù tìla zprávy*)
    UtcOff           : int;  (*posun èasového pásma v minutách*)
    charset          : string [16];  (*znaková sada tìla zprávy ('windows-1250', 'UTF-8',...)*)
    attachementType  : string [32];  (*uivatelsky definovanı MINE typ pøílohy. Není-li specifikován, je pouit 'application/octet-stream' (další moné hodnoty jsou 'image/jpeg', 'image/png', 'text/plain; charset=windows-1250',...)*)
    genMessageID     : bool;  (*vygeneruje unikátní Message-ID*)
  END_VAR
  VAR_IN_OUT
    Sender           : string [80];  (*adresa odesílatele*)
    SendName         : string [80];  (*jméno odesílatele*)
    Rcpt             : string [80];  (*adresa pøíjemce*)
    Subject          : string [80];  (*pøedmìt zprávy*)
    Text             : string [80];  (*první øádek tìla zprávy*)
    Attach           : string [80];  (*jméno souboru s pøilohou*)
    Username         : string [80];  (*uivatelské jméno pro SMTP server*)
    Password         : string [80];  (*heslo pro SMTP server*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*truepokud se podaøilo zprávu odeslat*)
    Busy             : bool;  (*truepokud se právì odesílá zpráva*)
    Err              : bool;  (*truepokud nastala pøi odesílání chyba*)
    ErrId            : usint;  (*èíslo chyby*)
    ReplyCode        : uint;  (*kód odpovìdi serveru*)
    State            : TSmtpState;  (*stav komunikace*)
  END_VAR
  VAR CONSTANT
    SMTP_BASE64_LEN_ : udint :=  57;  (*60*)
    SMTP_BASE64_LEN2_ : udint :=  SMTP_BASE64_LEN_*2;  (*120*)
    SMTP_MAXIMUM_FILE_LINE_LENGTH_ : udint :=  SMTP_BASE64_LEN_*3;  (*180;*)
  END_VAR
  VAR
    timeout_cntr     : TON;  (*detekce timeoutu pri komunikaci*)
    cmd              : string [255];
    buff             : ARRAY [0..511] OF usint;
    copy_rcpt        : string [255];
    temp_rcpt        : string [180];
    body_rcpt        : string [80];
    ptrText          : PTR_TO string [80];
    body_lines       : sint;
    Recv_from        : fbRecvTxt;  (*FB pro prijem*)
    Send_to          : fbSendTo;  (*FB pro vysilani*)
    h                : HANDLE;
    TRO              : bool;  (*buffer overflow*)
    lAuth            : bool;  (*byla pozadovana autorizace*)
    mesRec           : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE TNtpMessage {HIDDEN} :
  STRUCT
    Flags            : byte :=  2#00_011_011;  (*|  LI1 | LI0 | VN2 | VN1 | VN0 |Mode2|Mode1|Mode0|*)
    Stratum          : usint :=  15;
    Polling          : sint :=  8;
    Precision        : sint :=  -8;
    RootDelay        : udint;
    RootDispersion   : udint;
    RefIdentifier    : udint;
    ReferenceTS      : udint;
    ReferenceTSFrac  : udint;
    OriginateTS      : udint;
    OriginateTSFrac  : udint;
    ReceiveTS        : udint;
    ReceiveTSFrac    : udint;
    TransmitTS       : udint;
    TransmitTSFrac   : udint;
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbSntp
(*Získává èasovı ofset se vzdáleného èasového serveru
Jména skupin èasovıch serverù:
  
  pool.ntp.org
  europe.pool.ntp.org
  cz.pool.ntp.org*)
  VAR_INPUT
    Get              : bool R_EDGE;  (*Získat novı èasovı ofset ze serveru*)
    Accept           : bool R_EDGE;  (*Pøijmout èasovı ofset ze serveru*)
    chanCode         : uint;  (*UNI UDP kanál (60 bytes IN/OUT)*)
    IPadr            : TIPadr;  (*IP adresa NTP serveru*)
    port             : uint :=  123;  (*Port NTP serveru*)
    UtcOff           : int;  (*Posun èasového pásma v minutách*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Èasovı ofset úspìšnì získán*)
    Busy             : bool;  (*Probíha komunikace*)
    TimeSet          : bool;  (*Novı èas nastaven do RTC*)
    Err              : bool;  (*Chyba bìhem komunikace*)
    ErrId            : usint;  (*Èíslo chyby*)
    Offset           : lreal;  (*Získanı ofset [s]*)
    Error            : lreal;  (*Maximalní chyba získaného ofsetu [s]*)
  END_VAR
  VAR
    Recv             : bool;
    SettingTime      : bool;
    Now              : dt;
    NowLocal         : dt;
    NowTeco          : ARRAY [0..6] OF usint;
    NowMili          : uint;
    NtpPacket        : TNtpMessage;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    Attemps          : udint;
    Success          : udint;
    ShortTimeout     : TON;
    Timeout          : TON;
    maxSW22          : uint;
  END_VAR
  VAR CONSTANT
    _fbSntp_EMPTY_NTP_MESSAGE_ : TNtpMessage :=  (RootDispersion:= 0);
  END_VAR
END_FUNCTION_BLOCK

TYPE TNsLookUpItem :
  STRUCT
    Request          : bool;
    Set              : bool;
    Done             : bool;
    Err              : bool;
    IP               : TIPadr;
    Name             : string [80];
  END_STRUCT;
END_TYPE

TYPE  TNsLookUpTable : ARRAY [0..15] OF TNsLookUpItem;
END_TYPE

__DECL FUNCTION_BLOCK fbNsLookUpByTable
(*Získá IP adresu doménovıch jmén v tabulce*)
  VAR_INPUT
    chanCode         : uint;  (*pøenosovı kanál UDP, lport: 0, rport: 53, in: 524, out: 93*)
    DnsIP            : TIPadr;  (*Adresa DNS serveru*)
  END_VAR
  VAR_IN_OUT
    NsLookUpTable    : TNsLookUpTable;  (*Tabulka domenovıch jmen*)
  END_VAR
  VAR_OUTPUT
    Busy             : bool;  (*Probíha komunikace*)
    Err              : bool;  (*Chyba komunikace*)
    ErrId            : usint;  (*Èíslo chyby*)
  END_VAR
  VAR
    i                : uint;
    j                : uint;
    NsLookUp         : fbNsLookUp;
    NsLookUpItem     : TNsLookUpItem;
  END_VAR
END_FUNCTION_BLOCK

TYPE TFtpStoreState : 
  (fss_Init,
   fss_Idle,
   fss_OpenFile,
   fss_IpCom,
   fss_Connect,
   fss_Rx220,
   fss_TxUser,
   fss_RxUser,
   fss_TxPass,
   fss_RxPass,
   fss_TxType,
   fss_RxType,
   fss_TxPasv,
   fss_RxPasv,
   fss_TxStor,
   fss_IpDat,
   fss_WaitForOpen,
   fss_TxData,
   fss_RxComplete,
   fss_TxQuit,
   fss_RxQuit,
   fss_Close,
   fss_Error,
   fss_UnexpectedReply,
   fss_TxCreateDir,
   fss_RxCreateDir,
   fss_ReadDir,
   fss_TxRetr,
   fss_RxData,
   fss_TxSize,
   fss_RxSize 
  );
END_TYPE

VAR_GLOBAL CONSTANT
 FTP_DIR_STACK_ {HIDDEN} : usint :=  4;

END_VAR

TYPE TFtpDirStack {HIDDEN} :
  STRUCT
    hDir             : HANDLE;
    sDir             : string [12];
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbStoreToFtp
(*Ukladá soubory z pamìové karty na FTP server*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*Odešle soubor/adresáø na FTP*)
    IPadr            : TIPadr;  (*IP adresa FTP serveru*)
    port             : uint :=  21;  (*Port FTP serveru*)
    chanCodeCom      : uint;  (*Pøenosovı kanál TCP Master, in: 255, out: 255*)
    chanCodeDat      : uint;  (*Pøenosovı kanál TCP Master, in: 1, out: 255*)
  END_VAR
  VAR_IN_OUT
    User             : string [80];  (*Uivatelské jméno*)
    Pass             : string [80];  (*Heslo*)
    LocalName        : string [80];  (*Jméno souboru nebo sloky na pamìové kartì*)
    RemotName        : string [80];  (*Jméno souboru nebo sloky na FTP serveru*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Soubor byl uloen na FTP server*)
    Busy             : bool;  (*Soubor se ukládá na FTP server*)
    Err              : bool;  (*Nastala chyba*)
    ErrId            : usint;  (*Èíslo chyby*)
    ReplyCode        : uint;  (*Kód odpovìdi serveru*)
    State            : TFtpStoreState;  (*Stav komunikace*)
    CurrFile         : string [80];  (*Jméno aktuálnì nahrávaného souboru*)
    Progress         : usint;  (*Prùbìh nahrávání souboru v procentech*)
  END_VAR
  VAR
    Send_To_Com      : fbSendTo;
    Recv_From_Com    : fbRecvFrom;
    KeepAliveTCP     : fbKeepAliveTCP;
    rea              : TRemoteEthAdr;
    cmdCom           : string [255];
    lRemotName       : string [80];
    lLocalFileInfo   : TFileInfo;
    idPos            : udint;
    lSize            : udint;
    lTrans           : udint;
    dirStack         : ARRAY [0..4] OF TFtpDirStack;
    dirStackLev      : usint;
    i                : usint;
    eErrId           : usint;
    Send_To_Dat      : fbSendTo;
    cmdDat           : ARRAY [0..254] OF usint;
    timeoutCom       : TON;
    data             : udint;
    h                : HANDLE :=  INVALID_HANDLE_VALUE;
    pasvDat          : ARRAY [0..5] OF usint;
    TRO              : bool;
    mesRec           : bool;
    iniDir           : bool;
    endDir           : bool;
    TRO_com          : bool;
    TRO_dat          : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE  THttpPostData : ARRAY [0..1535] OF usint;
END_TYPE

__DECL FUNCTION_BLOCK fbHttpRequestL
(*Vysílá metody GET a POST pøes HTTP protokol*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*vyslat data metodou POST*)
    Get              : bool R_EDGE;  (*získat data metodu GET*)
    Cancel           : bool R_EDGE;  (*zrušit probíhající operaci*)
    chanCode         : uint;  (*pøenosovı kanál TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*IP adresa vzdáleneho serveru*)
    port             : uint :=  80;  (*Èíslo portu vzdáleného serveru*)
    postLen          : uint;  (*Délka dat pro metodu POST*)
    Close            : bool;  (*Pokud je nastaveno, blok neèeká na server a zavøe spojení a zavøe jej aktivnì jakmile získá všechny data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*Cesta k datùm na serveru (vdy zaèíná znakem '/')*)
    Host             : string [80];  (*Jméno hostitele*)
    Data             : THttpPostData;  (*První byte dat pro metodu POST*)
    RecvData         : THttpBuffer;  (*Bufer dat 512 bytù*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Operace ukonèena*)
    Busy             : bool;  (*Operace probíha*)
    Err              : bool;  (*Chyba komunikace*)
    ErrId            : usint;  (*Èíslo chyby*)
    DataReady        : bool;  (*Pøijata nová data*)
    DataLen          : uint;  (*Délka dat*)
    State            : THttpState;  (*Stav komunikace*)
    Result           : int;  (*HTTP kod*)
    Progress         : sint;  (*Prùbìh stahování dat*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    WasEOL           : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lPostLen         : uint;
    lHost            : string [80];
    BodyLen          : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbHttpRequestL2
(*Vysílá metody GET a POST pøes HTTP protokol s moností definice typu obsahu (Content-Type)*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*vyslat data metodou POST*)
    Get              : bool R_EDGE;  (*získat data metodu GET*)
    Cancel           : bool R_EDGE;  (*zrušit probíhající operaci*)
    chanCode         : uint;  (*pøenosovı kanál TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*IP adresa vzdáleneho serveru*)
    port             : uint :=  80;  (*Èíslo portu vzdáleného serveru*)
    postLen          : uint;  (*Délka dat pro metodu POST*)
    Close            : bool;  (*Pokud je nastaveno, blok neèeká na server a zavøe spojení a zavøe jej aktivnì jakmile získá všechny data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*Cesta k datùm na serveru (vdy zaèíná znakem '/')*)
    Host             : string [80];  (*Jméno hostitele*)
    Data             : THttpPostData;  (*První byte dat pro metodu POST*)
    ContentType      : string [80];  (*Typ obsahu (Content-Type)*)
    RecvData         : THttpBuffer;  (*Bufer dat 512 bytù*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Operace ukonèena*)
    Busy             : bool;  (*Operace probíha*)
    Err              : bool;  (*Chyba komunikace*)
    ErrId            : usint;  (*Èíslo chyby*)
    DataReady        : bool;  (*Pøijata nová data*)
    DataLen          : uint;  (*Délka dat*)
    State            : THttpState;  (*Stav komunikace*)
    Result           : int;  (*HTTP kod*)
    Progress         : sint;  (*Prùbìh stahování dat*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    WasEOL           : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lPostLen         : uint;
    lHost            : string [80];
    BodyLen          : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSplitUrlAddress
(*Funkèní blok fbSplitUrlAddress rozebírá zadanou URL adresu na jednotlivé poloky vyadované bloky fbHttpRequest, fbHttpRequestL a fbHttpRequestL2.
  Vstupem bloku je promìnná pøedaná pøes urlAddress, která nese URL adresu tak jak je uvedena ve webovém prohlíeèi.*)
  VAR_INPUT
    split            : bool R_EDGE;  (*Rozdìlení URL adresy*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*URL adresa rozdìlena a IP adresa úspìšnì získána*)
    busy             : bool;  (*Operace probíhá*)
    err              : bool;  (*Nastala chyba*)
    errId            : usint;  (*Èíslo chyby*)
  END_VAR
  VAR_IN_OUT
    urlAddress       : string [255];  (*URL adresa tak jak je uvedena ve webovém prohlíeèi*)
    host             : string [80];  (*Jméno hostitele*)
    action           : string [80];  (*Cesta k datùm na serveru (vdy zaèíná znakem '/')*)
    ipAdr            : TIPadr;  (*IP adresa vzdáleného serveru*)
    port             : uint;  (*Èíslo portu vzdáleného serveru*)
  END_VAR
  VAR
    NsLookUp         : fbNsLookUpEx;
  END_VAR
  VAR CONSTANT
    HTTP_IP_NULL     : TIPadr :=  [0,0,0,0];
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRetriveFromFtp
(*Získává soubor z FTP serveru a ukládá na pamìovou kartu*)
  VAR_INPUT
    Retrieve         : bool R_EDGE;  (*Pøíjmout soubor z FTP*)
    IPadr            : TIPadr;  (*IP adresa FTP serveru*)
    port             : uint :=  21;  (*Port FTP serveru*)
    chanCodeCom      : uint;  (*Pøenosovı kanál TCP Master, in: 255, out: 255*)
    chanCodeDat      : uint;  (*Pøenosovı kanál TCP Master, in: 255, out: 1*)
  END_VAR
  VAR_IN_OUT
    User             : string [80];  (*Uivatelské jméno*)
    Pass             : string [80];  (*Heslo*)
    LocalName        : string [80];  (*Jméno souboru na pamìové kartì*)
    RemotName        : string [80];  (*Jméno souboru na FTP serveru*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*Soubor byl uloen na pamìovou kartu*)
    Busy             : bool;  (*Soubor se ukládá na pamìovou kartu*)
    Err              : bool;  (*Nastala chyba*)
    ErrId            : usint;  (*Èíslo chyby*)
    ReplyCode        : uint;  (*Kód odpovìdi serveru*)
    State            : TFtpStoreState;  (*Stav komunikace*)
    Progress         : usint;  (*Prùbìh nahrávání souboru v procentech*)
  END_VAR
  VAR
    Send_To_Com      : fbSendTo;
    Recv_From_Com    : fbRecvTxt;  (*fbRecvFrom;*)
    KeepAliveTCP     : fbKeepAliveTCP;
    rea              : TRemoteEthAdr;
    cmdCom           : string [255];
    lRemotName       : string [80];
    lLocalFileInfo   : TFileInfo;
    idPos            : udint;
    lSize            : udint;
    lTrans           : udint;
    i                : usint;
    eErrId           : usint;
    Recv_From_Dat    : fbRecvFrom;
    WTFS             : WriteToFileSeq;
    cmdBuffer        : ARRAY [0..254] OF usint;
    cmdDat           : ARRAY [0..254] OF usint;
    timeoutCom       : TON;
    data             : udint;
    h                : HANDLE :=  INVALID_HANDLE_VALUE;
    pasvDat          : ARRAY [0..5] OF usint;
    TRO              : bool;
    mesRec           : bool;
    TRO_com          : bool;
    TRO_dat          : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE T_PING_INFO :
  STRUCT
    result           : dint;  (*0=probíhá, 1=dokonèeno bez chyb, -1=chyba*)
    hostIP           : TIPadr;  (*IP adresa hostitele*)
    responseTime     : time;  (*èas odezvy*)
    pingNumber       : udint;  (*èíslo pingu*)
    dataLen          : udint;  (*délka dat*)
    ttl              : usint;  (*TTL odpovìdi*)
    errMsg           : string [80];  (*chybová zpráva*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbPingIP
(*Ovìøí spojení mezi PLC a síovım rozhraním s danou IP adresou*)
  VAR_INPUT
    rqPing           : bool R_EDGE;  (*ádost o odeslání Ping*)
    hostIP           : TIPadr;  (*IP adresa hostitele*)
    ttl              : usint;  (*ivotnost paketu TTL*)
    timeLimit        : time;  (*Èasovı limit pro odpovìï*)
    dataLen          : uint;  (*Délka dat*)
  END_VAR
  VAR_IN_OUT
    pingInfo         : T_PING_INFO;  (*Informace o Pingu*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*Operace byla úspìšnì dokonèena*)
    busy             : bool;  (*Operace probíhá*)
    err              : bool;  (*Nastala chyba*)
  END_VAR
  VAR
    timeout          : TON;
    waitArp          : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbPing
(*Ovìøí spojení mezi PLC a hostitelem daného jména*)
  VAR_INPUT
    rqPing           : bool R_EDGE;  (*ádost o odeslání Ping*)
    hostName         : string [80];  (*Jméno hostitele*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*Operace byla úspìšnì dokonèena*)
    busy             : bool;  (*Operace probíhá*)
    err              : bool;  (*Nastala chyba*)
    pingInfo         : T_PING_INFO;  (*Informace o Pingu*)
  END_VAR
  VAR
    rqSplit          : bool;
    SplitUrlAdr      : fbSplitUrlAddress;
    PingIP           : fbPingIP;
    host             : string [80];  (*Jméno hostitele*)
    action           : string [80];  (*Poadovaná stránka napøíklad "/index.xml"*)
    ipAdr            : TIPadr;  (*IP adresa vzdáleneho serveru*)
    port             : uint;  (*Èíslo portu vzdáleného serveru*)
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\JSONLIBEX_V13_20151026.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : C:\TecoLib\JsonLibEx_V13_20151026.mlb *)
(* Knihovna : JsonLibEx 1.3 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c) 2015 Teco a.s. *)
(* Verze IEC pøekladaèe : 3.11.1.4 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : JsonLibEx 1.3  }
(* Historie: *)
(*
v1.0 16.11.2012 Nem Úvodni verze knihovny
v1.1 28.11.2014 Ciz Doplnìny bloky fbJsonParserEx(),
                    fbJsonFileParser() a fbJsonPageParser()
v1.2 08.07.2015 Nem Pøi chybì pársovaní a po dokonèení pársování 
                    korektnì uzavøeno spojení se serverem
v1.3 26.10.2015 Nem ve fbJsonPageParser() pouit blok
                    fbSplitUrlAddress() z InternetLib_v34
*)

(*----------------------------------------------------------------------------*)

VAR_GLOBAL CONSTANT
 JSON_MAX_STACK_LEVEL : sint :=  9;  (*maximální úroveò JSON stacku*)

END_VAR

TYPE TJsonItem :
  STRUCT
    name             : string [255];  (*celı název poloky*)
    value            : string [255];  (*hodnota poloky*)
  END_STRUCT;
END_TYPE

TYPE TJsonParserStat : 
  (json_none,
   json_object_name,
   json_object_value 
  );
END_TYPE

TYPE TJsonStackItem :
  STRUCT
    stat             : TJsonParserStat;  (*stav parseru*)
    isArray          : bool;  (*pøíznak pole*)
    arrayIndex       : uint;  (*index pole*)
    name             : string [31];  (*název poloky*)
  END_STRUCT;
END_TYPE

TYPE TJsonStack :
  STRUCT
    done {ALIGNED}   : bool;  (*byla vyparsovaná poloka*)
    eod {ALIGNED}    : bool;  (*konec dokumentu*)
    error            : usint;  (*kód chyby*)
    errTxt           : string [32];  (*popis chyby*)
    maxLevel {HIDDEN} : sint;  (*max úroveò stacku*)
    level            : sint;  (*úroveò stacku*)
    item             : ARRAY [0..9] OF TJsonStackItem;
  END_STRUCT;
END_TYPE

__DECL FUNCTION JSON_MemcpyPtr {HIDDEN} : udint
(*Funkce memcpy kopíruje blok n bytù ze source do dest.
  Funkce vrací poèet zkopírovanıch bytù*)
  VAR_INPUT
    source           : PTR_TO usint;  (*source*)
    dest             : PTR_TO usint;  (*destination*)
    length           : udint;  (*number of bytes*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbJsonParser
(*Pøevádí jednu poloku JSON dokumentu do struktury TJsonItem*)
  VAR_INPUT
    start            : bool;  (*TRUE zaène parsovat od zaèátku JSON dat, FALSE pokraèuje tam, kde se minule skonèilo*)
    shrink           : bool;  (*TRUE odstraní z bufferu ji zpracovanou èást a nezpracovanı zbytek pøesune na zaèátek bufferu*)
    size             : udint;  (*velikost bufferu s JSON dokumentem*)
  END_VAR
  VAR_IN_OUT
    sourceJSON       : usint;  (*zaèátek JSON dat*)
    jsonItem         : TJsonItem;  (*vıstup JSON parseru*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*byla vyparsována další poloka*)
    eod              : bool;  (*konec JSON dokumentu*)
    error            : usint;  (*error <> 0 ... došlo k chybì*)
    restLen          : uint;  (*poèet bytù, kterı zbıvá zpracovat*)
    jsonStack        : TJsonStack;  (*zásobník pro analızu dokumentu*)
  END_VAR
  VAR
    i                : sint;
    index            : udint;
    src              : PTR_TO usint;
    end              : PTR_TO usint;
    char             : usint;
    break            : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE TJsonInfo :
  STRUCT
    item             : TJsonItem;  (*vıstup JSON parseru*)
    stack            : TJsonStack;  (*zásobník pro analızu dokumentu*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbJsonParserEx
(*Pøevádí jednu poloku JSON dokumentu do struktury TJsonItem*)
  VAR_INPUT
    start            : bool;  (*TRUE zaène parsovat od zaèátku JSON dat, FALSE pokraèuje tam, kde se minule skonèilo*)
    shrink           : bool;  (*TRUE odstraní z bufferu ji zpracovanou èást a nezpracovanı zbytek pøesune na zaèátek bufferu*)
    size             : udint;  (*velikost bufferu s JSON dokumentem*)
  END_VAR
  VAR_IN_OUT
    sourceJSON       : usint;  (*zaèátek JSON dat*)
    JsonInfo         : TJsonInfo;  (*vıstup JSON parseru*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*byla vyparsována další poloka*)
    eod              : bool;  (*konec JSON dokumentu*)
    error            : usint;  (*error <> 0 ... došlo k chybì*)
    restLen          : uint;  (*poèet bytù, kterı zbıvá zpracovat*)
  END_VAR
  VAR
    i                : sint;
    index            : udint;
    src              : PTR_TO usint;
    end              : PTR_TO usint;
    char             : usint;
    break            : bool;
    tmp              : udint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbJsonFileParser
(*Parsování JSON dokumentu ze souboru. Informace o vyparsované poloce je uloena do struktury TJsonInfo.*)
  VAR CONSTANT
    JSON_BUMBER      : uint :=  256;  (*nárazník v JSON bufferu*)
    JSON_BUFFER_SIZE : uint :=  768;  (*velikost bufferu*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*parsovat JSON soubor*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*jméno souboru s JSON dokumentem*)
    JsonInfo         : TJsonInfo;  (*vısledek parsování*)
  END_VAR
  VAR_OUTPUT
    start            : bool;  (*príznak inicializace bloku*)
    done             : bool;  (*vısledek parsování je pripraven v JsonInfo*)
    busy             : bool;  (*blok je zaneprázdnen*)
    eof              : bool;  (*konec souboru*)
    break            : bool;  (*buffer zpracován, pokracovat príští cyklus*)
    err              : bool;  (*príznak chyby*)
    errTxt           : string [80];  (*popis chyby*)
    fileSize         : udint;  (*velikost souboru*)
    processed        : udint;  (*zpracováno (pocet znaku)*)
  END_VAR
  VAR
    rqInit           : bool;
    rqFile           : bool;
    rqParse          : bool;
    rqStart          : bool;
    trgExecOn        : R_TRIG;
    ReadFile         : ReadFromFile;
    JsonParser       : fbJsonParserEx;
    JsonBuffer       : ARRAY [0..768] OF usint;
    sumaLen          : udint;  (*kolik nacteno ze souboru*)
    actLen           : udint;  (*aktualni velikost JSON bufferu*)
    restLen          : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbJsonPageParser
(*Parsování JSON dokumentu z web stránky. Informace o vyparsované poloce je uloena do struktury TjsonInfo.*)
  VAR CONSTANT
    JSON_BUMBER      : uint :=  256;  (*nárazník v json bufferu*)
    JSON_BUFFER_SIZE : uint :=  768;  (*velikost bufferu*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*parsovat json soubor*)
    chanCode         : uint;  (*komunikaèní kanál (ETH1_uni0, ETH1_uni1,...)*)
  END_VAR
  VAR_IN_OUT
    pageName         : string [255];  (*název web stránky s s json dokumentem*)
    JsonInfo         : TJsonInfo;  (*vısledek parsování*)
  END_VAR
  VAR_OUTPUT
    start            : bool;  (*pøíznak inicializace bloku*)
    done             : bool;  (*vısledek parsování je pøipraven v jsonInfo*)
    busy             : bool;  (*blok je zaneprázdnìn*)
    eof              : bool;  (*konec souboru*)
    break            : bool;  (*buffer zpracován, pokraèovat pøíští cyklus*)
    err              : bool;  (*pøíznak chyby*)
    errTxt           : string [80];  (*popis chyby*)
    fileSize         : udint;  (*velikost souboru*)
    processed        : udint;  (*zpracováno (poèet znakù)*)
  END_VAR
  VAR
    rqShrink         : bool;
    rqFile           : bool;
    rqParse          : bool;
    rqStart          : bool;
    trgExecOn        : R_TRIG;
    JsonParser       : fbJsonParserEx;
    JsonBuffer       : ARRAY [0..768] OF usint;
    sumaLen          : udint;  (*kolik nacteno ze souboru*)
    actLen           : udint;  (*aktualni velikost json bufferu*)
    restLen          : uint;
    pos              : int;
    HttpIP           : TIPadr;
    HttpPort         : uint;
    HttpName         : string [80];
    Action           : string [80];
    Empty            : string [1];
    dnsRequest       : bool;
    SplitUrlAddress  : fbSplitUrlAddress;
    HttpRequest      : fbHttpRequest;
  END_VAR
  VAR CONSTANT
    HTTP_IP_NULL     : TIPadr :=  [0,0,0,0];
  END_VAR
END_FUNCTION_BLOCK



{LIBFILE="LOCALLIB\CRCLIB_V13_20170224.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : C:\TecoLib\CrcLib_V13_20170224.mlb *)
(* Knihovna : CrcLib 1.3 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c) 2005,..,2017 Teco a.s. *)
(* Verze IEC pøekladaèe : 3.12.11.0 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : CrcLib 1.3  }
(* Historie: *)
(*
v1.0 01.08.2005 Nem úvodní verze knihovny
v1.1 17.04.2009 Nem odstranìna varovná hlášení pøekladaèe pøi pøekladu knihovny
v1.2 02.09.2010 Nem doplnìna historie verzí
                    doplnìny závislosti na knihovnách
v1.3 24.02.2017 Nem doplnìna funkce CheckCRC_32
*)

(*----------------------------------------------------------------------------*)

__DECL FUNCTION CheckCRC_16 : uint
(*Vıpoèet polynomu (x16 + x15 + x2 + 1)
  
	Funkce vrací UINT polynom*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer na pole bytù*)
    length           : uint;  (*délka pole (poèet bytù)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckSum : usint
(*Vıpoèet aritmetického souètu pole bytù modulo 256
	
	Funkce vrací souèet modulo 256*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer na pole bytù*)
    length           : uint;  (*délka pole (poèet bytù)*)
  END_VAR
  VAR
    i                : uint;
    sum              : usint;
    ptrc             : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckSum_XOR : usint
(*Vıpoèet logického XOR pole bytù

	Funkce vrací XOR všech bytù v poli*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer na pole bytù*)
    length           : uint;  (*délka pole (poèet bytù)*)
  END_VAR
  VAR
    i                : uint;
    sum              : byte;
    ptrc             : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckCRC_CCITT : uint
(*Vıpoèet polynomu (x16 + x12 + x5 + 1)
	(pouívanı v PCD SAIA nebo GFR)

	Funkce vrací UINT polynom*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer na pole bytù*)
    length           : uint;  (*délka pole (poèet bytù)*)
  END_VAR
  VAR
    valCRC           : word;
    tmp              : word;
    i                : uint;
    j                : uint;
    ptrMsg           : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckCRC_TECO : uint
(*Vıpoèet polynomu (x16 + x6 + x3 + 1)
	(pouívanı v systémech Tecomat)
	
	Funkce vrací UINT polynom*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer na pole bytù*)
    length           : uint;  (*délka pole (poèet bytù)*)
  END_VAR
  VAR
    valCRC           : word;
    tmp              : word;
    i                : uint;
    j                : uint;
    ptrMsg           : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckCRC_DIN : uint
(*Vıpoèet polynomu podle normy DIN 66 348
  
	Funkce vrací UINT polynom*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer na pole bytù*)
    length           : uint;  (*délka pole (poèet bytù)*)
  END_VAR
  VAR
    tmp              : word;
    valCRC           : word;
    i                : uint;
    j                : uint;
    ptrMsg           : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckCRC_ARNEP : uint
(*Vıpoèet polynomu pro Conel sí ARNEP
  
	Funkce vrací UINT polynom*)
  VAR_INPUT
    ptr              : PTR_TO usint;  (*pointer na pole bytù*)
    length           : uint;  (*délka pole (poèet bytù)*)
  END_VAR
  VAR
    valCRC           : word;
    tmp              : byte;
    i                : uint;
    j                : uint;
    ptrMsg           : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION CheckCRC_32 : udint
(*------------------------------------------------------------------------------
  Function calculates polynomial (X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X+1) of byte array
  Return value : UDINT polynomial*)
  VAR_INPUT
    ptr              : PTR_TO usint;
    length           : uint;
  END_VAR
  VAR
    valCRC           : dword;
    mask             : dword;
    i                : uint;
    j                : uint;
    ptrMsg           : PTR_TO byte;
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\CANVASLIB_V21_20170112.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : D:\TecoUserLibs\CanvasLib_V21_20170112.mlb *)
(* Knihovna : CanvasLib 2.1 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c)2014 - 2017 Teco a.s. *)
(* Verze IEC pøekladaèe : 3.11.10.0 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : CanvasLib 2.1  }
(* Historie: *)
(*
v1.6 19.12.2010 Byd První vydání knihovny
v1.7 06.01.2011 Byd Pøidány funkce GC_GraphLineRealArray
v1.8 12.08.2015 Byd Pøidány barvy z palety Material Design
                    Opravena konstanta GLSCALE_HORIZONTAL
v1.9 02.02.2016 Byd Pøidána vıchozí hodnota stylu èáry
                    Upravena funkce GC_BEGIN, aby byla bezpeènì aktualizována hodnota velikosti grafického bufferu
v2.0 06.10.2016 Byd Pøidán blok GC_GraphPolygonRealArray
v2.1 12.01.2017 Byd Pøidán blok GC_GraphLineXYRealArray
*)

(*----------------------------------------------------------------------------*)

TYPE TCanvasInfo :
  STRUCT  (*informace o kreslícím plátnu*)
    ver              : usint :=  2;  (*verze struktury bufferu*)
    flags            : usint;  (*pøíznaky (.0 = 1 buffer je otevøen pro zápis)*)
    maxLen           : uint;  (*maximalní délka bufferu (o 1 byte menší, aby se do bufferu vdy vešla znaèka konec bufferu)*)
    actLen           : uint;  (*aktualní délka bufferu (rozpracovaná)*)
    macroptr         : uint;  (*pomocná promìnná pro definici makra*)
  END_STRUCT;
END_TYPE

TYPE TCanvasPoint :
  STRUCT  (*bod na kreslícím plátnu*)
    x                : int;  (*souøadnice X*)
    y                : int;  (*souøadnice Y*)
  END_STRUCT;
END_TYPE

TYPE TCanvasTouch :
  STRUCT  (*pozice dotyku/kliknutí na kreslícím plátnu a barva, na kterou ukazuje*)
    x                : int :=  -32767;  (*X souøadnice místa dotyku/kliknutí (-32767 bez dotyku/kliknutí)*)
    y                : int :=  -32767;  (*Y souøadnice místa dotyku/kliknutí (-32767 bez dotyku/kliknutí)*)
    color            : udint;  (*barva v místì dotyku/kliknutí*)
  END_STRUCT;
END_TYPE

TYPE TCanvasHeadBuf :
  STRUCT  (*hlavièka bufferu kreslícího plátna*)
    dataChg          : uint;  (*unikátní èíslo indikující zmìnu dat*)
    dataLen          : uint;  (*celková delka dat v bufferu*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData64 :
  STRUCT  (*datová struktura pro kreslící plátno, 64 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 63);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..63] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData128 :
  STRUCT  (*datová struktura pro kreslící plátno, 128 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 127);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..127] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData256 :
  STRUCT  (*datová struktura pro kreslící plátno, 256 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 255);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..255] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData384 :
  STRUCT  (*datová struktura pro kreslící plátno, 384 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 383);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..383] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData512 :
  STRUCT  (*datová struktura pro kreslící plátno, 512 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 511);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..511] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData768 :
  STRUCT  (*datová struktura pro kreslící plátno, 768 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 767);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..767] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData1024 :
  STRUCT  (*datová struktura pro kreslící plátno, 1024 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 1023);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..1023] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData1536 :
  STRUCT  (*datová struktura pro kreslící plátno, 1536 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 1535);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..1535] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData2048 :
  STRUCT  (*datová struktura pro kreslící plátno, 2048 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 2047);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..2047] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData3072 :
  STRUCT  (*datová struktura pro kreslící plátno, 3072 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 3071);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..3071] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData4096 :
  STRUCT  (*datová struktura pro kreslící plátno, 4095 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 4095);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..4095] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData6144 :
  STRUCT  (*datová struktura pro kreslící plátno, 6144 bytù*)
    info             : TCanvasInfo :=  ( maxLen := 6143);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..6143] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

TYPE TCanvasData :
  STRUCT  (*datová struktura pro kreslící plátno, maximální velikost*)
    info             : TCanvasInfo :=  ( maxLen := 8191);  (*informace o bufferu*)
    touch            : TCanvasTouch;  (*informace o dotyku/kliknutí*)
    bufHead          : TCanvasHeadBuf;  (*hlavièka bufferu*)
    buf              : ARRAY [0..8191] OF usint;  (*data*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 GPRIMITIVE_BEGIN {HIDDEN} : usint :=  16#01;  (*zacatek bufferu*)
 GPRIMITIVE_END {HIDDEN} : usint :=  16#02;  (*konec bufferu, vykreslit vsechna primitiva*)
 GPRIMITIVE_SETLINEWIDTH {HIDDEN} : usint :=  16#03;  (*zmena tloustky cary*)
 GPRIMITIVE_SETLINESTYLE {HIDDEN} : usint :=  16#04;  (*zmena stylu cary*)
 GPRIMITIVE_SETFGCOLOR {HIDDEN} : usint :=  16#05;  (*zmena barvy popredi (car, pisma)*)
 GPRIMITIVE_SETBGCOLOR {HIDDEN} : usint :=  16#06;  (*zmena barvy pozadi (vyplne, podkladu)*)
 GPRIMITIVE_SETTEXTSIZE {HIDDEN} : usint :=  16#07;  (*zmena velikosti pisma*)
 GPRIMITIVE_SETTEXTSTYLE {HIDDEN} : usint :=  16#08;  (*zmena stylu pisma*)
 GPRIMITIVE_SETGRADIENTSTYLE {HIDDEN} : usint :=  16#09;  (*zmena stylu gradientu*)
 GPRIMITIVE_SETORIGIN {HIDDEN} : usint :=  16#0A;  (*presune pocatek souradnic do pozice kresliciho pera*)
 GPRIMITIVE_RESETORIGIN {HIDDEN} : usint :=  16#0B;  (*presune pocatek souradnic do vychozi pozice*)
 GPRIMITIVE_SETVIRTSIZE {HIDDEN} : usint :=  16#0C;  (*nastavi virtualni rozmer kreslici plochy, pri zobrazeni se prepocita na skutecny rozmer canvasu*)
 GPRIMITIVE_SETFILLSTYLE {HIDDEN} : usint :=  16#0D;  (*zmena stylu vyplne*)
 GPRIMITIVE_POINT {HIDDEN} : usint :=  16#10;  (*bod*)
 GPRIMITIVE_LINE {HIDDEN} : usint :=  16#11;  (*cara x1,y1 -> x2,y2*)
 GPRIMITIVE_MOVETO {HIDDEN} : usint :=  16#12;  (*nastaveni nove souradnice kresliciho pera*)
 GPRIMITIVE_LINETO {HIDDEN} : usint :=  16#13;  (*cara z minuleho bodu do x,y*)
 GPRIMITIVE_BOX {HIDDEN} : usint :=  16#14;  (*obdelnik*)
 GPRIMITIVE_FILLBOX {HIDDEN} : usint :=  16#15;  (*vyplneny obdelnik*)
 GPRIMITIVE_POLYGON {HIDDEN} : usint :=  16#16;  (*polygon*)
 GPRIMITIVE_FILLPOLYGON {HIDDEN} : usint :=  16#17;  (*vyplneny polygon*)
 GPRIMITIVE_CIRCLE {HIDDEN} : usint :=  16#18;  (*kruznice*)
 GPRIMITIVE_FILLCIRCLE {HIDDEN} : usint :=  16#19;  (*kruh*)
 GPRIMITIVE_ARC {HIDDEN} : usint :=  16#1A;  (*oblouk*)
 GPRIMITIVE_FILLARC {HIDDEN} : usint :=  16#1B;  (*vyplneny oblouk*)
 GPRIMITIVE_WRITETEXT {HIDDEN} : usint :=  16#1C;  (*vypis textu ppravo od pozice kresliciho pera*)
 GPRIMITIVE_IMAGE {HIDDEN} : usint :=  16#1D;  (*zobrazeni obrazku*)
 GPRIMITIVE_MOVE {HIDDEN} : usint :=  16#20;  (*relativni zmena souradnice kresliciho pera*)
 GPRIMITIVE_CBOX {HIDDEN} : usint :=  16#21;  (*centrovany obdelnik*)
 GPRIMITIVE_CFILLBOX {HIDDEN} : usint :=  16#22;  (*centrovany vyplneny obdelnik*)
 GPRIMITIVE_CFILLARC {HIDDEN} : usint :=  16#23;  (*vyplneny oblouk se stredem na pozici kresliciho pera*)
 GPRIMITIVE_CWRITETEXT {HIDDEN} : usint :=  16#24;  (*centrovany vypis textu*)
 GPRIMITIVE_CIMAGE {HIDDEN} : usint :=  16#25;  (*centrovane zobrazeni obrazku*)
 GPRIMITIVE_CCIRCLE {HIDDEN} : usint :=  16#26;  (*centrovana kruznice*)
 GPRIMITIVE_CFILLCIRCLE {HIDDEN} : usint :=  16#27;  (*centrovany kruh*)
 GPRIMITIVE_HEADING {HIDDEN} : usint :=  16#28;  (*nastaveni uhlu kresliciho pera*)
 GPRIMITIVE_TURN {HIDDEN} : usint :=  16#29;  (*zmena uhlu kresliciho pera (+=doprava, -=doleva)*)
 GPRIMITIVE_LINEFWD {HIDDEN} : usint :=  16#2A;  (*posun kresliciho pera podle jeho uhlu (kresli caru)*)
 GPRIMITIVE_MOVEFWD {HIDDEN} : usint :=  16#2B;  (*posun kresliciho pera podle jeho uhlu (nekresli caru)*)
 GPRIMITIVE_PUSHPOSITION {HIDDEN} : usint :=  16#2C;  (*ulozi aktualni pozici kresliciho pera*)
 GPRIMITIVE_POPPOSITION {HIDDEN} : usint :=  16#2D;  (*obnovi aktualni pozici kresliciho pera*)
 GPRIMITIVE_CPOLYGON {HIDDEN} : usint :=  16#2E;  (*polygon, natoceny podle uhlu kresliciho pera, souradnice jsou relativni k pozici kresliciho pera pri uhlu 0st*)
 GPRIMITIVE_CFILLPOLYGON {HIDDEN} : usint :=  16#2F;  (*vyplneny polygon, natoceny podle uhlu kresliciho pera, souradnice jsou relativni k pozici kresliciho pera pri uhlu 0st*)
 GPRIMITIVE_GRAPHLINE {HIDDEN} : usint :=  16#30;  (*vykresli data pro carovy graf*)
 GPRIMITIVE_GRAPHBARS {HIDDEN} : usint :=  16#31;  (*vykresli data pro sloupcovy graf*)
 GPRIMITIVE_PUSHHEADING {HIDDEN} : usint :=  16#32;  (*ulozi aktualni uhel kresliciho pera*)
 GPRIMITIVE_POPHEADING {HIDDEN} : usint :=  16#33;  (*obnovi aktualni uhel kresliciho pera*)
 GPRIMITIVE_MACROBEGIN {HIDDEN} : usint :=  16#34;  (*zacatek definice marka*)
 GPRIMITIVE_MACROEND {HIDDEN} : usint :=  16#35;  (*konec definice marka*)
 GPRIMITIVE_MACRORUN {HIDDEN} : usint :=  16#36;  (*volani marka*)
 GPRIMITIVE_RADIALSCALE {HIDDEN} : usint :=  16#37;  (*kruhová stupnice*)
 GPRIMITIVE_LINEARSCALE {HIDDEN} : usint :=  16#38;  (*lineární stupnice*)
 GPRIMITIVE_ROUNDBOX {HIDDEN} : usint :=  16#39;  (*obdélník se zaoblenımi rohy*)
 GPRIMITIVE_ROUNDFILLBOX {HIDDEN} : usint :=  16#3A;  (*vyplnìnı obdélník se zaoblenımi rohy*)
 GPRIMITIVE_CROUNDBOX {HIDDEN} : usint :=  16#3B;  (*centrovanı obdélník se zaoblenımi rohy*)
 GPRIMITIVE_CROUNDFILLBOX {HIDDEN} : usint :=  16#3C;  (*centrovanı vyplnìnı obdélník se zaoblenımi rohy*)
 GPRIMITIVE_CARC {HIDDEN} : usint :=  16#3D;  (*oblouk se stredem na pozici kresliciho pera*)
 GTEXT_STYLE_NORMAL : uint :=  16#0000;  (*normalní písmo*)
 GTEXT_STYLE_BOLD : uint :=  16#0001;  (*tuèné písmo*)
 GTEXT_STYLE_ITALIC : uint :=  16#0002;  (*kurzíva*)
 GTEXT_STYLE_FILLBG : uint :=  16#0004;  (*vyplnit pod textem podklad*)
 GTEXT_STYLE_ALIGN_LEFT : uint :=  16#0000;  (*víceøadkovı text - zarovnat øádky vlevo*)
 GTEXT_STYLE_ALIGN_RIGHT : uint :=  16#0010;  (*víceøadkovı text - zarovnat øádky vpravo*)
 GTEXT_STYLE_ALIGN_CENTER : uint :=  16#0020;  (*víceøadkovı text - zarovnat øádky doprostøed*)
 GTEXT_STYLE_HRIGHT : uint :=  16#0000;  (*vıpis textu vpravo od pozice kreslícího pera*)
 GTEXT_STYLE_HLEFT : uint :=  16#0040;  (*vıpis textu vlevo od pozice kreslícího pera*)
 GTEXT_STYLE_HCENTER : uint :=  16#0080;  (*pozice kreslicího pera je ve støedu øádky*)
 GTEXT_STYLE_VDOWN : uint :=  16#0000;  (*vıpis textu od pozice kreslíciho pera dolù*)
 GTEXT_STYLE_VUP : uint :=  16#0100;  (*vıpis textu od pozice kreslíciho pera nahoru*)
 GTEXT_STYLE_VCENTER : uint :=  16#0200;  (*pozice kreslícího pera je ve støedu*)
 GLINE_STYLE_SOLID : usint :=  16#00;  (*plná èára*)
 GLINE_STYLE_DASH : usint :=  16#01;  (*èarkovana èára*)
 GLINE_STYLE_DOTDASH : usint :=  16#02;  (*èerchovana èára*)
 GLINE_STYLE_DOT : usint :=  16#03;  (*teèkovana èára*)
 GLINE_CAP_BUTT : usint :=  16#00;  (*normalní konec èáry v koncovém bodì*)
 GLINE_CAP_ROUND : usint :=  16#10;  (*zakulacenı konec èáry se støedem v koncovém bodì*)
 GLINE_CAP_SQUARE : usint :=  16#20;  (*hranatı konec èáry se støedem v koncovém bodì*)
 GLINE_JOIN_MITTER : usint :=  16#00;  (*normalní napojení èar s ostrım rohem*)
 GLINE_JOIN_ROUND : usint :=  16#40;  (*napojení èar se zakulacenım rohem*)
 GLINE_JOIN_BEVEL : usint :=  16#80;  (*napojení èar se zkosenım rohem*)
 GFILL_STYLE_BGCOLOR : usint :=  16#00;  (*vıplò barvou pozadí*)
 GFILL_STYLE_FRAME : usint :=  16#01;  (*vıplò vèetnì obrysu (obrys kreslit barvou popøedí)*)
 GFILL_STYLE_GRADIENT : usint :=  16#02;  (*vıplò gradientem*)
 GGRADIENT_STYLE_LINEAR : usint :=  16#00;  (*lineární gradient*)
 GGRADIENT_STYLE_BAR1_3 : usint :=  16#02;  (*dva opaèné linearní gradienty vedle sebe o širce 1/3 a 2/3*)
 GGRADIENT_STYLE_RADIAL : usint :=  16#01;  (*kruhovı gradient, první barva je ve støedu*)
 GGRADIENT_STYLE_RADIAL1_3 : usint :=  16#03;  (*kruhovı gradient, první barva je posunuta o 1/3 vlevo nahoru*)
 GGRADIENT_STYLE_HORIZONTAL : usint :=  16#80;  (*gradient zleva doprava (místo shora dolù)*)
 GPOS_TYPE_PCT : int :=  16#4000;  (*pøíznak, e souøadnice není v bodech ale v procentech*)
 GGRAPH_LINE_DEFAULT : usint :=  16#00;  (*základní styl èáry*)
 GGRAPH_LINE_SHOWDOT : usint :=  16#01;  (*zobrazit datové znaèky (koleèka)*)
 GGRAPH_LINE_SHOWCROSS : usint :=  16#02;  (*zobrazit datové znaèky (køíky)*)
 GGRAPH_LINE_NOLINES : usint :=  16#08;  (*nekreslit èáry (jen bodovy graf)*)
 GGRAPH_LINE_INTERPOLATE : usint :=  16#10;  (*interpolace dat*)
 GGRAPH_LINE_FILL : usint :=  16#20;  (*vyplnit plochu pod èarou k ose x*)
 GCOLOR_TRANSPARENT : udint :=  16#FF000000;  (*zcela prùhledná*)
 GCOLOR_TRANSPARENT3_4 : udint :=  16#C0000000;  (*ze 3/4 prùhledná*)
 GCOLOR_TRANSPARENT1_2 : udint :=  16#80000000;  (*ze 1/2 prùhledná*)
 GCOLOR_TRANSPARENT1_4 : udint :=  16#40000000;  (*z  1/4 prùhledná*)
 GCOLOR_WHITE : udint :=  16#00FFFFFF;  (*bílá*)
 GCOLOR_BLACK : udint :=  16#00000001;  (*èerná*)
 GCOLOR_RED : udint :=  16#000000FF;  (*èervená*)
 GCOLOR_ORANGE : udint :=  16#000080FF;  (*oranová*)
 GCOLOR_YELLOW : udint :=  16#0000FFFF;  (*lutá*)
 GCOLOR_CHARTREUSE : udint :=  16#0000FF80;  (*chertreuse*)
 GCOLOR_GREEN : udint :=  16#0000FF00;  (*zelená*)
 GCOLOR_SPRINGGREEN : udint :=  16#0080FF00;  (*jarní zelená*)
 GCOLOR_CYAN : udint :=  16#00FFFF00;  (*azurová*)
 GCOLOR_AZURE : udint :=  16#00FF8000;  (*blankytná*)
 GCOLOR_BLUE : udint :=  16#00FF0000;  (*modrá*)
 GCOLOR_VIOLET : udint :=  16#00FF0080;  (*fialová*)
 GCOLOR_MAGENTA : udint :=  16#00FF00FF;  (*purpurová*)
 GCOLOR_ROSE : udint :=  16#008000FF;  (*rùová*)
 GCOLOR_LTGRAY : udint :=  16#00C0C0C0;  (*svìtle šedá*)
 GCOLOR_GRAY : udint :=  16#00808080;  (*šedá*)
 GCOLOR_DKGRAY : udint :=  16#00404040;  (*tmavì šedá*)
 GCOLOR_RED_50 : udint :=    16#EEEBFF;  (*èervená*)
 GCOLOR_RED_100 : udint :=   16#D2CDFF;  (*èervená*)
 GCOLOR_RED_200 : udint :=   16#9A9AEF;  (*èervená*)
 GCOLOR_RED_300 : udint :=   16#7373E5;  (*èervená*)
 GCOLOR_RED_400 : udint :=   16#5053EF;  (*èervená*)
 GCOLOR_RED_500 : udint :=   16#3643F4;  (*èervená*)
 GCOLOR_RED_600 : udint :=   16#3539E5;  (*èervená*)
 GCOLOR_RED_700 : udint :=   16#2F2FD3;  (*èervená*)
 GCOLOR_RED_800 : udint :=   16#2828C6;  (*èervená*)
 GCOLOR_RED_900 : udint :=   16#1C1CB7;  (*èervená*)
 GCOLOR_RED_A100 : udint :=  16#808AFF;  (*èervená*)
 GCOLOR_RED_A200 : udint :=  16#5252FF;  (*èervená*)
 GCOLOR_RED_A400 : udint :=  16#4417FF;  (*èervená*)
 GCOLOR_RED_A700 : udint :=  16#0000D5;  (*èervená*)
 GCOLOR_PINK_50 : udint :=    16#ECE4FC;  (*rùová*)
 GCOLOR_PINK_100 : udint :=   16#D0BBF8;  (*rùová*)
 GCOLOR_PINK_200 : udint :=   16#B18FF4;  (*rùová*)
 GCOLOR_PINK_300 : udint :=   16#9262F0;  (*rùová*)
 GCOLOR_PINK_400 : udint :=   16#7A40EC;  (*rùová*)
 GCOLOR_PINK_500 : udint :=   16#631EE9;  (*rùová*)
 GCOLOR_PINK_600 : udint :=   16#601BD8;  (*rùová*)
 GCOLOR_PINK_700 : udint :=   16#5B18C2;  (*rùová*)
 GCOLOR_PINK_800 : udint :=   16#5714AD;  (*rùová*)
 GCOLOR_PINK_900 : udint :=   16#4F0E88;  (*rùová*)
 GCOLOR_PINK_A100 : udint :=  16#AB80FF;  (*rùová*)
 GCOLOR_PINK_A200 : udint :=  16#8140FF;  (*rùová*)
 GCOLOR_PINK_A400 : udint :=  16#5700F5;  (*rùová*)
 GCOLOR_PINK_A700 : udint :=  16#6211C5;  (*rùová*)
 GCOLOR_PURPLE_50 : udint :=    16#F5E5F3;  (*nachová*)
 GCOLOR_PURPLE_100 : udint :=   16#E7BEE1;  (*nachová*)
 GCOLOR_PURPLE_200 : udint :=   16#D893CE;  (*nachová*)
 GCOLOR_PURPLE_300 : udint :=   16#C868BA;  (*nachová*)
 GCOLOR_PURPLE_400 : udint :=   16#BC47AB;  (*nachová*)
 GCOLOR_PURPLE_500 : udint :=   16#B0279C;  (*nachová*)
 GCOLOR_PURPLE_600 : udint :=   16#AA248E;  (*nachová*)
 GCOLOR_PURPLE_700 : udint :=   16#A21F7B;  (*nachová*)
 GCOLOR_PURPLE_800 : udint :=   16#9A1B6A;  (*nachová*)
 GCOLOR_PURPLE_900 : udint :=   16#8C144A;  (*nachová*)
 GCOLOR_PURPLE_A100 : udint :=  16#FC80EA;  (*nachová*)
 GCOLOR_PURPLE_A200 : udint :=  16#FB40E0;  (*nachová*)
 GCOLOR_PURPLE_A400 : udint :=  16#F900D5;  (*nachová*)
 GCOLOR_PURPLE_A700 : udint :=  16#FF00AA;  (*nachová*)
 GCOLOR_DEEP_PURPLE_50 : udint :=    16#F6E7ED;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_100 : udint :=   16#E9C4D1;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_200 : udint :=   16#DB9DB3;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_300 : udint :=   16#CD7595;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_400 : udint :=   16#C2577E;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_500 : udint :=   16#B73A67;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_600 : udint :=   16#B1355E;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_700 : udint :=   16#A82D51;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_800 : udint :=   16#A02745;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_900 : udint :=   16#921B31;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_A100 : udint :=  16#FF88B3;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_A200 : udint :=  16#FF4D7C;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_A400 : udint :=  16#FF1F65;  (*tmavì nachová*)
 GCOLOR_DEEP_PURPLE_A700 : udint :=  16#EA0062;  (*tmavì nachová*)
 GCOLOR_INDIGO_50 : udint :=    16#F6EAE8;  (*indigo*)
 GCOLOR_INDIGO_100 : udint :=   16#E9CAC5;  (*indigo*)
 GCOLOR_INDIGO_200 : udint :=   16#DAA89F;  (*indigo*)
 GCOLOR_INDIGO_300 : udint :=   16#CB8679;  (*indigo*)
 GCOLOR_INDIGO_400 : udint :=   16#C06B5C;  (*indigo*)
 GCOLOR_INDIGO_500 : udint :=   16#B5513F;  (*indigo*)
 GCOLOR_INDIGO_600 : udint :=   16#AB4939;  (*indigo*)
 GCOLOR_INDIGO_700 : udint :=   16#9F3F30;  (*indigo*)
 GCOLOR_INDIGO_800 : udint :=   16#933528;  (*indigo*)
 GCOLOR_INDIGO_900 : udint :=   16#7E231A;  (*indigo*)
 GCOLOR_INDIGO_A100 : udint :=  16#FF9E8C;  (*indigo*)
 GCOLOR_INDIGO_A200 : udint :=  16#FE6D53;  (*indigo*)
 GCOLOR_INDIGO_A400 : udint :=  16#FE5A3D;  (*indigo*)
 GCOLOR_INDIGO_A700 : udint :=  16#FE4F30;  (*indigo*)
 GCOLOR_BLUE_50 : udint :=    16#FDF2E3;  (*modrá*)
 GCOLOR_BLUE_100 : udint :=   16#FBDEBB;  (*modrá*)
 GCOLOR_BLUE_200 : udint :=   16#F9CA90;  (*modrá*)
 GCOLOR_BLUE_300 : udint :=   16#F6B564;  (*modrá*)
 GCOLOR_BLUE_400 : udint :=   16#F5A542;  (*modrá*)
 GCOLOR_BLUE_500 : udint :=   16#F39621;  (*modrá*)
 GCOLOR_BLUE_600 : udint :=   16#E5881E;  (*modrá*)
 GCOLOR_BLUE_700 : udint :=   16#D27619;  (*modrá*)
 GCOLOR_BLUE_800 : udint :=   16#C06515;  (*modrá*)
 GCOLOR_BLUE_900 : udint :=   16#A1470D;  (*modrá*)
 GCOLOR_BLUE_A100 : udint :=  16#FFB182;  (*modrá*)
 GCOLOR_BLUE_A200 : udint :=  16#FF8A44;  (*modrá*)
 GCOLOR_BLUE_A400 : udint :=  16#FF7929;  (*modrá*)
 GCOLOR_BLUE_A700 : udint :=  16#FF6229;  (*modrá*)
 GCOLOR_LIGHT_BLUE_50 : udint :=    16#FEF5E1;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_100 : udint :=   16#FCE5B3;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_200 : udint :=   16#FAD481;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_300 : udint :=   16#F7C34F;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_400 : udint :=   16#F6B629;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_500 : udint :=   16#F4A903;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_600 : udint :=   16#E59B03;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_700 : udint :=   16#D18802;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_800 : udint :=   16#BD7702;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_900 : udint :=   16#9B5701;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_A100 : udint :=  16#FFD880;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_A200 : udint :=  16#FFC440;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_A400 : udint :=  16#FFB000;  (*svìtle modrá*)
 GCOLOR_LIGHT_BLUE_A700 : udint :=  16#EA9100;  (*svìtle modrá*)
 GCOLOR_CYAN_50 : udint :=    16#FAF7E0;  (*azurová*)
 GCOLOR_CYAN_100 : udint :=   16#F2EBB2;  (*azurová*)
 GCOLOR_CYAN_200 : udint :=   16#EADE80;  (*azurová*)
 GCOLOR_CYAN_300 : udint :=   16#E1D04D;  (*azurová*)
 GCOLOR_CYAN_400 : udint :=   16#DAC626;  (*azurová*)
 GCOLOR_CYAN_500 : udint :=   16#D4BC00;  (*azurová*)
 GCOLOR_CYAN_600 : udint :=   16#C1AC00;  (*azurová*)
 GCOLOR_CYAN_700 : udint :=   16#A79700;  (*azurová*)
 GCOLOR_CYAN_800 : udint :=   16#8F8300;  (*azurová*)
 GCOLOR_CYAN_900 : udint :=   16#646000;  (*azurová*)
 GCOLOR_CYAN_A100 : udint :=  16#FFFF84;  (*azurová*)
 GCOLOR_CYAN_A200 : udint :=  16#FFFF18;  (*azurová*)
 GCOLOR_CYAN_A400 : udint :=  16#FFE500;  (*azurová*)
 GCOLOR_CYAN_A700 : udint :=  16#D4B800;  (*azurová*)
 GCOLOR_TEAL_50 : udint :=    16#F1F2E0;  (*modrozelená*)
 GCOLOR_TEAL_100 : udint :=   16#DBDFB2;  (*modrozelená*)
 GCOLOR_TEAL_200 : udint :=   16#C4CB80;  (*modrozelená*)
 GCOLOR_TEAL_300 : udint :=   16#ACB64D;  (*modrozelená*)
 GCOLOR_TEAL_400 : udint :=   16#9AA626;  (*modrozelená*)
 GCOLOR_TEAL_500 : udint :=   16#889600;  (*modrozelená*)
 GCOLOR_TEAL_600 : udint :=   16#7B8900;  (*modrozelená*)
 GCOLOR_TEAL_700 : udint :=   16#6B7900;  (*modrozelená*)
 GCOLOR_TEAL_800 : udint :=   16#5C6900;  (*modrozelená*)
 GCOLOR_TEAL_900 : udint :=   16#404D00;  (*modrozelená*)
 GCOLOR_TEAL_A100 : udint :=  16#EBFFA7;  (*modrozelená*)
 GCOLOR_TEAL_A200 : udint :=  16#DAFF64;  (*modrozelená*)
 GCOLOR_TEAL_A400 : udint :=  16#B6E91D;  (*modrozelená*)
 GCOLOR_TEAL_A700 : udint :=  16#A5BF00;  (*modrozelená*)
 GCOLOR_GREEN_50 : udint :=    16#E9F5E8;  (*zelená*)
 GCOLOR_GREEN_100 : udint :=   16#C9E6C8;  (*zelená*)
 GCOLOR_GREEN_200 : udint :=   16#A7D6A5;  (*zelená*)
 GCOLOR_GREEN_300 : udint :=   16#84C781;  (*zelená*)
 GCOLOR_GREEN_400 : udint :=   16#6ABB66;  (*zelená*)
 GCOLOR_GREEN_500 : udint :=   16#50AF4C;  (*zelená*)
 GCOLOR_GREEN_600 : udint :=   16#47A043;  (*zelená*)
 GCOLOR_GREEN_700 : udint :=   16#3C8E38;  (*zelená*)
 GCOLOR_GREEN_800 : udint :=   16#327D2E;  (*zelená*)
 GCOLOR_GREEN_900 : udint :=   16#205E1B;  (*zelená*)
 GCOLOR_GREEN_A100 : udint :=  16#CAF6B9;  (*zelená*)
 GCOLOR_GREEN_A200 : udint :=  16#AEF069;  (*zelená*)
 GCOLOR_GREEN_A400 : udint :=  16#76E600;  (*zelená*)
 GCOLOR_GREEN_A700 : udint :=  16#53C800;  (*zelená*)
 GCOLOR_LIGHT_GREEN_50 : udint :=    16#E9F8F1;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_100 : udint :=   16#C8EDDC;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_200 : udint :=   16#A5E1C5;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_300 : udint :=   16#81D5AE;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_400 : udint :=   16#65CC9C;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_500 : udint :=   16#4AC38B;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_600 : udint :=   16#42B37C;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_700 : udint :=   16#389F68;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_800 : udint :=   16#2F8B55;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_900 : udint :=   16#1E6933;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_A100 : udint :=  16#90FFCC;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_A200 : udint :=  16#59FFB2;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_A400 : udint :=  16#03FF76;  (*svìtle zelená*)
 GCOLOR_LIGHT_GREEN_A700 : udint :=  16#17DD64;  (*svìtle zelená*)
 GCOLOR_LIME_50 : udint :=    16#E7FBF9;  (*lutozelená*)
 GCOLOR_LIME_100 : udint :=   16#C3F4F0;  (*lutozelená*)
 GCOLOR_LIME_200 : udint :=   16#9CEEE6;  (*lutozelená*)
 GCOLOR_LIME_300 : udint :=   16#75E7DC;  (*lutozelená*)
 GCOLOR_LIME_400 : udint :=   16#57E1D4;  (*lutozelená*)
 GCOLOR_LIME_500 : udint :=   16#39DCCD;  (*lutozelená*)
 GCOLOR_LIME_600 : udint :=   16#33CAC0;  (*lutozelená*)
 GCOLOR_LIME_700 : udint :=   16#2BB4AF;  (*lutozelená*)
 GCOLOR_LIME_800 : udint :=   16#249D9E;  (*lutozelená*)
 GCOLOR_LIME_900 : udint :=   16#177782;  (*lutozelená*)
 GCOLOR_LIME_A100 : udint :=  16#81FFF4;  (*lutozelená*)
 GCOLOR_LIME_A200 : udint :=  16#41FFEE;  (*lutozelená*)
 GCOLOR_LIME_A400 : udint :=  16#00FFC6;  (*lutozelená*)
 GCOLOR_LIME_A700 : udint :=  16#00EAAE;  (*lutozelená*)
 GCOLOR_YELLOW_50 : udint :=  16#E7FDFF;  (*lutá*)
 GCOLOR_YELLOW_100 : udint :=  16#C4F9FF;  (*lutá*)
 GCOLOR_YELLOW_200 : udint :=  16#9DF5FF;  (*lutá*)
 GCOLOR_YELLOW_300 : udint :=  16#76F1FF;  (*lutá*)
 GCOLOR_YELLOW_400 : udint :=  16#58EEFF;  (*lutá*)
 GCOLOR_YELLOW_500 : udint :=  16#3BEBFF;  (*lutá*)
 GCOLOR_YELLOW_600 : udint :=  16#35D8FD;  (*lutá*)
 GCOLOR_YELLOW_700 : udint :=  16#2DC0FB;  (*lutá*)
 GCOLOR_YELLOW_800 : udint :=  16#25A8F9;  (*lutá*)
 GCOLOR_YELLOW_900 : udint :=  16#177FF5;  (*lutá*)
 GCOLOR_YELLOW_A100 : udint :=  16#8DFFFF;  (*lutá*)
 GCOLOR_YELLOW_A200 : udint :=  16#00FFFF;  (*lutá*)
 GCOLOR_YELLOW_A400 : udint :=  16#00EAFF;  (*lutá*)
 GCOLOR_YELLOW_A700 : udint :=  16#00D6FF;  (*lutá*)
 GCOLOR_AMBER_50 : udint :=  16#E1F8FF;  (*jantarová*)
 GCOLOR_AMBER_100 : udint :=  16#B3ECFF;  (*jantarová*)
 GCOLOR_AMBER_200 : udint :=  16#82E0FF;  (*jantarová*)
 GCOLOR_AMBER_300 : udint :=  16#4FD5FF;  (*jantarová*)
 GCOLOR_AMBER_400 : udint :=  16#28CAFF;  (*jantarová*)
 GCOLOR_AMBER_500 : udint :=  16#07C1FF;  (*jantarová*)
 GCOLOR_AMBER_600 : udint :=  16#00B3FF;  (*jantarová*)
 GCOLOR_AMBER_700 : udint :=  16#00A0FF;  (*jantarová*)
 GCOLOR_AMBER_800 : udint :=  16#008FFF;  (*jantarová*)
 GCOLOR_AMBER_900 : udint :=  16#006FFF;  (*jantarová*)
 GCOLOR_AMBER_A100 : udint :=  16#7FE5FF;  (*jantarová*)
 GCOLOR_AMBER_A200 : udint :=  16#40D7FF;  (*jantarová*)
 GCOLOR_AMBER_A400 : udint :=  16#00C4FF;  (*jantarová*)
 GCOLOR_AMBER_A700 : udint :=  16#00ABFF;  (*jantarová*)
 GCOLOR_ORANGE_50 : udint :=  16#E0F3FF;  (*oranová*)
 GCOLOR_ORANGE_100 : udint :=  16#B2E0FF;  (*oranová*)
 GCOLOR_ORANGE_200 : udint :=  16#80CCFF;  (*oranová*)
 GCOLOR_ORANGE_300 : udint :=  16#4DB7FF;  (*oranová*)
 GCOLOR_ORANGE_400 : udint :=  16#26A7FF;  (*oranová*)
 GCOLOR_ORANGE_500 : udint :=  16#0098FF;  (*oranová*)
 GCOLOR_ORANGE_600 : udint :=  16#008CFB;  (*oranová*)
 GCOLOR_ORANGE_700 : udint :=  16#007CF5;  (*oranová*)
 GCOLOR_ORANGE_800 : udint :=  16#006CEF;  (*oranová*)
 GCOLOR_ORANGE_900 : udint :=  16#0051E6;  (*oranová*)
 GCOLOR_ORANGE_A100 : udint :=  16#80D1FF;  (*oranová*)
 GCOLOR_ORANGE_A200 : udint :=  16#40ABFF;  (*oranová*)
 GCOLOR_ORANGE_A400 : udint :=  16#0091FF;  (*oranová*)
 GCOLOR_ORANGE_A700 : udint :=  16#006DFF;  (*oranová*)
 GCOLOR_DEEP_ORANGE_50 : udint :=  16#E7E9FB;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_100 : udint :=  16#BCCCFF;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_200 : udint :=  16#91ABFF;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_300 : udint :=  16#658AFF;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_400 : udint :=  16#4370FF;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_500 : udint :=  16#2257FF;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_600 : udint :=  16#1E51F4;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_700 : udint :=  16#194AE6;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_800 : udint :=  16#1543D8;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_900 : udint :=  16#0C36BF;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_A100 : udint :=  16#809EFF;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_A200 : udint :=  16#406EFF;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_A400 : udint :=  16#003DFF;  (*tmavì oranová*)
 GCOLOR_DEEP_ORANGE_A700 : udint :=  16#002CDD;  (*tmavì oranová*)
 GCOLOR_BROWN_50 : udint :=  16#E9EBEF;  (*hnìdá*)
 GCOLOR_BROWN_100 : udint :=  16#C8CCD7;  (*hnìdá*)
 GCOLOR_BROWN_200 : udint :=  16#A4AABC;  (*hnìdá*)
 GCOLOR_BROWN_300 : udint :=  16#7F88A1;  (*hnìdá*)
 GCOLOR_BROWN_400 : udint :=  16#636E8D;  (*hnìdá*)
 GCOLOR_BROWN_500 : udint :=  16#485579;  (*hnìdá*)
 GCOLOR_BROWN_600 : udint :=  16#414C6D;  (*hnìdá*)
 GCOLOR_BROWN_700 : udint :=  16#37405D;  (*hnìdá*)
 GCOLOR_BROWN_800 : udint :=  16#2E344E;  (*hnìdá*)
 GCOLOR_BROWN_900 : udint :=  16#23273E;  (*hnìdá*)
 GCOLOR_GREY_50 : udint :=  16#FAFAFA;  (*šedá*)
 GCOLOR_GREY_100 : udint :=  16#F5F5F5;  (*šedá*)
 GCOLOR_GREY_200 : udint :=  16#EEEEEE;  (*šedá*)
 GCOLOR_GREY_300 : udint :=  16#E0E0E0;  (*šedá*)
 GCOLOR_GREY_400 : udint :=  16#BDBDBD;  (*šedá*)
 GCOLOR_GREY_500 : udint :=  16#9E9E9E;  (*šedá*)
 GCOLOR_GREY_600 : udint :=  16#757575;  (*šedá*)
 GCOLOR_GREY_700 : udint :=  16#616161;  (*šedá*)
 GCOLOR_GREY_800 : udint :=  16#424242;  (*šedá*)
 GCOLOR_GREY_900 : udint :=  16#212121;  (*šedá*)
 GCOLOR_BLUE_GREY_50 : udint :=  16#F1EFEC;  (*modrošedá*)
 GCOLOR_BLUE_GREY_100 : udint :=  16#DCD8CF;  (*modrošedá*)
 GCOLOR_BLUE_GREY_200 : udint :=  16#C5BEB0;  (*modrošedá*)
 GCOLOR_BLUE_GREY_300 : udint :=  16#AEA490;  (*modrošedá*)
 GCOLOR_BLUE_GREY_400 : udint :=  16#9C9078;  (*modrošedá*)
 GCOLOR_BLUE_GREY_500 : udint :=  16#8B7D60;  (*modrošedá*)
 GCOLOR_BLUE_GREY_600 : udint :=  16#7A6E54;  (*modrošedá*)
 GCOLOR_BLUE_GREY_700 : udint :=  16#645A45;  (*modrošedá*)
 GCOLOR_BLUE_GREY_800 : udint :=  16#4F4737;  (*modrošedá*)
 GCOLOR_BLUE_GREY_900 : udint :=  16#383226;  (*modrošedá*)
 GRSCALE_NO_FIRST : int :=  16#01;  (*nekreslit první znaèku*)
 GRSCALE_NO_LAST : int :=  16#02;  (*nekreslit poslední znaèku*)
 GRSCALE_NO_LABELS : int :=  16#04;  (*nekreslit textové popisy*)
 GRSCALE_BOLD_TICK : int :=  16#08;  (*hlavní znaèky tuènì*)
 GRSCALE_CIRCULAR_TICK : int :=  16#10;  (*kruhové hlavní znaèky*)
 GRSCALE_OUTLINE : int :=  16#20;  (*vykreslit oblouk spojující znaèky*)
 GLSCALE_HORIZONTAL : int :=  16#00;  (*vodorovná stupnice*)
 GLSCALE_VERTICAL : int :=  16#01;  (*svislá stupnice*)
 GLSCALE_NO_BASELINE : int :=  16#02;  (*nekreslit základní èáru (pouze znaèky)*)
 GLSCALE_NO_LABELS : int :=  16#04;  (*nekreslit textové popisy*)
 GLSCALE_BOLD_TICK : int :=  16#08;  (*hlavní znaèky tuènì*)

END_VAR

__DECL FUNCTION GC_TestSpace {HIDDEN} : bool
  VAR_INPUT
    rqLen            : uint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveByte {HIDDEN} : bool
  VAR_INPUT
    data             : usint;  (*BYTE k uloení*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveWord {HIDDEN} : bool
  VAR_INPUT
    data             : int;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveDword {HIDDEN} : bool
  VAR_INPUT
    data             : udint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveWordArray {HIDDEN} : bool
  VAR_INPUT
    n                : int;  (*number of items*)
  END_VAR
  VAR_IN_OUT
    data             : int;  (*first item*)
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveDwordArray {HIDDEN} : bool
  VAR_INPUT
    n                : usint;  (*number of items*)
  END_VAR
  VAR_IN_OUT
    data             : udint;  (*first item*)
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SavePos {HIDDEN} : bool
  VAR_INPUT
    x                : int;
    y                : int;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveAngle {HIDDEN} : bool
  VAR_INPUT
    angle            : real;  (*uhel ve stupnich*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveReal {HIDDEN} : bool
  VAR_INPUT
    data             : real;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveString {HIDDEN} : bool
  VAR_IN_OUT
    in               : string [80];
    GrData           : TCanvasData;
  END_VAR
  VAR
    l                : uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SaveArray {HIDDEN} : bool
  VAR_IN_OUT
    in               : usint;
  END_VAR
  VAR_INPUT
    lenIn            : usint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_DataLen : uint
(*vrací poèet bytù uloenıch v grafickém bufferu kreslícího plátna*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Begin : bool
(*zaèátek kreslení, vynuluje buffer a odemkne jej pro zápis*)
  VAR_INPUT
    SizeOfGrData     : udint;
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_End : bool
(*Konec kreslení, zamkne buffer pro zápis a povolí jeho vykreslení.
Vrací TRUE pokud se všechny grafické operace uloily úspìšnì.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
  VAR
    w                : PTR_TO uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MacroBegin : bool
(*Funkce oznaèuje zaèátek bloku grafickıch operací, které lze potom opakovanì spouštìt jako makro.
Toto je vıhodné pro sníení obsazeného místa v grafickém bufferu, pokud se nìkteré sekvence grafickıch operací opakují.
Parametrem funkce je index makra (1-10), pøes tuto hodnotu potom mùeme makro spustit. Konec makra oznaèuje funkce GC_MacroEnd.
Pøi zpracování dat v grafickém bufferu se všechny pøíkazy od GC_MacroBegin do GC_MacroEnd pøeskoèí, provedou se a pøi spuštìní makra funkcí GC_MacroRun.*)
  VAR_INPUT
    index            : usint;  (*index makra (1-10)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MacroEnd : bool
(*Funkce oznaèuje konec definice makra.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MacroRun : bool
(*Funkce spustí pøedem nadefinované makro.
Po jeho ukonèení se pokraèuje následujícím grafickım povelem.*)
  VAR_INPUT
    index            : usint;  (*index makra (1-10)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetLineWidth : bool
(*Funkce nastavuje šíøku èáry v pixelech.*)
  VAR_INPUT
    width            : usint;  (*šíøka èáry v pixelech*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetLineStyle : bool
(*Funkce nastavuje styl èáry, jejího zakonèení a napojení.*)
  VAR_INPUT
    style            : usint;  (*styl definovanı konstantami GLINE_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetFillStyle : bool
(*Funkce nastavuje styl vıplnì.*)
  VAR_INPUT
    style            : usint;  (*styl definovanı konstantami GFILL_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetFgColor : bool
(*Funkce nastavuje barvu èar a písma (popøedí).*)
  VAR_INPUT
    color            : udint;  (*barva uloené ve formátu UDINT (16#AABBGGRR)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetBgColor : bool
(*Funkce nastavuje barvu vıplnì (pozadí).*)
  VAR_INPUT
    color            : udint;  (*barva uloené ve formátu UDINT (16#AABBGGRR)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetTextSize : bool
(*Funkce nastavuje vıšku písma v pixelech.*)
  VAR_INPUT
    size             : usint;  (*vıška písma v pixelech*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetTextStyle : bool
(*Funkce umoòuje zmìnit styl písma, zarovnání øádek ve víceøádkovém textu a zpùsob umístìní textu vzhledem k souøadnici, od které se má text vykreslit.*)
  VAR_INPUT
    style            : uint;  (*styl definovanı konstantami GTEXT_STYLE_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetGradientStyle : bool
(*Funkce nastavuje barvy a styl barevného pøechodu (gradientu).
Aby se zobrazoval ve vıplni gradient místo barvy pozadí, musí se funkcí GC_SetFillStyle zmìnit styl vıplnì na GFILL_STYLE_GRADIENT.*)
  VAR_INPUT
    color1           : udint;  (*poèáteèní barva uloené ve formátu UDINT (16#AABBGGRR)*)
    color2           : udint;  (*koncová barva uloené ve formátu UDINT (16#AABBGGRR)*)
    style            : usint;  (*styl definovanı konstantami GGRADIENT_STYLE_...*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetOrigin : bool
(*Funkce pøesune poèátek souøadnic (bod 0, 0) na pozici kreslicího pera. Všechny souøadnice jsou potom chápány relativnì k této pozici.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_ResetOrigin : bool
(*Funkce pøesune poèátek souøadnic do levého horního rohu kreslicí plochy.*)
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_SetVirtSize : bool
(*Funkce nastaví rozmìr virtuální kreslicí plochy.
Virtuální plocha se umístí na kreslící plátno tak, aby mìla maximální rozmìr pøi zachování pomìru stran a její støed byl shodnı se støedem kreslícího plátna.
V nastaveném rozmìru virtuální plochy jsou zadávány souøadnice a rozmìry následujících grafickıch operací. Také souøadnice dotyku se øídí naposledy zadanım rozmìrem virtuální plochy. Díky této funkci je moné kreslit nezávisle na rozmìru kreslícího plátna.
Pokud jsou zadány oba rozmìry na nulu dojde k obnovení vıchozího rozmìru kreslícího plátna.*)
  VAR_INPUT
    width            : int;  (*šíøka virtuální kreslící plochy*)
    height           : int;  (*vıška virtuální kreslící plochy*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MoveTo : bool
(*Funkce mìní pozici kreslicího pera (bez kreslení).*)
  VAR_INPUT
    x                : int;  (*nová souøadnice X kreslícího pera*)
    y                : int;  (*nová souøadnice Y kreslícího pera*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Move : bool
(*Funkce mìní pozice kreslicího pera relativnì k pùvodnímu umístìní (bez kreslení).*)
  VAR_INPUT
    x                : int;  (*relativní zmìna pozice v ose X*)
    y                : int;  (*relativní zmìna pozice v ose Y*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Point : bool
(*Funkce vykreslí bod na zadanıch souøadnicích. Na stejné souøadnice nastaví i pozici kreslícího pera.*)
  VAR_INPUT
    x                : int;  (*souøadnice X*)
    y                : int;  (*souøadnice Y*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_LineTo : bool
(*Funkce kreslí èáru od souèasné pozice kreslicího pera do bodu zadaného souøadnicemi. Pozice kreslicího pera se pøesune do koncového bodu èáry.*)
  VAR_INPUT
    x                : int;  (*souøadnice X koncového bodu*)
    y                : int;  (*souøadnice Y koncového bodu*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Line : bool
(*Funkce vykreslí èáru mezi dvìma body. Pozice kreslicího pera se pøesune do koncového bodu èáry.*)
  VAR_INPUT
    x1               : int;  (*souøadnice X poèáteèního bodu*)
    y1               : int;  (*souøadnice Y poèáteèního bodu*)
    x2               : int;  (*souøadnice X koncového bodu*)
    y2               : int;  (*souøadnice Y koncového bodu*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Box : bool
(*Vykreslí obdélník.
        Kreslící pero posune do støedu obdélníku.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    x                : int;  (*souøadnice X levého horního rohu*)
    y                : int;  (*souøadnice Y levého horního rohu*)
    width            : int;  (*šíøka obdélníku*)
    height           : int;  (*vıška obdélníku*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CBox : bool
(*Vykreslí obdélník se støedem na pozici kreslícího pera.
Obdélník je otoèen o úhel nastavenı smìrem kreslícího pera.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    width            : int;  (*šíøka obdélníku*)
    height           : int;  (*vıška obdélníku*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_RoundBox : bool
(*Vykreslí obdélník se zakulacenımi rohy.
        Kreslící pero posune do støedu obdélníku.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    x                : int;  (*souøadnice X levého horního rohu*)
    y                : int;  (*souøadnice Y levého horního rohu*)
    width            : int;  (*šíøka obdélníku*)
    height           : int;  (*vıška obdélníku*)
    r                : int;  (*polomìr rohu*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CRoundBox : bool
(*Vykreslí obdélník se zakulacenımi rohy se støedem na pozici kreslícího pera.
Obdélník je otoèen o úhel nastavenı smìrem kreslícího pera.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    width            : int;  (*šíøka obdélníku*)
    height           : int;  (*vıška obdélníku*)
    r                : int;  (*polomìr rohu*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Triangle : bool
(*Vykreslí trojúhelník zadanı tøemi body.
        Pozice kreslícího pera se nemìní.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    x1               : int;  (*souøadnice X prvního bodu*)
    y1               : int;  (*souøadnice Y prvního bodu*)
    x2               : int;  (*souøadnice X druhého bodu*)
    y2               : int;  (*souøadnice Y druhého bodu*)
    x3               : int;  (*souøadnice X tøetího bodu*)
    y3               : int;  (*souøadnice Y tøetího bodu*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Polygon4 : bool
(*Vykreslí ètyøúhelník zadanı ètyømi body.
        Pozice kreslícího pera se nemìní.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    x1               : int;  (*souøadnice X prvního bodu*)
    y1               : int;  (*souøadnice Y prvního bodu*)
    x2               : int;  (*souøadnice X druhého bodu*)
    y2               : int;  (*souøadnice Y druhého bodu*)
    x3               : int;  (*souøadnice X tøetího bodu*)
    y3               : int;  (*souøadnice Y tøetího bodu*)
    x4               : int;  (*souøadnice X ètvrtého bodu*)
    y4               : int;  (*souøadnice Y ètvrtého bodu*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Polygon : bool
(*Vykreslí mnohoúhelník. Souøadnice jednotlivıch bodù se pøidávají pomocí funkce GC_AddPoint.
        Pozice kreslícího pera se nemìní.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    numPoints        : usint;  (*poèet bodù*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PolygonArray : bool
(*Vykreslí mnohoúhelník. Souøadnice jednotlivıch bodù se pøedávají jako pole.
        Pozice kreslícího pera se nemìní.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    numPoints        : usint;  (*poèet bodù*)
  END_VAR
  VAR_IN_OUT
    points           : TCanvasPoint;  (*první bod v poli bodù*)
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Arc : bool
(*Funkce nakreslí oblouk / eliptickou vıseè. Pozice kreslicího pera se pøesune do støedu.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    x                : int;  (*souøadnice X støedového bodu*)
    y                : int;  (*souøadnice Y støedového bodu*)
    rx               : int;  (*polomìr v ose X*)
    ry               : int;  (*polomìr v ose Y*)
    angle            : real;  (*poèáteèní úhel oblouku ve stupních*)
    dangle           : real;  (*délka oblouku ve stupních*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CArc : bool
(*Funkce nakreslí oblouk / eliptickou vıseè se støedem na pozici kreslícího pera.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    rx               : int;  (*polomìr v ose X*)
    ry               : int;  (*polomìr v ose Y*)
    angle            : real;  (*poèáteèní úhel oblouku ve stupních*)
    dangle           : real;  (*délka oblouku ve stupních*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Circle : bool
(*Funkce nakreslí krunici. Pozice kreslicího pera se pøesune do støedu.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    x                : int;  (*souøadnice X støedového bodu*)
    y                : int;  (*souøadnice Y støedového bodu*)
    r                : int;  (*polomìr*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CCircle : bool
(*Funkce nakreslí krunici se støedem na pozici kreslícího pera.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    r                : int;  (*polomìr*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CTriangle : bool
(*Funkce vykreslí trojúhelník zadanı tøemi body kolem pozice kreslicího pera natoèenı o úhel kreslicího pera.
Souøadnice jednotlivıch bodù jsou relativní k pozici kreslicího pera. Pozice kreslicího pera se nemìní.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    x1               : int;  (*souøadnice X prvního bodu*)
    y1               : int;  (*souøadnice Y prvního bodu*)
    x2               : int;  (*souøadnice X druhého bodu*)
    y2               : int;  (*souøadnice Y druhého bodu*)
    x3               : int;  (*souøadnice X tøetího bodu*)
    y3               : int;  (*souøadnice Y tøetího bodu*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CPolygon4 : bool
(*Funkce vykreslí ètyøúhelník zadanı ètyømi body kolem pozice kreslicího pera natoèenı o úhel kreslicího pera.
Souøadnice jednotlivıch bodù jsou relativní k pozici kreslicího pera. Pozice kreslicího pera se nemìní.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    x1               : int;  (*souøadnice X prvního bodu*)
    y1               : int;  (*souøadnice Y prvního bodu*)
    x2               : int;  (*souøadnice X druhého bodu*)
    y2               : int;  (*souøadnice Y druhého bodu*)
    x3               : int;  (*souøadnice X tøetího bodu*)
    y3               : int;  (*souøadnice Y tøetího bodu*)
    x4               : int;  (*souøadnice X ètvrtého bodu*)
    y4               : int;  (*souøadnice Y ètvrtého bodu*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CPolygon : bool
(*Funkce nakreslí mnohoúhelník kolem pozice kreslicího pera natoèenı o úhel kreslicího pera.
Souøadnice jednotlivıch bodù jsou relativní k pozici kreslicího pera. Body se pøidávají pomocí funkce GC_AddPoint. Pozice kreslicího pera se nemìní.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    numPoints        : usint;  (*poèet bodù*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CPolygonArray : bool
(*Funkce nakreslí mnohoúhelník kolem pozice kreslicího pera natoèenı o úhel kreslicího pera.
Souøadnice jednotlivıch bodù jsou relativní k pozici kreslicího pera. Body se pøedávají jako pole. Pozice kreslicího pera se nemìní.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    numPoints        : usint;  (*poèet bodù*)
  END_VAR
  VAR_IN_OUT
    points           : TCanvasPoint;  (*první bod v poli bodù*)
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_AddPoint : bool
(*Funkce slouí pro pøidání souøadnic jednotlivıch bodù polygonu, pouívá se po funkcích GC_CPolygon a GC_Polygon.*)
  VAR_INPUT
    x                : int;  (*souøadnice X*)
    y                : int;  (*souøadnice Y*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_WriteText : bool
(*Funkce vypíše text od pozice kreslicího pera. Text mùe bıt i víceøádkovı, jednotlivé øádky se oddìlují znakem $n.
Velikost písma je moné zmìnit funkcí GC_SetTextSize, pomocí funkce GC_SetTextStyle lze zmìnit styl písma a zpùsob zarovnání jednotlivıch øádek textu.
Pozice kreslícího pera se mìní v závislosti na tom, zda se text vypisuje doleva, na støed èi doprava od jeho pozice.*)
  VAR_INPUT
    text             : string [80];  (*text, kterı se má zobrazit*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CWriteText : bool
(*Funkce vypíše text centrovanı kolem pozice kreslicího pera. Text mùe bıt i víceøádkovı, jednotlivé øádky se oddìlují znakem $n.
Velikost písma je moné zmìnit funkcí GC_SetTextSize, pomocí funkce GC_SetTextStyle lze zmìnit styl písma a zpùsob zarovnání jednotlivıch øádek textu.
Pozice kreslícího pera se nemìní.*)
  VAR_INPUT
    text             : string [80];  (*text, kterı se má zobrazit*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Image : bool
(*Funkce zobrazí obrázek, levı horní roh bude umístìn na pozici kreslicího pera. Pozice kreslicího pera se pøesune do støedu obrázku.
Obrázek musí bıt asociovanı s objektem kreslícího plátna.*)
  VAR_INPUT
    width            : int;  (*šíøka vykresleného obrázku (0 pùvodní velikost)*)
    height           : int;  (*vıška vykresleného obrázku (0 pùvodní velikost)*)
    fileName         : string [80];  (*jméno obrázku*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_CImage : bool
(*Funkce zobrazí obrázek vystøedìnı na pozici kreslicího pera. Pozice kreslícího pera se nemìní.
Obrázek musí bıt asociovanı s objektem kreslícího plátna.*)
  VAR_INPUT
    width            : int;  (*šíøka vykresleného obrázku (0 pùvodní velikost)*)
    height           : int;  (*vıška vykresleného obrázku (0 pùvodní velikost)*)
    fileName         : string [80];  (*dlouhé jméno obrázku pøiøazené ke kreslicímu plátnu*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Heading : bool
(*Funkce nastavuje úhel kreslicího pera ve stupních. Hodnota 0 odpovídá smìru doprava, hodnota 90 smìru dolù.*)
  VAR_INPUT
    angle            : real;  (*novı úhel kreslícího pera ve stupních*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_Turn : bool
(*Funkce pootoèí úhel kreslicího pera o hodnotu zadanou ve stupních. Kladné hodnoty otáèí perem ve smìru hodinovıch ruèièek, záporné v proti smìru.*)
  VAR_INPUT
    angle            : real;  (*úhel pootoèení kreslicího pera ve stupních*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_LineFwd : bool
(*Funkce vykreslí èáru zadané délky od pozice kreslicího pera pod úhlem kreslicího pera. Pozice kreslicího pera se pøesune do koncového bodu èáry.*)
  VAR_INPUT
    length           : int;  (*délka èáry*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_MoveFwd : bool
(*Funkce pøesune pozici kreslicího pera o zadanou vzdálenost pod úhlem kreslicího pera.*)
  VAR_INPUT
    length           : int;  (*vzdálenost mezi starou a novou pozicí kreslícího pera*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PushPosition : bool
(*Funkce uloí do pomocného zásobníku aktuální umístìní kreslicího pera.
Parametrem funkce je index pozice v zásobníku. Pokud je index 1 – 10, hodnota se uloí pøímo na tuto pozici.
Pokud je index 0, posune se obsah zásobníku (data z pozic 1 – 9 se pøesunou do pozic 2 – 10) a nová hodnota se zapíše do pozice 1 (vrchol zásobníku).*)
  VAR_INPUT
    index            : usint;  (*index pozice v zásobníku (1 – 10) nebo vrchol zásobníku (0)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PopPosition : bool
(*Funkce obnoví pozici kreslicího pera uloenou funkcí GC_PushPosition.
Parametrem je index pozice v zásobníku. Pokud je index 1 – 10, pouije se pøímo hodnota na této pozici.
Pokud je index 0, pouije se hodnota z vrcholu zásobníku (pozice 1), obsah zbylıch pozic se pøesune (data z pozic 2 – 10 se pøesunou do pozic 1 – 9).*)
  VAR_INPUT
    index            : usint;  (*index pozice v zásobníku (1 – 10) nebo vrchol zásobníku (0)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PushHeading : bool
(*Funkce uloí do pomocného zásobníku aktuální úhel kreslicího pera.
Parametrem funkce je index pozice v zásobníku. Pokud je index 1 – 10, hodnota se uloí pøímo na tuto pozici.
Pokud je index 0, posune se obsah zásobníku (data z pozic 1 – 9 se pøesunou do pozic 2 – 10) a nová hodnota se zapíše do pozice 1 (vrchol zásobníku).*)
  VAR_INPUT
    index            : usint;  (*index pozice v zásobníku (1 – 10) nebo vrchol zásobníku (0)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_PopHeading : bool
(*Funkce obnoví úhel kreslicího pera uloenı funkcí GC_PushHeading.
Parametrem je index pozice v pomocném zásobníku. Pokud je index 1 – 10, pouije se pøímo hodnota na této pozici.
Pokud je index 0, pouije se hodnota z vrcholu zásobníku (pozice 1), obsah zbylıch pozic se pøesune (data z pozic 2 – 10 se pøesunou do pozic 1 – 9).*)
  VAR_INPUT
    index            : usint;  (*index pozice v zásobníku (1 – 10) nebo vrchol zásobníku (0)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLineArray : bool
(*Funkce vykreslí data pro èárovı graf.
Kreslení probíhá od pozice kreslicího pera, souøadnice Y jednotlivıch datovıch bodù jsou relativní k pozici kreslicího pera.
Jednotlivé souøadnice se pøedávají jako pole hodnot typu INT.
Pozice kreslicího pera se nemìní.*)
  VAR_INPUT
    params           : usint;  (*volitelné parametry, které upravují zobrazení grafu (konstanty GGRAPH_LINE_...)*)
    length           : int;  (*délka èáry grafu v pixelech*)
    numPoints        : int;  (*poèet datovıch bodù*)
  END_VAR
  VAR_IN_OUT
    data             : int;  (*první prvek pole souøadnic Y relativnì k pozici kreslicího pera*)
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLineRealArray : bool
(*Funkce vykreslí data pro èárovı graf.
Kreslení probíhá od pozice kreslicího pera. Tento bod odpovídá minimu os X a Y.
Jednotlivé souøadnice se pøedávají jako pole hodnot typu REAL a jsou mìøítkovány dle minY a maxY.
Pozice kreslicího pera se nemìní.*)
  VAR_INPUT
    params           : usint;  (*volitelné parametry, které upravují zobrazení grafu (konstanty GGRAPH_LINE_...)*)
    length           : int;  (*délka èáry grafu v pixelech*)
    numPoints        : int;  (*poèet datovıch bodù*)
    height           : int;  (*vıška grafu v pixelech*)
    minY             : real;  (*hodnota odpovídající minimu grafu*)
    maxY             : real;  (*hodnota odpovídající maximu grafu*)
  END_VAR
  VAR_IN_OUT
    data             : real;  (*první prvek pole souøadnic Y*)
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
  VAR
    a                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLine : bool
(*Funkce vykreslí data pro èárovı graf.
Kreslení probíhá od pozice kreslicího pera, souøadnice Y jednotlivıch datovıch bodù jsou relativní k pozici kreslicího pera.
Jednotlivé souøadnice se pøidávají pomocí funkce GC_GraphAddData.
Pozice kreslicího pera se nemìní.*)
  VAR_INPUT
    params           : usint;  (*volitelné parametry, které upravují zobrazení grafu (konstanty GGRAPH_LINE_...)*)
    length           : int;  (*délka èáry grafu v pixelech*)
    numPoints        : int;  (*poèet datovıch bodù*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphBarsArray : bool
(*Funkce vykreslí data pro sloupcovı graf.
Kreslení probíhá od pozice kreslicího pera, souøadnice Y jednotlivıch datovıch bodù jsou relativní k pozici kreslicího pera.
Jednotlivé souøadnice se pøedávají jako pole hodnot typu INT.
Pozice kreslicího pera se nemìní.*)
  VAR_INPUT
    params           : usint;  (*volitelné parametry, které upravují zobrazení grafu*)
    length           : int;  (*vzdálenost mezi støedy prvního a posledního sloupce v pixelech*)
    barWidth         : int;  (*šíøka sloupcù*)
    numPoints        : int;  (*poèet datovıch bodù*)
  END_VAR
  VAR_IN_OUT
    data             : int;  (*první prvek pole souøadnic Y relativnì k pozici kreslicího pera*)
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphBarsRealArray : bool
(*Funkce vykreslí data pro sloupcovı graf.
Kreslení probíhá od pozice kreslicího pera. Tento bod odpovídá minimu os X a Y.
Jednotlivé souøadnice se pøedávají jako pole hodnot typu REAL a jsou mìøítkovány dle minY a maxY.
Pozice kreslicího pera se nemìní.*)
  VAR_INPUT
    params           : usint;  (*volitelné parametry, které upravují zobrazení grafu*)
    length           : int;  (*vzdálenost mezi støedy prvního a posledního sloupce v pixelech*)
    barWidth         : int;  (*šíøka sloupcù*)
    numPoints        : int;  (*poèet datovıch bodù*)
    height           : int;  (*vıška grafu v pixelech*)
    minY             : real;  (*hodnota odpovídající minimu grafu*)
    maxY             : real;  (*hodnota odpovídající maximu grafu*)
  END_VAR
  VAR_IN_OUT
    data             : real;  (*první prvek pole souøadnic Y*)
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
  VAR
    a                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphBars : bool
(*Funkce vykreslí data pro sloupcovı graf.
Kreslení probíhá od pozice kreslicího pera, souøadnice Y jednotlivıch datovıch bodù jsou relativní k pozici kreslicího pera.
Jednotlivé souøadnice se pøidávají pomocí funkce GC_GraphAddData.
Pozice kreslicího pera se nemìní.*)
  VAR_INPUT
    params           : usint;  (*volitelné parametry, které upravují zobrazení grafu*)
    length           : int;  (*vzdálenost mezi støedy prvního a posledního sloupce v pixelech*)
    barWidth         : int;  (*šíøka sloupcù*)
    numPoints        : int;  (*poèet datovıch bodù*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphAddData : bool
(*Pøidá jeden datovı bod do grafu. Tato funkce se pouívá po funkcích GC_GraphBars a GC_GraphLine.*)
  VAR_INPUT
    data             : int;  (*Souøadnice Y datového bodu v pixelech relativnì k pozici kreslícího pera*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_RadialScale : bool
(*Funkce vykreslí stupnici kruhového mìøidla*)
  VAR_INPUT
    radius           : int;  (*polomìr*)
    sAngle           : real;  (*poèáteèní úhel - odpovídá minimální hodnotì*)
    eAngle           : real;  (*koncovı úhel - odpovídá maximální hodnotì*)
    majorTickLen     : int;  (*délka hlavní znaèky s popisem (kladné se kreslí smìrem do støedu)*)
    minorTickLen     : int;  (*délka vedlejší znaèky*)
    labelOffset      : usint;  (*odstup textu od znaèky*)
    labelDec         : usint;  (*poèet desetinnıch míst popisu*)
    sVal             : real;  (*poèáteèní hodnota*)
    eVal             : real;  (*koncová hodnota*)
    majorStep        : real;  (*krok po kterém budou vykresleny hlavní znaèky*)
    labelAt          : real;  (*hodnota na které bude znaèka s popiskou*)
    labelStep        : usint;  (*krok po kterém je vykreslena popiska*)
    stepDiv          : usint;  (*dìlení kroku hlavních znaèek pro kreslení vedlejší znaèek*)
    params           : int;  (*další parametry (konstanty GRSCALE...)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_LinearScale : bool
(*Funkce vykreslí lineární stupnici*)
  VAR_INPUT
    length           : int;  (*délka*)
    majorTickLen     : int;  (*délka hlavní znaèky s popisem (kladné se kreslí doleva/dolu)*)
    minorTickLen     : int;  (*délka vedlejší znaèky*)
    gridLength       : int;  (*délka èáry møíky*)
    labelOffset      : usint;  (*odstup textu od znaèky*)
    labelDec         : usint;  (*poèet desetinıch míst popisu*)
    sVal             : real;  (*poèáteèní hodnota*)
    eVal             : real;  (*koncová hodnota*)
    majorStep        : real;  (*krok po kterém budou vykresleny hlavní znaèky*)
    labelAt          : real;  (*hodnota na které bude znaèka s popiskou*)
    labelStep        : usint;  (*krok po kterém je vykreslena popiska*)
    stepDiv          : usint;  (*dìlení kroku hlavních znaèek pro kreslení vedlejší znaèek*)
    params           : int;  (*další parametry (konstanty GLSCALE...)*)
  END_VAR
  VAR_IN_OUT
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION

__DECL FUNCTION RGBA_TO_Color : udint
(*Sloí barvu z jednotlivıch sloek RGB a prùhlednosti do formátu UDINT (16#AABBGGRR)*)
  VAR_INPUT
    R                : usint;  (*Èervená sloka (0-255)*)
    G                : usint;  (*Zelená sloka (0-255)*)
    B                : usint;  (*Modrá sloka (0-255)*)
    A                : usint;  (*Prùhlednost (0 - neprùhledné, 255 - prùhledné)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Color_TO_RGBA : bool
(*Rozloí barvu ve formátu UDINT (16#AABBGGRR) na jednotlivé sloky RGB a prùhlednost*)
  VAR_INPUT
    color            : udint;  (*barva uloené ve formátu UDINT (16#AABBGGRR)*)
  END_VAR
  VAR_IN_OUT
    R                : usint;  (*Èervená sloka (0-255)*)
    G                : usint;  (*Zelená sloka (0-255)*)
    B                : usint;  (*Modrá sloka (0-255)*)
    A                : usint;  (*Prùhlednost (0 - neprùhledné, 255 - prùhledné)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION Alpha_TO_Color : udint
(*Nastaví barvì uloené ve formátu UDINT (16#AABBGGRR) prùhlednost (0 - neprùhledné, 255 - prùhledné)*)
  VAR_INPUT
    color            : udint;  (*barva uloené ve formátu UDINT (16#AABBGGRR)*)
    alpha            : usint;  (*prùhlednost (0 - neprùhledné, 255 - prùhledné)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphPolygonRealArray : bool
(*Vykreslí mnohoúhelník jako XY graf. Souøadnice jednotlivıch bodù se pøedávají jako pole souøadnic X a Y.
Pozice kreslícího pera se nemìní.*)
  VAR_INPUT
    fill             : bool;  (*kreslit vyplnìnı*)
    numPoints        : usint;  (*poèet bodù*)
    length           : int;  (*délka osy X v pixelech*)
    height           : int;  (*délka osy Y v pixelech*)
    minX             : real;  (*hodnota odpovídající minimu osy X*)
    maxX             : real;  (*hodnota odpovídající maximu osy X*)
    minY             : real;  (*hodnota odpovídající minimu osy Y*)
    maxY             : real;  (*hodnota odpovídající maximu osy Y*)
  END_VAR
  VAR_IN_OUT
    pointsX          : real;  (*první bod v poli souøadnic X*)
    pointsY          : real;  (*první bod v poli souøadnic Y*)
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
  VAR
    a                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION GC_GraphLineXYRealArray : bool
(*Vykreslí èáru jako XY graf. Souøadnice jednotlivıch bodù se pøedávají jako pole souøadnic X a Y.
Pozice kreslícího pera se nemìní.*)
  VAR_INPUT
    x                : int;  (*souøadnice X poèáteèního bodu*)
    y                : int;  (*souøadnice Y poèáteèního bodu*)
    numPoints        : usint;  (*poèet bodù*)
    length           : int;  (*délka osy X v pixelech*)
    height           : int;  (*délka osy Y v pixelech*)
    minX             : real;  (*hodnota odpovídající minimu osy X*)
    maxX             : real;  (*hodnota odpovídající maximu osy X*)
    minY             : real;  (*hodnota odpovídající minimu osy Y*)
    maxY             : real;  (*hodnota odpovídající maximu osy Y*)
  END_VAR
  VAR_IN_OUT
    pointsX          : real;  (*první bod v poli souøadnic X*)
    pointsY          : real;  (*první bod v poli souøadnic Y*)
    GrData           : TCanvasData;  (*odkaz na buffer kreslícího plátna*)
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\CONVERTLIB_V21_20170222.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : D:\TecoUserLibs\ConvertLib_V21_20170222.mlb *)
(* Knihovna : ConvertLib 2.1 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c) 2017 Teco a.s. *)
(* Verze IEC pøekladaèe : 3.12.10.2 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : ConvertLib 2.1  }
(* Historie: *)
(*
v1.0 17.11.2010 Nem Úvodni verze knihovny
v1.1 22.07.2010 Nem Funkce STRING_TO_UPPER() a STRING_TO_LOWER()
                    vrací délku pøevedeného stringu
v1.2 13.02.2012 Nem Pøidaná funkce ISO8859_2_TO_CP1250()
v1.3 27.04.2012 Nem Pøidaná funkce ReplaceChar()
v1.4 03.09.2012 Nem Pøidány funkce DT_TO_DT_RFC822() a DT_RFC822_TO_DT()
v1.5 02.06.2013 Nem Opravena funkce DT_RFC822_TO_DT() pro èerven a èervenec
v1.6 23.09.2013 Byd Pøidány funkce WindDirectionT115Deg, WindDirectionT115StringCs, 
                    WindDirectionT115StringEn a funkèní bloky fbMeterCounter, fbMeterPulse
v1.7 14.10.2013 Byd Oprava v DT_RFC822_TO_DT pro mìsíc øíjen
v1.8 31.10.2014 Nem Pøidány funkce STRING_TO_INT_EX, STRING_TO_REAL_EX, 
                    STRING_TO_LREAL_EX
v1.9 18.01.2016 Nem Pøidány funkce DT_TO_DT_HTTP() a UTF8_TO_CP125x()
                    Oprava v DT_RFC822_TO_DT pro PM
v2.0 19.01.2017 Byd Ošetøen blok fbMeterCounter pro MaxPeriod menší ne 1000ms
v2.1 22.02.2017 Byd Pøidány funkce CP1250_TO_UTF8, CP1251_TO_UTF8, CP1252_TO_UTF8, CP1253_TO_UTF8, CP1254_TO_UTF8, CP1255_TO_UTF8
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\STDLIB_V21_20140514.MLB"}

__DECL FUNCTION STRING_TO_UPPER : uint
(*Pøevod všech znakù v øetìzci na velká písmena. Vrací délku pøevedeného øetìzce.*)
  VAR_IN_OUT
    input            : string [80];
  END_VAR
END_FUNCTION

__DECL FUNCTION STRING_TO_LOWER : uint
(*Pøevod všech znakù v øetìzci na malá písmena. Vrací délku pøevedeného øetìzce.*)
  VAR_IN_OUT
    input            : string [80];
  END_VAR
END_FUNCTION

__DECL FUNCTION STRING_HEX_TO_UDINT : udint
(*Pøevod STRING (pouze hex èíslice) na UDINT
  
  Povolené znaky : '0123456789abcdefABCDEF'*)
  VAR_INPUT
    input            : string [80];
  END_VAR
  VAR
    tmp              : string [8] :=  '00000000';
  END_VAR
END_FUNCTION

__DECL FUNCTION DEG_TO_RAD : lreal
(*Pøevod úhlovıch stupòù na radiány*)
  VAR_INPUT
    angle            : lreal;  (*úhel ve stupních*)
  END_VAR
  VAR CONSTANT
    _180_pi          : lreal :=  3.1415926535897931/180.0;
  END_VAR
END_FUNCTION

__DECL FUNCTION RAD_TO_DEG : lreal
(*Pøevod radiánù na úhlové stupnì*)
  VAR_INPUT
    angle            : lreal;  (*úhel v radiánech*)
  END_VAR
  VAR CONSTANT
    _pi_180          : lreal :=  180.0/3.1415926535897931;
  END_VAR
END_FUNCTION

__DECL FUNCTION DEGREES_TO_ANGLE : lreal
(*Pøevod úhlu ze stupòù, minut a vteøin na stupnì*)
  VAR_INPUT
    degrees          : int;  (*Stupnì*)
    minutes          : int;  (*Minuty*)
    seconds          : int;  (*Vteøiny*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FAHRENHEIT_TO_CELSIUS : real
(*Pøevod teploty ze stupòù Fahrenheita na stupnì Celsia*)
  VAR_INPUT
    temp             : real;  (*teplota ve stupních Fahrenheita*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CELSIUS_TO_FAHRENHEIT : real
(*Pøevod teploty ze stupòù Celsia na stupnì Fahrenheita*)
  VAR_INPUT
    temp             : real;  (*teplota ve stupních Celsia*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ANGLE_TO_DEGREES : bool
(*Pøevod úhlu ve stupních na stupnì/minuty/vteøiny*)
  VAR_INPUT
    angle            : lreal;  (*úhel ve stupních*)
  END_VAR
  VAR_IN_OUT
    degrees          : int;  (*Stupnì*)
    minutes          : int;  (*Minuty*)
    seconds          : int;  (*Vteøiny*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ISO8859_2_TO_CP1250 : udint
(*Pøevod znakù kódovanıch podle ISO 8859-2 na kódování CP-1250*)
  VAR_IN_OUT
    src              : usint;  (*první byte øetìzce pro pøevod*)
  END_VAR
  VAR
    ps               : PTR_TO usint;
    s                : usint;
  END_VAR
  VAR CONSTANT
    ISO8859_2_TO_CP1250_161_190 : ARRAY [161..190] OF usint :=  [
      165, 162, 163, 164, 188, 140,
      167, 168, 138, 170, 141, 143,
      173, 142, 175, 176, 185, 178,
      179, 180, 190, 156, 183, 184,
      154, 186, 157, 159, 189, 158
    ];
  END_VAR
END_FUNCTION

__DECL FUNCTION REPLACE_CHAR : uint
(*Nahradí všechny znaky C1 znakem C2
Vrací délku øetìzce*)
  VAR_INPUT
    C1               : byte;  (*ASCII hodnota znaku, kterı má bıt nahrazen*)
    C2               : byte;  (*ASCII hodnota znaku, kterım se bude nahrazovat*)
  END_VAR
  VAR_IN_OUT
    input            : string [255];  (*Øetizec, ve kterém budou znaky nahrazeny*)
  END_VAR
END_FUNCTION

TYPE TypeTecoDateTime {HIDDEN} :
  STRUCT
    year             : usint;  (*rok     (poslední dvì èíslice letopoètu)*)
    month            : usint;  (*mìsíc   (1 .. 12)*)
    day              : usint;  (*den     (1 .. 28/29/30/31)*)
    hour             : usint;  (*hodina  (0 .. 23)*)
    min              : usint;  (*minuta  (0 .. 59)*)
    sec              : usint;  (*sekunda (0 .. 59)*)
    dayOfWeek        : usint;  (*den v tıdnu (1 = pondìlí, 7 = nedìle)*)
    milisec          : uint;  (*milisekunda*)
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 MonthsNamesRFC822 : ARRAY [1..12] OF string [3] :=   ['Jan', 'Feb', 'Mar', 'Apr',
                                                       'May', 'Jun', 'Jul', 'Aug',
                                                       'Sep', 'Oct', 'Nov', 'Dec'];

END_VAR

__DECL FUNCTION DT_TO_DT_RFC822 : string [26]
(*vrací datum a èas dle RFC822

  datum a èas podle RFC822

  datum           =       den mìsíc rok
  rok             =       4 èísla
  mìsíc           =       jméno-mìsíce
  jméno-mìsíce    =       "Jan" / "Feb" / "Mar" / "Apr" /
                          "May" / "Jun" / "Jul" / "Aug" /
                          "Sep" / "Oct" / "Nov" / "Dec"
  den             =       1-2 èísla
  èas             =       èas-ve-dni zóna
  èas-ve-dni      =       hodina ":" minuta ":" sekunda
  hodina          =       2 èísla
  minuta          =       2 èísla
  sekunda         =       2 èísla
  zóna            =       (( "+" / "-" ) 4 èísla)*)
  VAR_INPUT
    dateTime         : dt;  (*Datum a èas ve formátu IEC DT*)
    UtcOff           : uint;  (*Posun èasového pásma v minutách*)
  END_VAR
  VAR
    tmpDT            : TypeTecoDateTime;
    tmpTime          : time;
    Format           : string [80];
  END_VAR
END_FUNCTION

__DECL FUNCTION DT_RFC822_TO_DT : dt
(*Pøevod data a èasu ve formátu podle RFC822 na IEC formát DATE_AND_TIME
  Vrací èas ve formátu IEC DT

  datum a èas podle RFC822

  datum           =       den mìsíc rok
  rok             =       4 èísla
  mìsíc           =       jméno-mìsíce
  jméno-mìsíce    =       "Jan" / "Feb" / "Mar" / "Apr" /
                          "May" / "Jun" / "Jul" / "Aug" /
                          "Sep" / "Oct" / "Nov" / "Dec"
  den             =       1-2 èísla
  èas             =       èas-ve-dni zóna
  èas-ve-dni      =       hodina ":" minuta ":" sekunda
  hodina          =       2 èísla
  minuta          =       2 èísla
  sekunda         =       2 èísla
  zóna            =       (( "+" / "-" ) 4 èísla)*)
  VAR_INPUT
    dateTime         : string [80];  (*Datum a èas podle RFC822 (napø. Tue, 28 Aug 2012 7:58 am)*)
  END_VAR
  VAR
    tmpDT            : TypeTecoDateTime;
  END_VAR
END_FUNCTION

__DECL FUNCTION WindDirectionT115Deg : real
(*Pøevod odporu mìøeného na ukazateli smìru vìtru T115 na úhlové stupnì*)
  VAR_INPUT
    R                : real;
  END_VAR
  VAR CONSTANT
    directionDeg     : ARRAY [0..7] OF real :=  [90,135,180,45,225,0,315,270];
  END_VAR
END_FUNCTION

__DECL FUNCTION WindDirectionT115StringCs : string [2]
(*Pøevod odporu mìøeného na ukazateli smìru vìtru T115 na èeské oznaèení smìru*)
  VAR_INPUT
    R                : real;  (*Odpor mìøenı na ukazateli smìru vìtru T115*)
  END_VAR
  VAR
    direction        : ARRAY [0..7] OF string [2] :=  ['V','JV','J','SV','JZ','S','SZ','Z'];
  END_VAR
END_FUNCTION

__DECL FUNCTION WindDirectionT115StringEn : string [2]
(*Pøevod odporu mìøeného na ukazateli smìru vìtru T115 na anglické oznaèení smìru*)
  VAR_INPUT
    R                : real;  (*Odpor mìøenı na ukazateli smìru vìtru T115*)
  END_VAR
  VAR
    direction        : ARRAY [0..7] OF string [2] :=  ['E','SE','S','NE','SW','N','NW','W'];
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 DayNamesRFC1123 : ARRAY [1..7] OF string [3] :=   [ 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

END_VAR

__DECL FUNCTION DT_TO_DT_HTTP : string
(*dateTime : DT;            Datum a èas ve formátu IEC DT
    UtcOff   : UINT;*)
  VAR_INPUT
    dateTime         : dt;  (*Datum a èas ve formátu IEC DT*)
    UtcOff           : uint;  (*Posun èasového pásma v minutách*)
  END_VAR
  VAR
    gmtDT            : dt;
    tmpDT            : TypeTecoDateTime;
    tmpTime          : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION UTF8_TO_CP125x : uint
(*Pøevod znakù kódovanıch podle UTF8 na kódování CP-1250,...,CP1255
        Vrací velikost vısledného øetìzce*)
  VAR_IN_OUT
    str              : string [255];  (*øetìzec, kterı bude pøekódován z UTF8 na CP125x*)
  END_VAR
  VAR_INPUT
    codePage         : uint;  (*kódová stránka = 1250,...,1255*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbMeterPulse
(*Poèítá pulzy a jejich frekvenci*)
  VAR_INPUT
    Pulse            : bool R_EDGE;  (*Pulzy*)
    Reset            : bool R_EDGE;  (*Nulování poèítadla pulzù*)
    Freeze           : bool;  (*Zastaví èítání a nastaví frekvenci na nulu*)
    Filter           : time :=  T#2s;  (*Èasová konstanta filtru frekvence*)
    MaxPeriod        : time :=  T#1m;  (*Maximální perioda mezi pulzy*)
    Base             : time :=  T#1s;  (*Základní èasová perioda pro urèování frekvence*)
  END_VAR
  VAR_OUTPUT
    PulseOut         : bool;  (*Kopie vstupních pulzù*)
    Overflow         : bool;  (*Pøeteèení èítaèe pulzù, nastavte Reset do logické 1*)
    Frequency        : real;  (*Frekvence [1/Base]*)
  END_VAR
  VAR_IN_OUT
    Counter          : udint;  (*Poèítadlo pulzù (musí bıt RETAIN!)*)
  END_VAR
  VAR
    RawFrequncy      : real;
    LastPulseTim     : time;
    PulseLen         : real;
    LastPulseLen     : real;
    Exp1             : real;
    LastFilterTime   : time;
    OldFilter        : time;
    MaxPulseLen      : real;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbMeterCounter
(*Poèítá pulzy a jejich frekvenci*)
  VAR_INPUT
    Cnt              : uint;  (*Èítaè pulzù*)
    Reset            : bool R_EDGE;  (*Nulování poèítadla pulzù*)
    Freeze           : bool;  (*Zastaví èítání a nastaví frekvenci na nulu*)
    Filter           : time :=  T#2s;  (*Èasová konstanta filtru frekvence*)
    MaxPeriod        : time :=  T#1m;  (*Maximální perioda mezi pulzy*)
    Base             : time :=  T#1s;  (*Základní èasová perioda pro urèování frekvence*)
  END_VAR
  VAR_OUTPUT
    Change           : bool;  (*Èítaè pulzù zmìnil hodnotu*)
    Overflow         : bool;  (*Pøeteèení èítaèe pulzù, nastavte Reset do logické 1*)
    Frequency        : real;  (*Frekvence [1/Base]*)
  END_VAR
  VAR_IN_OUT
    Counter          : dint;  (*Poèítadlo pulzù (musí bıt RETAIN!)*)
  END_VAR
  VAR
    RawFrequncy      : real;
    LastPulseTim     : time;
    PulseLen         : real;
    LastPulseLen     : real;
    Exp1             : real;
    LastFilterTime   : time;
    OldFilter        : time;
    MaxPulseLen      : real;
    Dif              : dint;
    MaxDif           : dint;
    CntOld           : uint;
    Init             : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION STRING_TO_REAL_EX : real
(*Pøevod STRING na REAL, toleruje mezery a des. èárku ve vstupním øetìzci*)
  VAR_INPUT
    input            : string [80];
  END_VAR
  VAR
    pchar1           : PTR_TO byte;
    pchar2           : PTR_TO byte;
    Buffer           : string [80];
    value1           : byte;  (*pomocna hodnota*)
  END_VAR
END_FUNCTION

__DECL FUNCTION STRING_TO_LREAL_EX : lreal
(*Pøevod STRING na LREAL, toleruje mezery a des. èárku ve vstupním øetìzci*)
  VAR_INPUT
    input            : string [80];
  END_VAR
  VAR
    pchar1           : PTR_TO byte;
    pchar2           : PTR_TO byte;
    Buffer           : string [80];
    value1           : byte;  (*pomocna hodnota*)
  END_VAR
END_FUNCTION

__DECL FUNCTION STRING_TO_INT_EX : int
(*Pøevod STRING na INT, toleruje mezery ve vstupním øetìzci*)
  VAR_INPUT
    input            : string [80];
  END_VAR
  VAR
    pchar1           : PTR_TO byte;
    pchar2           : PTR_TO byte;
    Buffer           : string [80];
    value1           : byte;  (*pomocna hodnota*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CP125x_TO_UTF8 {HIDDEN} : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
    TO_UTF8_128_255  : PTR_TO dword;
  END_VAR
  VAR_IN_OUT
    cp125x           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1250_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#00AC82E2,16#00BDBFEF,16#009A80E2,16#00BDBFEF,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#00BDBFEF,16#00B080E2,16#0000A0C5,16#00B980E2,16#00009AC5,16#0000A4C5,16#0000BDC5,16#0000B9C5,
      16#00BDBFEF,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00BDBFEF,16#00A284E2,16#0000A1C5,16#00BA80E2,16#00009BC5,16#0000A5C5,16#0000BEC5,16#0000BAC5,
      16#0000A0C2,16#000087CB,16#000098CB,16#000081C5,16#0000A4C2,16#000084C4,16#0000A6C2,16#0000A7C2,
      16#0000A8C2,16#0000A9C2,16#00009EC5,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#0000BBC5,
      16#0000B0C2,16#0000B1C2,16#00009BCB,16#000082C5,16#0000B4C2,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#0000B8C2,16#000085C4,16#00009FC5,16#0000BBC2,16#0000BDC4,16#00009DCB,16#0000BEC4,16#0000BCC5,
      16#000094C5,16#000081C3,16#000082C3,16#000082C4,16#000084C3,16#0000B9C4,16#000086C4,16#000087C3,
      16#00008CC4,16#000089C3,16#000098C4,16#00008BC3,16#00009AC4,16#00008DC3,16#00008EC3,16#00008EC4,
      16#000090C4,16#000083C5,16#000087C5,16#000093C3,16#000094C3,16#000090C5,16#000096C3,16#000097C3,
      16#000098C5,16#0000AEC5,16#00009AC3,16#0000B0C5,16#00009CC3,16#00009DC3,16#0000A2C5,16#00009FC3,
      16#000095C5,16#0000A1C3,16#0000A2C3,16#000083C4,16#0000A4C3,16#0000BAC4,16#000087C4,16#0000A7C3,
      16#00008DC4,16#0000A9C3,16#000099C4,16#0000ABC3,16#00009BC4,16#0000ADC3,16#0000AEC3,16#00008FC4,
      16#000091C4,16#000084C5,16#000088C5,16#0000B3C3,16#0000B4C3,16#000091C5,16#0000B6C3,16#0000B7C3,
      16#000099C5,16#0000AFC5,16#0000BAC3,16#0000B1C5,16#0000BCC3,16#0000BDC3,16#0000A3C5,16#000099CB
    ];
  END_VAR
  VAR_IN_OUT
    cp1250           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1251_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#000082D0,16#000083D0,16#009A80E2,16#000093D1,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#00AC82E2,16#00B080E2,16#000089D0,16#00B980E2,16#00008AD0,16#00008CD0,16#00008BD0,16#00008FD0,
      16#000092D1,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00BDBFEF,16#00A284E2,16#000099D1,16#00BA80E2,16#00009AD1,16#00009CD1,16#00009BD1,16#00009FD1,
      16#0000A0C2,16#00008ED0,16#00009ED1,16#000088D0,16#0000A4C2,16#000090D2,16#0000A6C2,16#0000A7C2,
      16#000081D0,16#0000A9C2,16#000084D0,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#000087D0,
      16#0000B0C2,16#0000B1C2,16#000086D0,16#000096D1,16#000091D2,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#000091D1,16#009684E2,16#000094D1,16#0000BBC2,16#000098D1,16#000085D0,16#000095D1,16#000097D1,
      16#000090D0,16#000091D0,16#000092D0,16#000093D0,16#000094D0,16#000095D0,16#000096D0,16#000097D0,
      16#000098D0,16#000099D0,16#00009AD0,16#00009BD0,16#00009CD0,16#00009DD0,16#00009ED0,16#00009FD0,
      16#0000A0D0,16#0000A1D0,16#0000A2D0,16#0000A3D0,16#0000A4D0,16#0000A5D0,16#0000A6D0,16#0000A7D0,
      16#0000A8D0,16#0000A9D0,16#0000AAD0,16#0000ABD0,16#0000ACD0,16#0000ADD0,16#0000AED0,16#0000AFD0,
      16#0000B0D0,16#0000B1D0,16#0000B2D0,16#0000B3D0,16#0000B4D0,16#0000B5D0,16#0000B6D0,16#0000B7D0,
      16#0000B8D0,16#0000B9D0,16#0000BAD0,16#0000BBD0,16#0000BCD0,16#0000BDD0,16#0000BED0,16#0000BFD0,
      16#000080D1,16#000081D1,16#000082D1,16#000083D1,16#000084D1,16#000085D1,16#000086D1,16#000087D1,
      16#000088D1,16#000089D1,16#00008AD1,16#00008BD1,16#00008CD1,16#00008DD1,16#00008ED1,16#00008FD1
    ];
  END_VAR
  VAR_IN_OUT
    cp1251           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1252_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#00AC82E2,16#00BDBFEF,16#009A80E2,16#000092C6,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#000086CB,16#00B080E2,16#0000A0C5,16#00B980E2,16#000092C5,16#00BDBFEF,16#0000BDC5,16#00BDBFEF,
      16#00BDBFEF,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00009CCB,16#00A284E2,16#0000A1C5,16#00BA80E2,16#000093C5,16#00BDBFEF,16#0000BEC5,16#0000B8C5,
      16#0000A0C2,16#0000A1C2,16#0000A2C2,16#0000A3C2,16#0000A4C2,16#0000A5C2,16#0000A6C2,16#0000A7C2,
      16#0000A8C2,16#0000A9C2,16#0000AAC2,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#0000AFC2,
      16#0000B0C2,16#0000B1C2,16#0000B2C2,16#0000B3C2,16#0000B4C2,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#0000B8C2,16#0000B9C2,16#0000BAC2,16#0000BBC2,16#0000BCC2,16#0000BDC2,16#0000BEC2,16#0000BFC2,
      16#000080C3,16#000081C3,16#000082C3,16#000083C3,16#000084C3,16#000085C3,16#000086C3,16#000087C3,
      16#000088C3,16#000089C3,16#00008AC3,16#00008BC3,16#00008CC3,16#00008DC3,16#00008EC3,16#00008FC3,
      16#000090C3,16#000091C3,16#000092C3,16#000093C3,16#000094C3,16#000095C3,16#000096C3,16#000097C3,
      16#000098C3,16#000099C3,16#00009AC3,16#00009BC3,16#00009CC3,16#00009DC3,16#00009EC3,16#00009FC3,
      16#0000A0C3,16#0000A1C3,16#0000A2C3,16#0000A3C3,16#0000A4C3,16#0000A5C3,16#0000A6C3,16#0000A7C3,
      16#0000A8C3,16#0000A9C3,16#0000AAC3,16#0000ABC3,16#0000ACC3,16#0000ADC3,16#0000AEC3,16#0000AFC3,
      16#0000B0C3,16#0000B1C3,16#0000B2C3,16#0000B3C3,16#0000B4C3,16#0000B5C3,16#0000B6C3,16#0000B7C3,
      16#0000B8C3,16#0000B9C3,16#0000BAC3,16#0000BBC3,16#0000BCC3,16#0000BDC3,16#0000BEC3,16#0000BFC3
    ];
  END_VAR
  VAR_IN_OUT
    cp1252           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1253_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#00AC82E2,16#00BDBFEF,16#009A80E2,16#000092C6,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#00BDBFEF,16#00B080E2,16#00BDBFEF,16#00B980E2,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,
      16#00BDBFEF,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00BDBFEF,16#00A284E2,16#00BDBFEF,16#00BA80E2,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,
      16#0000A0C2,16#000085CE,16#000086CE,16#0000A3C2,16#0000A4C2,16#0000A5C2,16#0000A6C2,16#0000A7C2,
      16#0000A8C2,16#0000A9C2,16#00BDBFEF,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#009580E2,
      16#0000B0C2,16#0000B1C2,16#0000B2C2,16#0000B3C2,16#000084CE,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#000088CE,16#000089CE,16#00008ACE,16#0000BBC2,16#00008CCE,16#0000BDC2,16#00008ECE,16#00008FCE,
      16#000090CE,16#000091CE,16#000092CE,16#000093CE,16#000094CE,16#000095CE,16#000096CE,16#000097CE,
      16#000098CE,16#000099CE,16#00009ACE,16#00009BCE,16#00009CCE,16#00009DCE,16#00009ECE,16#00009FCE,
      16#0000A0CE,16#0000A1CE,16#00BDBFEF,16#0000A3CE,16#0000A4CE,16#0000A5CE,16#0000A6CE,16#0000A7CE,
      16#0000A8CE,16#0000A9CE,16#0000AACE,16#0000ABCE,16#0000ACCE,16#0000ADCE,16#0000AECE,16#0000AFCE,
      16#0000B0CE,16#0000B1CE,16#0000B2CE,16#0000B3CE,16#0000B4CE,16#0000B5CE,16#0000B6CE,16#0000B7CE,
      16#0000B8CE,16#0000B9CE,16#0000BACE,16#0000BBCE,16#0000BCCE,16#0000BDCE,16#0000BECE,16#0000BFCE,
      16#000080CF,16#000081CF,16#000082CF,16#000083CF,16#000084CF,16#000085CF,16#000086CF,16#000087CF,
      16#000088CF,16#000089CF,16#00008ACF,16#00008BCF,16#00008CCF,16#00008DCF,16#00008ECF,16#00BDBFEF
    ];
  END_VAR
  VAR_IN_OUT
    cp1253           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1254_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#00AC82E2,16#000081C2,16#009A80E2,16#000092C6,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#000086CB,16#00B080E2,16#0000A0C5,16#00B980E2,16#000092C5,16#00008DC2,16#00008EC2,16#00008FC2,
      16#000090C2,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00009CCB,16#00A284E2,16#0000A1C5,16#00BA80E2,16#000093C5,16#00009DC2,16#00009EC2,16#0000B8C5,
      16#0000A0C2,16#0000A1C2,16#0000A2C2,16#0000A3C2,16#0000A4C2,16#0000A5C2,16#0000A6C2,16#0000A7C2,
      16#0000A8C2,16#0000A9C2,16#0000AAC2,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#0000AFC2,
      16#0000B0C2,16#0000B1C2,16#0000B2C2,16#0000B3C2,16#0000B4C2,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#0000B8C2,16#0000B9C2,16#0000BAC2,16#0000BBC2,16#0000BCC2,16#0000BDC2,16#0000BEC2,16#0000BFC2,
      16#000080C3,16#000081C3,16#000082C3,16#000083C3,16#000084C3,16#000085C3,16#000086C3,16#000087C3,
      16#000088C3,16#000089C3,16#00008AC3,16#00008BC3,16#00008CC3,16#00008DC3,16#00008EC3,16#00008FC3,
      16#00009EC4,16#000091C3,16#000092C3,16#000093C3,16#000094C3,16#000095C3,16#000096C3,16#000097C3,
      16#000098C3,16#000099C3,16#00009AC3,16#00009BC3,16#00009CC3,16#0000B0C4,16#00009EC5,16#00009FC3,
      16#0000A0C3,16#0000A1C3,16#0000A2C3,16#0000A3C3,16#0000A4C3,16#0000A5C3,16#0000A6C3,16#0000A7C3,
      16#0000A8C3,16#0000A9C3,16#0000AAC3,16#0000ABC3,16#0000ACC3,16#0000ADC3,16#0000AEC3,16#0000AFC3,
      16#00009FC4,16#0000B1C3,16#0000B2C3,16#0000B3C3,16#0000B4C3,16#0000B5C3,16#0000B6C3,16#0000B7C3,
      16#0000B8C3,16#0000B9C3,16#0000BAC3,16#0000BBC3,16#0000BCC3,16#0000B1C4,16#00009FC5,16#0000BFC3
    ];
  END_VAR
  VAR_IN_OUT
    cp1254           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION

__DECL FUNCTION CP1255_TO_UTF8 : udint
  VAR_INPUT
    maxLen           : udint;  (*maximum len of output buffer including end zero*)
  END_VAR
  VAR
    TO_UTF8_128_255  : ARRAY [128..255] OF dword :=  [
      16#00AC82E2,16#00BDBFEF,16#009A80E2,16#000092C6,16#009E80E2,16#00A680E2,16#00A080E2,16#00A180E2,
      16#000086CB,16#00B080E2,16#00BDBFEF,16#00B980E2,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,
      16#00BDBFEF,16#009880E2,16#009980E2,16#009C80E2,16#009D80E2,16#00A280E2,16#009380E2,16#009480E2,
      16#00009CCB,16#00A284E2,16#00BDBFEF,16#00BA80E2,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,
      16#0000A0C2,16#0000A1C2,16#0000A2C2,16#0000A3C2,16#00AA82E2,16#0000A5C2,16#0000A6C2,16#0000A7C2,
      16#0000A8C2,16#0000A9C2,16#000097C3,16#0000ABC2,16#0000ACC2,16#0000ADC2,16#0000AEC2,16#0000AFC2,
      16#0000B0C2,16#0000B1C2,16#0000B2C2,16#0000B3C2,16#0000B4C2,16#0000B5C2,16#0000B6C2,16#0000B7C2,
      16#0000B8C2,16#0000B9C2,16#0000B7C3,16#0000BBC2,16#0000BCC2,16#0000BDC2,16#0000BEC2,16#0000BFC2,
      16#0000B0D6,16#0000B1D6,16#0000B2D6,16#0000B3D6,16#0000B4D6,16#0000B5D6,16#0000B6D6,16#0000B7D6,
      16#0000B8D6,16#0000B9D6,16#00BDBFEF,16#0000BBD6,16#0000BCD6,16#0000BDD6,16#0000BED6,16#0000BFD6,
      16#000080D7,16#000081D7,16#000082D7,16#000083D7,16#0000B0D7,16#0000B1D7,16#0000B2D7,16#0000B3D7,
      16#0000B4D7,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,16#00BDBFEF,
      16#000090D7,16#000091D7,16#000092D7,16#000093D7,16#000094D7,16#000095D7,16#000096D7,16#000097D7,
      16#000098D7,16#000099D7,16#00009AD7,16#00009BD7,16#00009CD7,16#00009DD7,16#00009ED7,16#00009FD7,
      16#0000A0D7,16#0000A1D7,16#0000A2D7,16#0000A3D7,16#0000A4D7,16#0000A5D7,16#0000A6D7,16#0000A7D7,
      16#0000A8D7,16#0000A9D7,16#0000AAD7,16#00BDBFEF,16#00BDBFEF,16#008E80E2,16#008F80E2,16#00BDBFEF
    ];
  END_VAR
  VAR_IN_OUT
    cp1255           : string [255];
    utf8             : string [255];
  END_VAR
END_FUNCTION



{LIBFILE="LOCALLIB\ICONTROLLIB_V20_20170209.MLB"}
(* Knihovna vıvojového systému Mosaic *)
(* Jméno souboru : C:\TecoLib\iControlLib_V20_20170209.mlb *)
(* Knihovna : iControlLib 2.0 *)
(* Autor : Teco a.s. *)
(* Autorská práva : (c)2017 Teco a.s. *)
(* Verze IEC pøekladaèe : 3.12.13.0 *)
(* Verze assembleru : 4.3.00 *)

//{Knihovna : iControlLib 2.0  }
(* Historie: *)
(*
v1.0 16.12.2014 nem  první verze pro testy
v1.1 09.02.2015 nem  oprava bloku fb_iDimmerRGB
                     sesouhlaseno chování blokù fb_iDimmer,
                     fb_iDimmerLED a fb_iDimmerRGB
v1.2 13.05.2015 nem  úprava fb_iJalousie kvùli spolupráci 
                     s blokem fbJalAlarm + zkrácena vıchozí 
                     hodnota pauseTime na 1 sec
                     upraven fb_TimeAction pro dlouhou dobu cyklu
v1.3 20.08.2015 nem  úprava fb_iDimmer - vıpoèet ramp
v1.4 25.11.2015 nem  úprava fb_iDimmerRGB - nastaveni barev z iFoxtrot
v1.5 14.12.2015 nem  doplnìny bloky fb_iScene4 a fb_iScene8
                     pro øízení scén
v1.6 03.02.2016 nem  doplnìny bloky fb_iWebConf, fb_iWebCamera
                     a fb_iSocket
v1.7 26.07.2016 nem  doplnìn blok fb_iDisplay
v1.8 26.08.2016 nem  doplnìn blok fb_iDisplay_OnOff, fb_iDisplay_Val,
                     fb_iDisplay_Edit, vynechán blok fb_iDisplay
v1.9 neveøejná  nem  blok fb_iTherm nahrazen blokem fb_iSensorTemp,
                     blok fb_iButton1 nahrazen blokem fb_Button1,
                     vynechány bloky fb_iButton2, fb_iContact
v2.0 09.02.2017 nem  zmìna direktiv PUBLIC na PUBLIC_iFOX  
                     doplnìny bloky fb_iTimeProgWeek, 
                     fb_iTimeProgWeek1 a fb_iTimeProgWeek2
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\DATABOXLIB_V16_20160713.MLB"}
// {LIBRARY="LOCALLIB\DEBUGCOMLIB_V16_20140422.MLB"}

VAR_GLOBAL CONSTANT
 ICL_SIZE_NAME : int :=  24;
 ICL_IFOX_PATH : string [12] :=  'WWW/iFOX/';
 APP_ICON_default : uint :=  0;
 APP_ICON_socket : uint :=  1;
 APP_ICON_fan : uint :=  2;
 APP_ICON_heating : uint :=  3;
 APP_ICON_extLink : uint :=  1000;
 APP_ICON_rain : uint :=  1001;
 APP_ICON_vlc : uint :=  1002;
 APP_ICON_parking : uint :=  1003;
 APP_ICON_parkingcar : uint :=  1004;
 APP_ICON_music : uint :=  1005;
 APP_ICON_radarcloud : uint :=  1006;
 APP_ICON_kodi : uint :=  1007;

END_VAR

TYPE T_SET_RGB_LIGHT :
  STRUCT
    level            : real;
    RGB              : T_RGB_COLOR;
  END_STRUCT;
END_TYPE

TYPE  T_TIME_VAL : time :=  T#24h00m0s;
END_TYPE

TYPE T_TIME_PROG_WEEK :
  STRUCT
    name             : string [24];  (*název casoveho programu*)
    update           : usint;  (*pozadavek na update cas. programu z aplikace iFoxtrot*)
    typ              : usint;  (*ICL_TPW_TYPE_HEATING, ICL_TPW_TYPE_COOLING, ICL_TPW_TYPE_HEATING_COOLING*)
    numTimes         : usint;  (*pocet casovych znacek za den (min 2, max 7)*)
    units            : usint;  (*jednotky 0 = °C, 1 = °F*)
    heatTemp         : ARRAY [0..3] OF real;  (*teploty topeni pro kazdy rezim casoveho programu*)
    coolTemp         : ARRAY [0..3] OF real;  (*teploty chlazeni pro kazdy rezim casoveho programu*)
    times            : ARRAY [0..6,0..6] OF T_TIME_VAL;  (*casove intervaly casoveho programu*)
    values           : ARRAY [0..6,0..7] OF usint;  (*rezimy casoveho programu*)
    holiday          : ARRAY [0..1] OF dt;  (*dovolena [od, do]*)
    reserved         : dword;  (*rezerva*)
    crc              : uint;  (*crc = 0 ... povel ze strany termostatu a nebo web rozhrani pro ukladani struktury do souboru*)
  END_STRUCT;
END_TYPE

TYPE T_TIME_PROG_WEEK_STAT :
  STRUCT
    manual           : bool;  (*0 = auto, 1 = manual*)
    holiday          : bool;  (*1 = is holiday*)
    heat             : bool;  (*pozadavek na topeni*)
    cool             : bool;  (*pozadavek na chlazeni*)
    units            : bool;  (*0 = °C, 1 = °F*)
    roomTemp         : real;  (*teplota v mistnosti*)
    heatTemp         : real;  (*pozadovana teplota topeni*)
    coolTemp         : real;  (*pozadovana teplota chlazeni*)
    mode             : sint;  (*zvoleny rezim ... 0 = limit, 1 = ECO, 2 = NIGHT {utlum), 3 = DAY (komfort)*)
    interval         : usint;  (*aktualni interval podle cas. programu*)
    delta            : real;  (*aktualni delta <-5.0, 5.0>*)
    initial          : word;  (*initial.0-1	editacni mod - 0 zobrazit data, 1 prochazeni dat, 2 editacni rezim*)
  END_STRUCT;
END_TYPE

TYPE T_TIME_PROG_WEEK_CONT :
  STRUCT
    nextProg         : bool;  (*auto -> manual, manual -> auto*)
    nextMode         : bool;  (*zmena rezimu v manualnim modu (ECO <-> NIGHT <-> DAY)*)
    rqMode           : sint :=  -1;  (*zvoleny rezim ... -1 = no request, 0 = limit, 1 = ECO, 2 = NIGHT {utlum), 3 = DAY (komfort)*)
    rqNewDelta       : bool;  (*zadost o nastaveni nove hodnoty delta*)
    newDelta         : real;  (*nova hodnota delta <-5.0, 5.0>*)
  END_STRUCT;
END_TYPE

TYPE T_TIME_PROG_WEEK_INTERFACE :
  STRUCT
    stat             : T_TIME_PROG_WEEK_STAT;
    cont             : T_TIME_PROG_WEEK_CONT;
  END_STRUCT;
END_TYPE

TYPE T_TIME_PROG_WEEK_WEB_SETTINGS :
  STRUCT
    darkBg           : bool;  (*:= FALSE = light background, TRUE = dark background*)
    copyT            : string [24];  (*:= 'Copy ';*)
    selT             : string [24];  (*:= 'Select dest. day';*)
    startH           : string [32];  (*:= 'Set start of holiday';*)
    endH             : string [32];  (*:= 'Set end of holiday';*)
    days             : ARRAY [0..6] OF string [4];  (*:= ['MON','TUE','WED','THU','FRI','SAT','SUN'];*)
    months           : ARRAY [1..12] OF string [16];  (*:= ['January','February','March','April','May','June','July','August','September','October','November','December'];*)
    buttons          : ARRAY [0..4] OF string [9];  (*:= ['HEAT','COOL','HOLIDAY','CANCEL','SAVE']*)
  END_STRUCT;
END_TYPE

TYPE  T_TIME_PROG_WEEK_WEB_SETTINGS_CZE : T_TIME_PROG_WEEK_WEB_SETTINGS :=  ( copyT   := 'Kopírovat ',
                                                                          selT    := 'Zvolte cílovı den',
                                                                          startH  := 'Zadejte zaèátek dovolené',
                                                                          endH    := 'Zadejte konec dovolené',
                                                                          days    := ['PO','ÚT','ST','ÈT','PÁ','SO','NE'],
                                                                          months  := ['Leden','Únor','Bøezen','Duben','Kvìten','Èerven','Èervenec','Srpen','Záøí','Øíjen','Listopad','Prosinec'],
                                                                          buttons := ['TOPENÍ','CHLAZENÍ','DOVOLENÁ','ZRUŠIT','ULOIT']);
END_TYPE

TYPE  T_TIME_PROG_WEEK_WEB_SETTINGS_ENG : T_TIME_PROG_WEEK_WEB_SETTINGS :=  ( copyT   := 'Copy ',
                                                                          selT    := 'Select dest. day',
                                                                          startH  := 'Set start of holiday',
                                                                          endH    := 'Set end of holiday',
                                                                          days    := ['MO','TU','WE','TH','FR','SA','SU'],
                                                                          months  := ['January','February','March','April','May','June','July','August','September','October','November','December'],
                                                                          buttons := ['HEATING','COOLING','HOLIDAY','CANCEL','SAVE']);
END_TYPE

__DECL FUNCTION_BLOCK fb_iLight
(*Základní ovládání vıstupu pro svìtlo*)
  VAR_INPUT
    lightOn          : bool R_EDGE;  (*zapnutí svìtla*)
    lightOff         : bool R_EDGE;  (*vypnutí svìtla*)
    lightToggle      : bool R_EDGE;  (*pøepnutí svìtla*)
    timeLimit        : time;  (*max. doba svícení*)
    webToggle        : bool R_EDGE;  (*pøepnutí svìtla z web stránky*)
    lightReset       : bool R_EDGE;  (*centrální vypnutí svìtel*)
    name             : string [24];  (*název svìtla*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*ovládání svìtla*)
  END_VAR
  VAR
    GTSAP1_LIGHT_name {PUBLIC_IFOX} : string [24];
    GTSAP1_LIGHT_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_type {PUBLIC_IFOX} : bool :=  0;
    GTSAP1_LIGHT_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;
    stopTime         : time;
  END_VAR
END_FUNCTION_BLOCK

VAR_GLOBAL CONSTANT
 ICL_RELAY_TYPE_ON_OFF : usint :=  0;
 ICL_RELAY_TYPE_DIMMING : usint :=  1;
 ICL_RELAY_TYPE_MULTI_STATE : usint :=  2;

END_VAR

__DECL FUNCTION_BLOCK fb_iRelay
(*Funkcní blok pro základní ovládání vıstupu pro relé
         Impuls na vstupu 'in' vyvolá na vıstupu 'out' impuls o délce definované v parametru 'pulsTime'.
         Pøi nábìné hranì vstupu 'in' (z 0 na 1) je generován impuls na vıstup 'out_on'. Na vıstupu 'out_off' je generován impuls kdy probìhne sestupná hrana (z 1 na 0).*)
  VAR_INPUT
    relayOn          : bool R_EDGE;  (*zapnutí relé*)
    relayOff         : bool R_EDGE;  (*vypnutí relé*)
    relayToggle      : bool R_EDGE;  (*prepnutí relé*)
    pulseTime        : time;  (*doba trvání pulzu*)
    webToggle        : bool R_EDGE;  (*prepnutí relé z web stránky*)
    relayReset       : bool R_EDGE;  (*centrální vypnutí relé*)
    symbol           : uint;  (*ikona pro aplikace iFoxtrot (APP_ICON_socket, ...)*)
    name             : string [24];  (*název*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*øízení relé*)
    out_on           : bool;  (*pulz na nábìnou hranu out (z 0 do 1)*)
    out_off          : bool;  (*pulz na sestupnou hranu out (z 1 do 0)*)
  END_VAR
  VAR
    GTSAP1_RELAY_name {PUBLIC_IFOX} : string [24];  (*název funkcního bloku*)
    GTSAP1_RELAY_enable {PUBLIC_IFOX} : bool :=  1;  (*povel k zobrazení funkcního bloku v aplikace iFoxtrot App*)
    GTSAP1_RELAY_type {PUBLIC_IFOX} : usint :=  ICL_RELAY_TYPE_ON_OFF;  (*model relé (0=onOff, 1=dimming, 2=multiState)*)
    GTSAP1_RELAY_symbol {PUBLIC_IFOX} : uint;  (*ikona pro aplikace iFoxtrot (APP_ICON_socket, ...)*)
    GTSAP1_RELAY_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;  (*povel na zapnutí/vypnutí relé z aplikace iFoxtrot*)
    stopTime         : time;
    in_Ftrig         : F_TRIG;
    in_Rtrig         : R_TRIG;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iAction
(*zachytává poadavky na akci nastavované z mobilní aplikace nebo z web stránky
   pokud pøijde poadavek, tak nastaví vıstup bloku na TRUE a vynuluje poadavek
   vıstup bloku se pak pouije pro vyvolání akce v PLC*)
  VAR_INPUT
    action           : bool R_EDGE;  (*poadavek na akci*)
    webAction        : bool R_EDGE;  (*poadavek na akci z web stránky*)
    name             : string [24];  (*název*)
  END_VAR
  VAR
    GTSAP1_ACTION_name {PUBLIC_IFOX} : string [24];
    GTSAP1_ACTION_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_ACTION_exec {OPEN_UP} {PUBLIC_IFOX} : bool;
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*TRUE znamená provést akci*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_Button1
(*blok pro zpracovani tlaèítka s vyhodnocením krátkého a dlouhého stisku*)
  VAR_INPUT
    in               : bool;  (*vstup tlaèítka*)
    pressTime        : time :=  T#750ms;  (*èas dlouhého stisku*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*kopie vstupu in*)
    click            : bool;  (*krátkı stisk*)
    press            : bool;  (*dlouhı stisk*)
  END_VAR
  VAR
    in_Ftrig         : F_TRIG;
    in_ton           : TON;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iSensorPIR
(*èidlo pøítomnosti*)
  VAR_INPUT
    in               : bool;  (*PIR èidlo*)
    delay            : time;  (*necitlivost*)
    name             : string [24];  (*název*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*detekce pohybu*)
  END_VAR
  VAR
    GTSAP1_PIRSENSOR_name {PUBLIC_IFOX} : string [24];
    GTSAP1_PIRSENSOR_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_PIRSENSOR_value {PUBLIC_IFOX} : bool;
    timSensor        : TON;  (*zpozdeni detekce*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iDimmer
(*Stmívané svìtlo s nastavováním úrovnì pomocí dlouhıch stiskù,
         krátké stisky zapínají a vypínají svìtlo (na nastavenou úroveò s rampou "offOnRamp")
         dlouhé stisky mìní nastavenou úroveò s rampou "setRamp"
         Vıstup level 0..100% - pro øízení 0..10V*)
  VAR_INPUT
    lightOn          : bool R_EDGE;  (*zapnout svìtlo na poslední úroveò (krátkı stisk)*)
    levelUp          : bool;  (*zvıšit úroveò (dlouhı stisk)*)
    lightOff         : bool R_EDGE;  (*vypnout svìtlo (krátkı stisk)*)
    levelDw          : bool;  (*sníit úroveò (dlouhı stisk)*)
    lightToggle      : bool R_EDGE;  (*pøepnutí svìtla*)
    minLevel         : real :=  10.0;  (*min úroveò pro svìtlo (zapalovací úroveò) [%]*)
    offOnRamp        : time :=  T#5s;  (*rampa Off/On z minLevel na 100% [sec]*)
    setRamp          : time :=  T#8s;  (*rampa Up/Dw z minLevel na 100% [sec]*)
    timeLimit        : time;  (*omezení max. doby svícení (automaticky zhasne) [sec]*)
    webToggle        : bool R_EDGE;  (*ovládání svìtla z web stránky*)
    lightReset       : bool R_EDGE;  (*centrální zhasnutí*)
    name             : string [24];  (*název svìtla*)
  END_VAR
  VAR_IN_OUT
    setLevel         : real;  (*poslední nastavená úroveò (promìnnou umístit do VAR_GLOBAL RETAIN)*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*signalizace On/Off*)
    level            : real;  (*úroveò 0..100[%]*)
    minLev           : real;  (*minimální úroveò 0..90[%]*)
  END_VAR
  VAR
    GTSAP1_LIGHT_name {PUBLIC_IFOX} : string [24];
    GTSAP1_LIGHT_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_type {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_dimtype {PUBLIC_IFOX} : bool :=  0;
    GTSAP1_LIGHT_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_LIGHT_dimlevel {OPEN_UP} {PUBLIC_IFOX} : real;
    gtsap1_old       : real;  (*pro vyhodnoceni zmeny od mobilni aplikace*)
    oldSetLevel      : real;  (*pro vyhodnoceni zmeny retain promenne*)
    toggleOn         : bool;  (*pomocna pro zapnuti*)
    toggleOff        : bool;  (*pomocna pro vypnuti*)
    lastLevelUp      : bool;
    lastLevelDw      : bool;
    lastSL52         : udint;
    tim              : TON;  (*casovac pro omezeni doby osvetleni*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iDimmerLED
(*Stmívané LED svìtlo s nastavováním úrovnì pomocí dlouhıch stiskù,
         krátké stisky zapínají a vypínají svìtlo (na nastavenou úroveò s rampou "offOnRamp")
         dlouhé stisky mìní nastavenou úroveò s rampou "setRamp"
         Vıstup level 0..100%, rampa [sec] - pro jeden kanál CIB modulu ULED/ILED/RLC*)
  VAR_INPUT
    lightOn          : bool R_EDGE;  (*zapnout svìtlo na poslední úroveò (krátkı stisk)*)
    levelUp          : bool;  (*zvıšit úroveò (dlouhı stisk)*)
    lightOff         : bool R_EDGE;  (*vypnout svìtlo (krátkı stisk)*)
    levelDw          : bool;  (*sníit úroveò (dlouhı stisk)*)
    lightToggle      : bool R_EDGE;  (*pøepnutí svìtla*)
    minLevel         : real :=  10.0;  (*min úroveò pro svìtlo (zapalovací úroveò) [%]*)
    offOnRamp        : time :=  T#5s;  (*rampa Off/On z minLevel na 100% [sec]*)
    setRamp          : time :=  T#8s;  (*rampa Up/Dw z minLevel na 100% [sec]*)
    timeLimit        : time;  (*omezení max. doby svícení (automaticky zhasne) [sec]*)
    webToggle        : bool R_EDGE;  (*ovládání svìtla z web stránky*)
    lightReset       : bool R_EDGE;  (*centrální zhasnutí*)
    name             : string [24];  (*název svìtla*)
  END_VAR
  VAR_IN_OUT
    setLevel         : real;  (*poslední nastavená úroveò (promìnnou umístit do VAR_GLOBAL RETAIN)*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*signalizace On/Off*)
    level            : real;  (*úroveò 0..100 [%]*)
    ramp             : usint;  (*rampa pro On/Off*)
    minLev           : real;  (*minimální úroveò 0..90[%]*)
  END_VAR
  VAR
    GTSAP1_LIGHT_name {PUBLIC_IFOX} : string [24];
    GTSAP1_LIGHT_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_type {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_dimtype {PUBLIC_IFOX} : bool :=  0;
    GTSAP1_LIGHT_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_LIGHT_dimlevel {OPEN_UP} {PUBLIC_IFOX} : real;
    gtap1_old        : real;  (*pro vyhodnoceni zmeny od mobilni aplikace*)
    oldSetLevel      : real;  (*pro vyhodnoceni zmeny retain promenne*)
    toggleOn         : bool;  (*pomocna pro zapnuti*)
    toggleOff        : bool;  (*pomocna pro vypnuti*)
    lastLevelUp      : bool;
    lastLevelDw      : bool;
    lastSL52         : udint;
    tim              : TON;  (*casovac pro omezeni doby osvetleni*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION iControl_RGB_COLOR_TO_UDINT {HIDDEN} : udint
  VAR_INPUT
    color            : T_RGB_COLOR;
  END_VAR
END_FUNCTION

__DECL FUNCTION iControl_UDINT_TO_RGB_COLOR {HIDDEN} : T_RGB_COLOR
  VAR_INPUT
    color            : udint;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fb_iDimmerRGB
(*Stmívané RGB svìtlo,
         krátké stisky zapínají a vypínají svìtlo (na nastavenou úroveò s rampou "offOnRamp")
         dlouhé stisky mìní nastavenou úroveò s rampou "setRamp"
         Vıstup 3 x level 0..100%, 3 x rampa [sec] - pro 3 RGB kanály CIB modulu ULED/ILED*)
  VAR_INPUT
    lightOn          : bool R_EDGE;  (*zapnout svìtlo na poslední úroveò (krátkı stisk)*)
    levelUp          : bool;  (*zvıšit úroveò (dlouhı stisk)*)
    lightOff         : bool R_EDGE;  (*vypnout svìtlo (krátkı stisk)*)
    levelDw          : bool;  (*sníit úroveò (dlouhı stisk)*)
    lightToggle      : bool R_EDGE;  (*pøepnutí svìtla*)
    minLevel         : real :=  5.0;  (*min úroveò pro svìtlo (zapalovací úroveò) [%]*)
    offOnRamp        : time :=  T#5s;  (*rampa Off/On z minLevel na 100% [sec]*)
    setRamp          : time :=  T#8s;  (*rampa Up/Dw z minLevel na 100% [sec]*)
    timeLimit        : time;  (*omezení max. doby svícení (automaticky zhasne) [sec]*)
    webToggle        : bool R_EDGE;  (*ovládání svìtla z web stránky*)
    lightReset       : bool R_EDGE;  (*centrální zhasnutí*)
    name             : string [24];  (*název svìtla*)
  END_VAR
  VAR_IN_OUT
    setLight         : T_SET_RGB_LIGHT;  (*poslední nastavená úroveò a barva (promìnnou umístit do VAR_GLOBAL RETAIN)*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*signalizace On/Off*)
    levelRed         : real;  (*red úroveò 0..100 [%]*)
    levelGreen       : real;  (*green úroveò 0..100 [%]*)
    levelBlue        : real;  (*blue úroveò 0..100 [%]*)
    rampRed          : usint;  (*red rampa [sec]*)
    rampGreen        : usint;  (*green rampa [sec]*)
    rampBlue         : usint;  (*blue rampa [sec]*)
    minLev           : real;  (*minimální úroveò 0..90[%]*)
  END_VAR
  VAR
    GTSAP1_LIGHT_name {PUBLIC_IFOX} : string [24];
    GTSAP1_LIGHT_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_type {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_dimtype {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_LIGHT_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_LIGHT_dimlevel {OPEN_UP} {PUBLIC_IFOX} : real;
    GTSAP1_LIGHT_rgb {OPEN_UP} {PUBLIC_IFOX} : udint;
    toggleOn         : bool;  (*pomocna pro zapnuti*)
    toggleOff        : bool;  (*pomocna pro vypnuti*)
    lastLevelUp      : bool;
    lastLevelDw      : bool;
    lastSL52         : udint;
    level            : real;  (*svetelnost RGB (jas)*)
    oldSetGTSAP1     : T_SET_RGB_LIGHT;
    oldSetLight      : T_SET_RGB_LIGHT;
    tim              : TON;  (*casovac pro omezeni doby osvetleni*)
    red              : real;
    green            : real;
    blue             : real;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iJalousie
(*Ovládání aluzií*)
  VAR_INPUT
    rotUp            : bool R_EDGE;  (*pootoèit aluzie nahoru*)
    up               : bool R_EDGE;  (*aluzie nahoru*)
    rotDw            : bool R_EDGE;  (*pootoèit aluzie dolu*)
    dw               : bool R_EDGE;  (*aluzie dolu*)
    block            : bool;  (*blokace ovládacích vstupù*)
    stop             : bool R_EDGE;  (*zastavení pohybu*)
    ctrUp            : bool R_EDGE;  (*centrální vytaení aluzie*)
    ctrDw            : bool R_EDGE;  (*centrální spuštìní aluzie*)
    webUp            : bool R_EDGE;  (*pro vysunutí aluzií z web rozhraní*)
    webDw            : bool R_EDGE;  (*pro spuštìní aluzií z web rozhraní*)
    upDwTime         : time :=  T#20s;  (*maximální doba bìhu pohonu*)
    rotTime          : time :=  T#0.5s;  (*doba trvání kroku pri pootáèení*)
    pauseTime        : time :=  T#1.0s;  (*prodleva pøed otoèením smìru*)
    ctrTime          : time := T#10.0s ;  (*zpodìní centrálního pohybu*)
    name             : string [24];  (*název aluzie*)
  END_VAR
  VAR_OUTPUT
    outUp            : bool;  (*aluzie nahoru*)
    outDw            : bool;  (*aluzie dolu*)
    sig              : bool;  (*signalizace chodu*)
    sigUp            : bool;  (*signalizace aluzie nahoøe*)
    sigDw            : bool;  (*signalizace aluzie dole*)
  END_VAR
  VAR
    GTSAP1_SHUTTER_name {PUBLIC_IFOX} : string [24];
    GTSAP1_SHUTTER_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_SHUTTER_up {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_down {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_run {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_uppos {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_downpos {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_up_control {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_down_control {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_rotup_control {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SHUTTER_rotdown_control {OPEN_UP} {PUBLIC_IFOX} : bool;
    cas_stop         : time :=  T#0s;
    pauseUp          : bool;
    pauseDw          : bool;
    longUpDw         : bool;
    timUp            : TOF;
    timDw            : TOF;
    centrUp          : bool;
    centrUpH         : bool;
    centrDw          : bool;
    centrDwH         : bool;
    centrDelay       : time;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_TimeAction
(*Blok pro vytvoøení impulsu v zadanı èas.
   timeOfAction := T#22h odpovídá èasu 22:00:00 [hh:mm:ss]*)
  VAR_INPUT
    enable           : bool;  (*povolení aktivace*)
    timeOfAction1    : time;  (*èas aktivace 1.vıstupu*)
    timeOfAction2    : time;  (*èas aktivace 2.vıstupu*)
  END_VAR
  VAR_OUTPUT
    out1             : bool;  (*vıstup pro 1.akci*)
    out2             : bool;  (*vıstup pro 2.akci*)
  END_VAR
  VAR
    out1Trgr         : R_TRIG;
    out2Trgr         : R_TRIG;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_JalAlarm
(*Základní reakce aluzie na poplachy.
    Priority:
    1. poár   : blokace a otevøení
    2. námraza : blokace a zastavení
    3. vítr    : blokace a otevøení
    4. sklo    : zavøení*)
  VAR_INPUT
    fire             : bool;  (*poplach poár: vytaení aluzie a blokace vstupù*)
    ice              : bool;  (*poplach námraza: zastavení pohybu, blokace vstupù*)
    wind             : bool;  (*poplach silnı vítr: vytaení aluzie a blokace vstupù*)
    glass            : bool;  (*poplach rozbití skla: spuštìní aluzie*)
    blockJal         : bool;  (*blokace ovládání*)
    stopJal          : bool R_EDGE;  (*vstup zastavení pohybu aluzie*)
    ctrUpJal         : bool R_EDGE;  (*central nahoru*)
    ctrDwJal         : bool R_EDGE;  (*central dolu*)
  END_VAR
  VAR_OUTPUT
    block            : bool;  (*blokace ovládání, propojit s blokem zaluzie*)
    stop             : bool;  (*zastavení pohybu aluzie, propojit s blokem zaluzie*)
    ctrUp            : bool;  (*central nahoru, propojit s blokem zaluzie*)
    ctrDw            : bool;  (*centralne dolu, propojit s blokem zaluzie*)
  END_VAR
  VAR
    fire_Rtrig       : R_TRIG;
    ice_Rtrig        : R_TRIG;
    wind_Rtrig       : R_TRIG;
    glass_Rtrig      : R_TRIG;
    fireH            : bool;
    iceH             : bool;
    windH            : bool;
    glassH           : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_RndPulse
(*Funkèní blok pro generování náhodnıch zapínacích pulzù s rùznou délkou.*)
  VAR_INPUT
    enable           : bool;  (*Povolení funkce FB*)
    sTime            : time;  (*zaèátek generování pulzù T#21h odpovídá 21:00:00 [hh:mm:ss]*)
    eTime            : time;  (*Konec generování novıch pulzù T#21h odpovídá 21:00:00 [hh:mm:ss]*)
    minOffT          : time :=  T#5m;  (*Minimální délka intervalu nuly*)
    minOnT           : time :=  T#10m;  (*Minimální délka intervalu jednièky*)
    maxLenght        : time :=  T#1h;  (*Maximální délka pulzu jak "1" tak "0".*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*vıstup náhodnì generovanıch a náhodnì dlouhıch pulzù*)
    outOn            : bool;  (*nábìná hrana vıstupu out*)
    outOff           : bool;  (*sestupná hrana vıstupu out*)
  END_VAR
  VAR
    tOffStart        : bool;
    timerOff         : TON;
    timerOn          : TON;
    bottleneck       : real;
    i                : usint :=  1;
    duration         : time;
    cas              : ARRAY [1..2] OF time;
    dTime            : time;
    trigOn           : R_TRIG;
    trigOff          : F_TRIG;
    seed             : dint;
    init_seed        : bool :=  1;
    k                : dint;
    random           : real;
  END_VAR
END_FUNCTION_BLOCK

VAR_GLOBAL CONSTANT
 ICL_SCENE_PREFIX : string [4] :=  'SCN_';
 ICL_SCENE_FORMAT : string [8] :=  '%04X.sc?';
 ICL_SCENE_ERR1 : string [23] :=  'Name of scene is empty!';
 ICL_SCENE_ERR2 : string [11] :=  ' not found!';

END_VAR

__DECL FUNCTION_BLOCK fb_iScene4
(*Nastavení scén
         Blok umoòuje nastavit a 4 scény*)
  VAR_INPUT
    scene1On         : bool R_EDGE;  (*zapnutí scény 1*)
    scene2On         : bool R_EDGE;  (*zapnutí scény 2*)
    scene3On         : bool R_EDGE;  (*zapnutí scény 3*)
    scene4On         : bool R_EDGE;  (*zapnutí scény 4*)
    webScene1On      : bool R_EDGE;  (*zapnutí scény 1 z web stránky*)
    webScene2On      : bool R_EDGE;  (*zapnutí scény 2 z web stránky*)
    webScene3On      : bool R_EDGE;  (*zapnutí scény 3 z web stránky*)
    webScene4On      : bool R_EDGE;  (*zapnutí scény 4 z web stránky*)
    name             : string [24];  (*název scény*)
  END_VAR
  VAR_OUTPUT
    busy             : bool;  (*blok pracuje*)
    lastErr          : string [80];  (*popis pøípadné chyby*)
    file             : string [12];  (*jméno json souboru s popisem scény*)
  END_VAR
  VAR
    GTSAP1_SCENE_name {PUBLIC_IFOX} : string [24];
    GTSAP1_SCENE_file {PUBLIC_IFOX} : string [24];
    GTSAP1_SCENE_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_SCENE_num {PUBLIC_IFOX} : usint :=  4;
    GTSAP1_SCENE_set1 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set2 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set3 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set4 {OPEN_UP} {PUBLIC_IFOX} : bool;
    rqScene1         : bool;
    rqScene2         : bool;
    rqScene3         : bool;
    rqScene4         : bool;
    rqScene          : bool;
    JsonParser       : fbJsonFileParser;  (*FB pro pársování souboru*)
    json             : TJsonInfo;  (*struktura pro vısledky pársování*)
    fileName         : string [24];
    extNum           : usint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iScene8
(*Nastavení scén
         Blok umoòuje nastavit a 8 scén*)
  VAR_INPUT
    scene1On         : bool R_EDGE;  (*zapnutí scény 1*)
    scene2On         : bool R_EDGE;  (*zapnutí scény 2*)
    scene3On         : bool R_EDGE;  (*zapnutí scény 3*)
    scene4On         : bool R_EDGE;  (*zapnutí scény 4*)
    scene5On         : bool R_EDGE;  (*zapnutí scény 5*)
    scene6On         : bool R_EDGE;  (*zapnutí scény 6*)
    scene7On         : bool R_EDGE;  (*zapnutí scény 7*)
    scene8On         : bool R_EDGE;  (*zapnutí scény 8*)
    webScene1On      : bool R_EDGE;  (*zapnutí scény 1 z web stránky*)
    webScene2On      : bool R_EDGE;  (*zapnutí scény 2 z web stránky*)
    webScene3On      : bool R_EDGE;  (*zapnutí scény 3 z web stránky*)
    webScene4On      : bool R_EDGE;  (*zapnutí scény 4 z web stránky*)
    webScene5On      : bool R_EDGE;  (*zapnutí scény 5 z web stránky*)
    webScene6On      : bool R_EDGE;  (*zapnutí scény 6 z web stránky*)
    webScene7On      : bool R_EDGE;  (*zapnutí scény 7 z web stránky*)
    webScene8On      : bool R_EDGE;  (*zapnutí scény 8 z web stránky*)
    name             : string [24];  (*název scény*)
  END_VAR
  VAR_OUTPUT
    busy             : bool;  (*blok pracuje*)
    lastErr          : string [80];  (*popis pøípadné chyby*)
    file             : string [12];  (*jméno json souboru s popisem scény*)
  END_VAR
  VAR
    GTSAP1_SCENE_name {PUBLIC_IFOX} : string [24];
    GTSAP1_SCENE_file {PUBLIC_IFOX} : string [24];
    GTSAP1_SCENE_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_SCENE_num {PUBLIC_IFOX} : usint :=  8;
    GTSAP1_SCENE_set1 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set2 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set3 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set4 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set5 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set6 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set7 {OPEN_UP} {PUBLIC_IFOX} : bool;
    GTSAP1_SCENE_set8 {OPEN_UP} {PUBLIC_IFOX} : bool;
    rqScene1         : bool;
    rqScene2         : bool;
    rqScene3         : bool;
    rqScene4         : bool;
    rqScene5         : bool;
    rqScene6         : bool;
    rqScene7         : bool;
    rqScene8         : bool;
    rqScene          : bool;
    JsonParser       : fbJsonFileParser;  (*FB pro pársování souboru*)
    json             : TJsonInfo;  (*struktura pro vısledky pársování*)
    fileName         : string [24];
    extNum           : usint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iWebConf
(*Zveøejnìní web stránky do aplikace iFoxtrot nebo odkaz na aplikaci spouštìnou z iFoxtrot

  podporované aplikace pres URL:
  SoundTouch:     (SoundTouch Controller od Bose https:itunes.apple.com/cz/app/soundtouch-controller/id708379313?mt=8)
  control4v2:     (Control4 https:itunes.apple.com/us/app/control4/id734435367?mt=8)
  sonos:          (Sonos Controller https:itunes.apple.com/cz/app/sonos-controller/id293523031?mt=8)
  vlc-x-callback: (VLC, popis parametru: https:wiki.videolan.org/Documentation:IOS/#x-callback-url)
  vlc:            (VLC bez moznosti dalsich parametru)
  xbmcremote:     (Official Kodi Remote https:itunes.apple.com/cz/app/official-kodi-remote/id520480364?mt=8)
  music:          (systemova iOS Music aplikace)*)
  VAR_INPUT
    link             : string [80];  (*odkaz na web stránku v PLC nebo URL aplikace ('vlc://', ...) ! rozlišují se velká a malá písmena*)
    symbol           : uint :=  APP_ICON_extLink;  (*název ikony pro aplikaci (rain, vlc, parking, parkingcar, music, radarcloud, kodi)*)
    name             : string [24];  (*název bloku (iFoxtrot ikony)*)
  END_VAR
  VAR
    GTSAP1_WEBCONF_name {PUBLIC_IFOX} : string [24];
    GTSAP1_WEBCONF_url {PUBLIC_IFOX} : string [80];  (*napr. index.xml*)
    GTSAP1_WEBCONF_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_WEBCONF_symbol {PUBLIC_IFOX} : uint;  (*viz konstanty APP_ICON_extLink, APP_ICON_rain, APP_ICON_vlc, APP_ICON_parking, APP_ICON_parkingcar, APP_ICON_music, APP_ICON_radarcloud, APP_ICON_kodi*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iWebCamera
(*Zveøejnìní web kamery do aplikace iFoxtrot*)
  VAR_INPUT
    url              : string [80];  (*URL adresa web kamery*)
    name             : string [24];  (*název bloku (iFoxtrot ikony)*)
  END_VAR
  VAR
    GTSAP1_CAMERA_name {PUBLIC_IFOX} : string [24];
    GTSAP1_CAMERA_url {PUBLIC_IFOX} : string [80];  (*napr. http://posta.mukolin.cz/axis-cgi/jpg/image.cgi*)
    GTSAP1_CAMERA_enable {PUBLIC_IFOX} : bool :=  1;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iSocket
(*Základní ovládání vıstupu pro relé*)
  VAR_INPUT
    socketOn         : bool R_EDGE;  (*zapnutí zásuvky*)
    socketOff        : bool R_EDGE;  (*vypnutí zásuvky*)
    socketToggle     : bool R_EDGE;  (*pøepnutí zásuvky*)
    pulseTime        : time;  (*doba trvání pulzu*)
    webToggle        : bool R_EDGE;  (*pøepnutí zásuvky z web stránky*)
    socketReset      : bool R_EDGE;  (*centrální vypnutí zásuvky*)
    name             : string [24];  (*název*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*øízení zásuvky*)
  END_VAR
  VAR
    GTSAP1_SOCKET_name {PUBLIC_IFOX} : string [24];
    GTSAP1_SOCKET_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_SOCKET_onoff {OPEN_UP} {PUBLIC_IFOX} : bool;
    stopTime         : time;
  END_VAR
END_FUNCTION_BLOCK

VAR_GLOBAL CONSTANT
 ICL_DISPLAY_TYPE_ON_OFF : usint :=  0;
 ICL_DISPLAY_TYPE_VALUE : usint :=  1;

END_VAR

__DECL FUNCTION_BLOCK fb_iDisplay_Val
(*blok pro zobrazení hodnoty vèetnì fyzikálních jednotek*)
  VAR_INPUT
    value            : real;  (*hodnota (REAL promìnná)*)
    unit             : string [8];  (*jednotky (kWh, km/h, ...)*)
    precision        : int;  (*poèet zobrazenıch desetinnıch míst (0 = celé èíslo)*)
    link             : string [80];  (*URL adresa web stránky*)
    symbol           : uint;  (*ikona pro aplikace iFoxtrot (APP_ICON_socket, ...)*)
    name             : string [24];  (*název*)
  END_VAR
  VAR_OUTPUT
    out              : real;  (*kopie 'value'*)
  END_VAR
  VAR
    GTSAP1_DISPLAY_name {PUBLIC_IFOX} : string [24];  (*název funkcního bloku*)
    GTSAP1_DISPLAY_enable {PUBLIC_IFOX} : bool :=  1;  (*ikona pro aplikace iFoxtrot (APP_ICON_socket, ...)*)
    GTSAP1_DISPLAY_edit {PUBLIC_IFOX} : bool :=  0;  (*promenou je mozno editovat v aplikaci*)
    GTSAP1_DISPLAY_type {PUBLIC_IFOX} : usint :=  ICL_DISPLAY_TYPE_VALUE;  (*typ zobrazovane hodnoty (0=onOff, 1=real value)*)
    GTSAP1_DISPLAY_symbol {PUBLIC_IFOX} : uint;  (*povel k zobrazení funkcního bloku v aplikace iFoxtrot App*)
    GTSAP1_DISPLAY_value {PUBLIC_IFOX} : real;  (*hodnota k zobrazeni*)
    GTSAP1_DISPLAY_unit {PUBLIC_IFOX} : string [8];  (*Jednotka merení (%,bar,C/F ...)*)
    GTSAP1_DISPLAY_precision {PUBLIC_IFOX} : int;  (*presnost desetinnou cást hodnoty*)
    GTSAP1_DISPLAY_url {PUBLIC_IFOX} : string [80];  (*Odkaz (URL) na web stranku (graf, historie ...)*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iDisplay_Edit
(*Funkcni blok pro zobrazení v aplikace iFoxtrot hodnoty vèetni fyzikálních jednotek*)
  VAR_INPUT
    unit             : string [8];  (*jednotky (kWh, km/h, ...)*)
    precision        : int;  (*poèet zobrazenıch desetinnıch míst (0 = celé èíslo)*)
    limitUp          : real;  (*Horni limit promeny 'Value'*)
    limitDw          : real;  (*Dolni limit promeny 'Value'*)
    step             : real :=  0.1;  (*Minimalni hodnota zmeny z app iFoxtrot*)
    webUp            : bool R_EDGE;  (*zvıšit hodnotu z web rozhraní*)
    webDw            : bool R_EDGE;  (*sníit hodnotu z web rozhraní*)
    link             : string [80];  (*URL adresa web stránky*)
    symbol           : uint;  (*ikona pro aplikace iFoxtrot (APP_ICON_socket, ...)*)
    name             : string [24];  (*název funkcního bloku v aplikace iFoxtrot App*)
  END_VAR
  VAR_IN_OUT
    value            : real;  (*hodnota (REAL promìnná)*)
  END_VAR
  VAR_OUTPUT
    out              : real;  (*kopie 'Value'*)
  END_VAR
  VAR
    GTSAP1_DISPLAY_name {PUBLIC_IFOX} : string [24];  (*název funkcního bloku*)
    GTSAP1_DISPLAY_enable {PUBLIC_IFOX} : bool :=  1;  (*povel k zobrazení funkcního bloku v aplikace iFoxtrot App*)
    GTSAP1_DISPLAY_edit {PUBLIC_IFOX} : bool :=  1;  (*promena ukazuje ze promena*)
    GTSAP1_DISPLAY_type {PUBLIC_IFOX} : usint :=  ICL_DISPLAY_TYPE_VALUE;  (*model relé (0=onOff, 1=real/uint value)*)
    GTSAP1_DISPLAY_symbol {PUBLIC_IFOX} : uint;  (*ikona pro aplikace iFoxtrot (APP_ICON_socket, ...)*)
    GTSAP1_DISPLAY_value {PUBLIC_IFOX} : real;  (*hodnota k zobrazeni*)
    GTSAP1_DISPLAY_unit {PUBLIC_IFOX} : string [8];  (*Jednotka merení (%,bar,C/F ...)*)
    GTSAP1_DISPLAY_precision {PUBLIC_IFOX} : int;  (*presnost desetinnou cást hodnoty*)
    GTSAP1_DISPLAY_url {PUBLIC_IFOX} : string [80];  (*Odkaz (URL) na web stranku (graf, historie ...)*)
    GTSAP1_DISPLAY_incValue {PUBLIC_IFOX} : bool;  (*Povel s App iFoxtrot ke zvıšení poadovanou hodnotu*)
    GTSAP1_DISPLAY_decValue {PUBLIC_IFOX} : bool;  (*Povel s App iFoxtrot ke sníení poadovanou hodnotu*)
    GTSAP1_DISPLAY_valueSet {OPEN_UP} {PUBLIC_IFOX} : real :=  1E38;  (*tuhle promennou zapise iFoxtrot do JSON souboru kdyz je fb_iDisplay_Val_edit zarazen do sceny*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iDisplay_OnOff
(*blok pro zobrazení boolove hodnoty*)
  VAR_INPUT
    value            : bool;  (*hodnota (BOOL promìnná)*)
    symbolOn         : uint;  (*ikona pro aplikace iFoxtrot (APP_ICON_socket, ...)*)
    symbolOff        : uint;  (*ikona pro aplikace iFoxtrot (APP_ICON_socket, ...)*)
    name             : string [24];  (*název*)
  END_VAR
  VAR_OUTPUT
    out              : bool;  (*copy of 'Value'                                   kopie 'Value'*)
  END_VAR
  VAR
    GTSAP1_DISPLAY_name {PUBLIC_IFOX} : string [24];  (*název funkcního bloku*)
    GTSAP1_DISPLAY_enable {PUBLIC_IFOX} : bool :=  1;  (*povel k zobrazení funkcního bloku v aplikace iFoxtrot App*)
    GTSAP1_DISPLAY_edit {PUBLIC_IFOX} : bool :=  0;
    GTSAP1_DISPLAY_type {PUBLIC_IFOX} : usint :=  ICL_DISPLAY_TYPE_ON_OFF;  (*typ zobrazovane hodnoty (0=onOff, 1=real value)*)
    GTSAP1_DISPLAY_symbol {PUBLIC_IFOX} : uint;  (*ikona pro aplikace iFoxtrot (APP_ICON_socket, ...)*)
    GTSAP1_DISPLAY_onOff {PUBLIC_IFOX} : bool;  (*hodnota (stav) k zobrazeni*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iSensorTemp
(*blok pro mìøení teploty (ve stupních Celsia) s fitrem 1.øádu
   a moností korekce vstupní hodnoty*)
  VAR_INPUT
    in               : real;  (*teplota (REAL promìnná)*)
    offset           : real;  (*korekce teploty*)
    filterTime       : time :=  T#30s;  (*èasová konstanta filtru*)
    name             : string [24];  (*název*)
  END_VAR
  VAR_OUTPUT
    out              : real;  (*out := filter( in + offset)*)
  END_VAR
  VAR
    GTSAP1_DISPLAY_name {PUBLIC_IFOX} : string [24];  (*název funkcního bloku*)
    GTSAP1_DISPLAY_enable {PUBLIC_IFOX} : bool :=  1;  (*ikona pro aplikace iFoxtrot (APP_ICON_socket, ...)*)
    GTSAP1_DISPLAY_edit {PUBLIC_IFOX} : bool :=  0;  (*promenou je mozno editovat v aplikaci*)
    GTSAP1_DISPLAY_type {PUBLIC_IFOX} : usint :=  ICL_DISPLAY_TYPE_VALUE;  (*typ zobrazovane hodnoty (0=onOff, 1=real value)*)
    GTSAP1_DISPLAY_symbol {PUBLIC_IFOX} : uint :=  100;  (*povel k zobrazení funkcního bloku v aplikace iFoxtrot App*)
    GTSAP1_DISPLAY_value {PUBLIC_IFOX} : real;  (*hodnota k zobrazeni*)
    GTSAP1_DISPLAY_unit {PUBLIC_IFOX} : string [8] :=  '°C';  (*Jednotka merení (%,bar,C/F ...)*)
    GTSAP1_DISPLAY_precision {PUBLIC_IFOX} : int :=  1;  (*presnost desetinnou cást hodnoty*)
    filter           : fbFirstOrder;  (*filtr prvniho radu*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbHolidayCalendar {HIDDEN}
  VAR_INPUT
    vis              : bool;
    refr             : bool R_EDGE;
    webGuiSettings   : T_TIME_PROG_WEEK_WEB_SETTINGS;
  END_VAR
  VAR_OUTPUT
    butCancel        : bool;
    butSave          : bool;
    canvasOK         : bool;
    canvasLen        : uint;
  END_VAR
  VAR_IN_OUT
    canvasData       : TCanvasData1024;
    startHoliday     : dt;
    endHoliday       : dt;
  END_VAR
  VAR CONSTANT
    CC_width         : int :=  700;
    CC_width2        : int :=  CC_width /2;
    CC_width3        : int :=  CC_width /3;
    CC_width5        : int :=  CC_width /5;
    CC_width7        : int :=  CC_width /7;
    CC_width10       : int :=  CC_width /10;
    CC_width20       : int :=  CC_width /20;
    CC_height        : int :=  1000;
    CC_R             : int :=  CC_width /14;
    CC_textSize      : int :=  CC_height /25;  (*40*)
  END_VAR
  VAR
    fontColor        : udint;
    selectColor      : udint;
    visTrig          : R_TRIG;
    wasTouch         : bool;
    tecoDT           : TTecoDateTime;
    startDate        : dt;
    holIndex         : uint;
    holiday          : ARRAY [0..1] OF dt;
    today            : date;
    i                : int;
    d                : dt;
    m                : usint;
  END_VAR
END_FUNCTION_BLOCK

VAR_GLOBAL CONSTANT
 ICL_TPW_TYPE_HEATING : usint :=  1;
 ICL_TPW_TYPE_COOLING : usint :=  2;
 ICL_TPW_TYPE_HEATING_COOLING : usint :=  3;
 ICL_TPW_PREFIX : string [4] :=  'WTP_';
 ICL_TPW_FORMAT : string [8] :=  '%04X.JSN';
 ICL_TPW_JSN_EXT : string [8] :=  '.JSN';
 ICL_TPW_APP_EXT : string [8] :=  '.APP';
 ICL_TPW_BAK_EXT : string [8] :=  '.BAK';
 ICL_TPW_TMP_EXT : string [8] :=  '.TMP';
 ICL_TPW_ERR1 : string [26] :=  'Name of program is empty!';
 ICL_TPW_ERR2 : string [11] :=  ' not found!';
 ICL_TPW_ERR3 : string [19] :=  'Corrupted JSON file';
 ICL_TPW_ERR4 : string [23] :=  'No time program in JSON';
 ICL_TPW_KEYWORD : string [16] :=  'timeProgWeekData';

END_VAR

__DECL FUNCTION AddTextToRecord {HIDDEN} : udint
(*Add next part of record*)
  VAR_INPUT
    text             : string [80];
    ptrRec           : PTR_TO string [255];
  END_VAR
  VAR
    lenRec           : uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION fc_TimeProgWeek_LoadDefault {HIDDEN} : bool
  VAR_INPUT
    units            : bool;  (*0 = °C, 1 = °F*)
    timeProgWeekData : PTR_TO T_TIME_PROG_WEEK;
  END_VAR
  VAR CONSTANT
    initTimeProg24x7data : T_TIME_PROG_WEEK :=  ( typ      := ICL_TPW_TYPE_HEATING_COOLING,
                                                 numTimes := 5,
                                                 heatTemp := [5.0,19.0,21.0,23.0],  // musi byt vzestupne
                                                 coolTemp := [33.0,28.0,25.0,24.0], // musi byt sestupne
                                                 times    := [T#0h0m0s, T#6h15m0s, T#8h0m0s,  T#15h00m0s, T#21h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#6h15m0s, T#8h0m0s,  T#15h00m0s, T#21h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#6h15m0s, T#8h0m0s,  T#15h00m0s, T#21h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#6h15m0s, T#8h0m0s,  T#15h00m0s, T#21h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#6h15m0s, T#8h0m0s,  T#15h00m0s, T#21h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#7h15m0s, T#22h0m0s, T#24h00m0s, T#24h00m0s, T#24h0m0s, T#24h0m0s,
                                                              T#0h0m0s, T#7h15m0s, T#22h0m0s, T#24h00m0s, T#24h00m0s, T#24h0m0s, T#24h0m0s],
                                                 values   := [1,2,3,2,3,1,1,1,
                                                              1,2,3,2,3,1,1,1,
                                                              1,2,3,2,3,1,1,1,
                                                              1,2,3,2,3,1,1,1,
                                                              1,2,3,2,3,1,1,1,
                                                              1,2,3,2,1,1,1,1,
                                                              1,2,3,2,1,1,1,1],
                                                 holiday  := [DT#1970-01-01-00:00:00.0, DT#1970-01-01-00:00:00.0],   // dovolena <od, do>
                                                 crc      := 0);
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fb_TimeProgWeek_LoadDataFromFile {HIDDEN}
  VAR_INPUT
    exec             : bool;
    units            : bool;  (*0 = °C, 1 = °F*)
    fileName         : string [24];
    timeProgName     : string [80];  (*jmeno promenne s casovym programem*)
    timeProgAdr      : udint;  (*adresa promenne s casovym programem*)
  END_VAR
  VAR_OUTPUT
    done             : bool;
    busy             : bool;
    lastErr          : string [80];  (*popis pøípadné chyby*)
    rqSave           : bool;  (*ulozit po nacteni*)
    err              : bool;
  END_VAR
  VAR
    JsonParser {HIDDEN} : fbJsonFileParser;  (*FB pro pársování souboru*)
    json             : TJsonInfo;  (*struktura pro vısledky pársování*)
    res              : bool;
    isTimeProg24x7   : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION ICL_GetVarNameByAdr {HIDDEN} : string [255]
(*Vrátí jméno promìnné podle adresy promìnné*)
  VAR_INPUT
    varAdr           : udint;  (*adresa promìnné*)
    varSize          : udint;  (*velikost promìnné (poèet bytù)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fb_TimeProgWeek_Basic {HIDDEN}
(*Tento blok zajišuje ukládání a naèítání èasového programu do/z JSON souboru*)
  VAR_INPUT
    typ              : usint :=  ICL_TPW_TYPE_HEATING_COOLING;  (*typ èasového programu : ICL_TPW_TYPE_HEATING, ICL_TPW_TYPE_COOLING, ICL_TPW_TYPE_HEATING_COOLING*)
    numTimes         : usint;  (*pocet casovych znacek za den (min 2, max 7)*)
    units            : bool;  (*0 = °C, 1 = °F*)
    name             : string [24];  (*název èasového programu*)
    adrTimeProg      : udint;  (*adresa promìnné timeProgWeekData*)
  END_VAR
  VAR_OUTPUT
    busy             : bool;  (*blok pracuje*)
    lastErr          : string [80];  (*popis pøípadné chyby*)
    file             : string [12];  (*jméno json souboru s popisem èasového programu*)
  END_VAR
  VAR
    WeekTimeProg24x7data_temp {OPEN_UP} {TRACK_ADR} : T_TIME_PROG_WEEK;
    TimeProgWeek_LoadDataFromFile {HIDDEN} : fb_TimeProgWeek_LoadDataFromFile;
    fb_CreatePath    : CreatePath;
    fb_WriteToFile   : WriteToFile;
    fb_ReadFromFile  : ReadFromFile;
    fileDesc         : TFileInfo;  (*struktura s informacemi o souboru*)
    jsonBuf          : ARRAY [0..1023] OF usint;  (*buffer pro sestaveni json souboru*)
    fileName         : string [24];
    fileName_app     : string [24];
    fileName_tmp     : string [24];
    fileName_bak     : string [24];
    extSaveRq        : bool;
    extCopyReadRq    : bool;
    extCopyWriteRq   : bool;
    extSaveToBAKRq   : bool;
    extSaveToJSNRq   : bool;
    extPowerUpLoadRq : bool :=  TRUE;
    extPowerUpLoadJSNRq : bool :=  TRUE;
    extPowerUpLoadBAKRq : bool;
    extSaveNewDataToJSNRq : bool :=  TRUE;
    extSaveNewDataToBAKRq : bool;
    extLoadTempDataRq : bool;
    last_units       : bool;
    last_crc         : uint;
    ptr              : PTR_TO usint;
    ptrTimeProgWeekData : PTR_TO T_TIME_PROG_WEEK;
    ptr_str          : PTR_TO string [80];
    crc              : uint;
    varBaseName      : string [80];
    iFoxPath         : string [20] :=  ICL_IFOX_PATH;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION CustomTimeProgTimToPos {HIDDEN} : int
  VAR_INPUT
    tim              : time;
    width            : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION CustomTimeProgPosToTim {HIDDEN} : time
  VAR_INPUT
    pos              : int;
    width            : int;
    lim              : real;
    w                : real;
    t                : time;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fb_TimeProgWeek_Web {HIDDEN}
  VAR_INPUT
    adrTimeProg      : udint;
  END_VAR
  VAR_IN_OUT
    webGuiSettings   : T_TIME_PROG_WEEK_WEB_SETTINGS;
    canvasData       : TCanvasData1024;
  END_VAR
  VAR_OUTPUT
    canvasOK         : bool;
    canvasLen        : uint;
  END_VAR
  VAR CONSTANT
    C_HEAT_3         : udint :=  GCOLOR_RED_600;  (*16#182CDD;*)
    C_HEAT_2         : udint :=  GCOLOR_DEEP_ORANGE_500;  (*16#1958E2;*)
    C_HEAT_1         : udint :=  GCOLOR_ORANGE_600;  (*16#1B83E6;*)
    C_HEAT_0         : udint :=  GCOLOR_AMBER_400;  (*16#D9CE7E;*)
    C_COOL_3         : udint :=  GCOLOR_INDIGO_600;  (*16#DD7718;*)
    C_COOL_2         : udint :=  GCOLOR_BLUE_600;  (*16#E2A219;*)
    C_COOL_1         : udint :=  GCOLOR_LIGHT_BLUE_400;  (*16#E6D11B;*)
    C_COOL_0         : udint :=  GCOLOR_CYAN_200;  (*16#58AEFF;*)
    C_BUTTONS        : udint :=  GCOLOR_DEEP_PURPLE_500;
    C_BACKGR         : udint :=  16#686868;  (*== GCOLOR_GREY_650;*)
    C_LINE           : udint :=  GCOLOR_GREY_300;  (*16#E1E1E1;*)
    C_NUM_STEPS      : usint :=  4;  (*pocet teplot*)
    C_NUM_TIMES      : usint :=  7;  (*max. pocet casovych znacek za den*)
    C_HEAT_COLOR     : ARRAY [0..3] OF udint :=  [C_HEAT_0, C_HEAT_1, C_HEAT_2, C_HEAT_3];
    C_COOL_COLOR     : ARRAY [0..3] OF udint :=  [C_COOL_0, C_COOL_1, C_COOL_2, C_COOL_3];
    C_width          : int :=  500;
    C_width2         : int :=  C_width /2;
    C_width3         : int :=  C_width /3;
    C_width6         : int :=  C_width /6;
    C_4C_width6      : int :=  4*C_width6;
    C_5C_width6      : int :=  5*C_width6;
    C_width10        : int :=  C_width /10;
    C_width10_70     : int :=  C_width10 - C_width/70;  (*posun zacatku pri kresleni prvku do horni listy*)
    C_9C_width10     : int :=  9*C_width10;
    C_height         : int :=  350;
    C_hMarg          : int :=  3*C_width /20;
    C_hMarg2         : int :=  C_hMarg /2;
    C_hMarg4         : int :=  C_hMarg /4;
    C_wMarg          : int :=  C_width /20;
    C_wMarg2         : int :=  C_wMarg /2;
    C_hStep          : int :=  C_width /20;
    C_hStep2         : int :=  C_hStep /2;
    C_selDist        : int :=  C_width /20;
    C_textSize       : int :=  C_hMarg2 /3 -1;
    C_textSize2      : int :=  C_textSize /2;
    C_controlBar     : int :=  -70-C_hMarg2;
    C_R              : int :=  C_textSize*3 /2 +3;
    C_wb             : int :=  C_width /8 +5;
    C_wb2            : int :=  C_wb /2;
    C_wb4            : int :=  C_wb /4;
    C_ws             : int :=  C_width /7;
    C_ws2            : int :=  C_ws /2;
  END_VAR
  VAR
    numTimes         : usint;  (*pocet casovych znacek za den*)
    selLine          : int;
    selBlock         : int;
    selButton1       : int;
    C_delta          : real;
    endTime          : time :=  T#24h;
    actTim           : PTR_TO time;
    actTim2          : PTR_TO time;
    actTim3          : PTR_TO time;
    heatCool         : bool;  (*0 heating, 1 cooling*)
    wasTouch         : bool;
    rqSave           : bool;
    repaint          : bool;
    saveProg         : bool;
    counterInit      : bool;
    flgHoliday       : bool;
    copy             : int;
    counterTON       : TON;
    time_prog        : T_TIME_PROG_WEEK;  (*kopie casoveho programu*)
    ptr_time_prog    : PTR_TO T_TIME_PROG_WEEK;  (*ptr na casovy program*)
    disp             : usint :=  255;
    corrDist         : int;
    x_time           : int;
    lastTouchX       : int;
    lastTouchY       : int;
    lastCRC          : uint;
    HolidayCalendar {HIDDEN} : fbHolidayCalendar;
    triangle         : ARRAY [0..2] OF TCanvasPoint :=  [( x := 0,  y := 0), ( x := -5,  y := 9),( x := 5,  y := 9)];
    triangleUP       : ARRAY [0..2] OF TCanvasPoint :=  [( x := 0,  y := -7),( x := -7,  y := 6),( x := 7,  y := 6)];
    triangleDW       : ARRAY [0..2] OF TCanvasPoint :=  [( x := -7, y := -6),( x := 0,   y := 7),( x := 7,  y := -6)];
    canvasMax        : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_TimeProgWeek_Control {HIDDEN}
  VAR_INPUT
    onOff            : bool :=  TRUE;  (*rizeni zapnute/vypnute*)
    manPriority      : bool;  (*0 = rezim manual skonci pri 1.zmene casoveho programu, 1 = rezim manual se ukonci pouze prepnutim do auto*)
    roomTemp         : real;  (*teplota v mistnosti*)
    hyst             : real :=  0.1;  (*hystereze (necitlivost vystupu heat/cool) <0.0,0.5>*)
    webNextProg      : bool R_EDGE;  (*auto -> manual, manual -> auto*)
    webNextMode      : bool R_EDGE;  (*zmena rezimu v manualnim modu*)
    webIncDelta      : bool R_EDGE;
    webDecDelta      : bool R_EDGE;
    adrTimeProg      : udint;
  END_VAR
  VAR_IN_OUT
    settings         : T_TIME_PROG_WEEK_INTERFACE;
  END_VAR
  VAR_OUTPUT
    status           : T_TIME_PROG_WEEK_STAT;  (*stav rizeni*)
  END_VAR
  VAR
    GTSAP1_TPW_name {PUBLIC_IFOX} : string [24];
    GTSAP1_TPW_enable {PUBLIC_IFOX} : bool :=  1;
    GTSAP1_TPW_type {PUBLIC_IFOX} : usint;  (*typ casoveho programu*)
    GTSAP1_TPW_file {PUBLIC_IFOX} : string [24];
    GTSAP1_TPW_crc {PUBLIC_IFOX} : uint;  (*posledni platne crc casoveho programu*)
    GTSAP1_TPW_update {PUBLIC_IFOX} : bool;  (*povel z aplikace na nacteni dat casoveho programu z souboru*)
    GTSAP1_TPW_manual {PUBLIC_IFOX} : bool;  (*0 = auto, 1 = manual*)
    GTSAP1_TPW_holiday {PUBLIC_IFOX} : bool;  (*0 = normal control, 1 = holiday (=> ECO mode)*)
    GTSAP1_TPW_heat {PUBLIC_IFOX} : bool;  (*pozadavek na topeni*)
    GTSAP1_TPW_cool {PUBLIC_IFOX} : bool;  (*pozadavek na chlazeni*)
    GTSAP1_TPW_roomTemp {PUBLIC_IFOX} : real;  (*teplota v mistnosti*)
    GTSAP1_TPW_heatTemp {PUBLIC_IFOX} : real;  (*pozadovana teplota topeni*)
    GTSAP1_TPW_coolTemp {PUBLIC_IFOX} : real;  (*pozadovana teplota chlazeni*)
    GTSAP1_TPW_mode {PUBLIC_IFOX} : sint;  (*zvoleny rezim ... 0 = limit, 1 = ECO, 2 = NIGHT {utlum), 3 = DAY (komfort)*)
    GTSAP1_TPW_delta {PUBLIC_IFOX} : real;  (*aktualni delta <-5.0, 5.0>*)
    GTSAP1_TPW_nextProg {PUBLIC_IFOX} : bool;  (*auto -> manual, manual -> auto*)
    GTSAP1_TPW_nextMode {PUBLIC_IFOX} : bool;  (*zmena rezimu v manualnim modu (ECO <-> NIGHT <-> DAY)*)
    GTSAP1_TPW_incDelta {PUBLIC_IFOX} : bool;  (*+0.5*)
    GTSAP1_TPW_decDelta {PUBLIC_IFOX} : bool;  (*-0.5*)
    GTSAP1_TPW_manualSet {OPEN_UP} {PUBLIC_IFOX} : sint :=  -1;  (*0 = auto, 1 = manual, -1=nenastaveno*)
    GTSAP1_TPW_modeSet {OPEN_UP} {PUBLIC_IFOX} : sint :=  -1;  (*0 = limit, 1 = ECO, 2 = NIGHT {utlum), 3 = DAY (komfort), -1=nenastaveno*)
    init             : bool;
    lastManual       : bool;
    numTimes         : usint;
    lastInterval     : usint;
    ptr_time_prog    : PTR_TO T_TIME_PROG_WEEK;
    incMode          : sint;
  END_VAR
END_FUNCTION_BLOCK

TYPE TCIB_CRC0011R_iTHERM_iRH :
  STRUCT
    iTHERM           : real;
    iRH              : usint;
  END_STRUCT;
END_TYPE

TYPE  TCIB_PAGING_ARRAY : ARRAY [0..4] OF byte;
END_TYPE

TYPE TCIB_C_RC_0011R_IN :
  STRUCT
    BUTTONS          : usint;
    iTHERM_iRH       : TCIB_CRC0011R_iTHERM_iRH;
    eTHERM           : real;
    PAGING {HIDDEN}  : TCIB_PAGING_ARRAY;
  END_STRUCT;
END_TYPE

TYPE  TCIB_CRC0011R_DATA : ARRAY [0..3] OF int;
END_TYPE

TYPE  TCIB_CRC0011R_DATA_TYPE : ARRAY [0..3] OF byte;
END_TYPE

TYPE TCIB_CRC0011R_VAL :
  STRUCT
    DATA             : TCIB_CRC0011R_DATA;
    DATA_TYPE        : TCIB_CRC0011R_DATA_TYPE;
  END_STRUCT;
END_TYPE

TYPE TCIB_CRC0011R_ICO :
  STRUCT
    BUTT_EDIT        : bool;
    BUTT_ESC         : bool;
    BUTT_OK          : bool;
    BUTT_DOWN        : bool;
    BUTT_UP          : bool;
    MODE_SUN         : bool;
    MODE_MOON        : bool;
    MODE_ECO         : bool;
    PROG_AUTOMAT     : bool;
    PROG_HAND        : bool;
    PROG_HOLIDAY     : bool;
    TEMP_INDOOR      : bool;
    TEMP_OUTDOOR     : bool;
    TEMP             : bool;
    FAN_0            : bool;
    FAN_1            : bool;
    FAN_2            : bool;
    FAN_3            : bool;
    FAN_AUTOMAT      : bool;
    HEATING          : bool;
    COOLING          : bool;
    WINDOW           : bool;
    LOCK             : bool;
    WARNING          : bool;
    DAY_1            : bool;
    DAY_2            : bool;
    DAY_3            : bool;
    DAY_4            : bool;
    DAY_5            : bool;
    DAY_6            : bool;
    DAY_7            : bool;
    LINE             : bool;
    RADIO_0          : bool;
    RADIO_1          : bool;
    RADIO_2          : bool;
    RADIO_3          : bool;
    RADIO_BATTERY    : bool;
    MAIN_VAL_C       : bool;
    MAIN_VAL_F       : bool;
    MAIN_VAL_RH      : bool;
    MAIN_VAL_PERC    : bool;
    MAIN_VAL_DOT     : bool;
    SEC_VAL_C        : bool;
    SEC_VAL_F        : bool;
    SEC_VAL_RH       : bool;
    SEC_VAL_PERC     : bool;
    SEC_VAL_COLON    : bool;
    SEC_VAL_DOT      : bool;
    SEC_VAL_DOT2     : bool;
    SEC_VAL_DOT3     : bool;
    SEC_VAL_AM       : bool;
    SEC_VAL_PM       : bool;
    ARROW            : bool;
    dummy53 {HIDDEN} : bool;
    dummy54 {HIDDEN} : bool;
    dummy55 {HIDDEN} : bool;
  END_STRUCT;
END_TYPE

TYPE TCIB_C_RC_0011R_OUT :
  STRUCT
    VAL              : TCIB_CRC0011R_VAL;
    ICO              : TCIB_CRC0011R_ICO;
    PAGING {HIDDEN}  : TCIB_PAGING_ARRAY;
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fb_TimeProgWeek_C_RC_0011R {HIDDEN}
  VAR_INPUT
    adrTimeProg      : udint;  (*adresa timeProgWeekData*)
    fan              : usint;  (*ventilace*)
  END_VAR
  VAR_IN_OUT
    settings         : T_TIME_PROG_WEEK_INTERFACE;  (*nastaveni modulu*)
    C_RC_in          : TCIB_C_RC_0011R_IN;  (*vstupni struktura (data z modulu)*)
    C_RC_out         : TCIB_C_RC_0011R_OUT;  (*vystupni struktura (data pro modul)*)
  END_VAR
  VAR_OUTPUT
    warning          : usint;  (*chyba*)
  END_VAR
  VAR
    C_RC_inL         : TCIB_C_RC_0011R_IN;  (*predchozi vstupni struktura*)
    settingsL        : T_TIME_PROG_WEEK_INTERFACE;  (*predchozi nastaveni*)
    time_progL       : T_TIME_PROG_WEEK;  (*predchozi WTP*)
    ptr_time_prog    : PTR_TO T_TIME_PROG_WEEK;  (*pointer na WTP*)
    dateTime         : TTecoDateTime;  (*cas a datum*)
    fanL             : usint;  (*ventilace (fanCoil)*)
    warningL         : usint;  (*chyba*)
    confirmWait      : usint;  (*priznak cekani na potvrzeni prijmu (odpoved)*)
    noConfirmCnt     : usint;  (*mereni, pokud modul nedostal odpoved*)
    confirmType      : usint;  (*priznak naposledy odeslanych dat*)
    confirmCnt       : usint;  (*citac odpovedi (pro detekci zmeny - inkrementuje se po kazde odpovedi)*)
    newMess          : bool;  (*priznak novych vystupnich dat/odpoved, dalsi ceka ve fronte*)
    resetUpdate      : byte;  (*pozadavek modulu o nastaveni a cas*)
    paginL           : TCIB_PAGING_ARRAY;  (*zaloha vystupniho packetu*)
    edit             : bool;  (*priznak editace v modulu*)
    crc              : uint;
    fbBlock          : usint;  (*fb synchronizuje data s displejem jen v "Editacnim(Autonomni) rezimu" (0 nezinicializovano, 1 Editacni(Autonomni) rezim, 2 ostatni rezimy)*)
    settUpdate       : bool;  (*priznak zmeny nastaveni*)
    tempUpdate       : bool;  (*priznak zmeny teploty (offsetu)*)
    tempOffs         : real;  (*offset pozadovane teploty*)
    modulInit        : word;  (*inicializacni nastaveni modulu*)
    d                : uint;
    i                : uint;
    timeVar          : dint;
    hour             : dint;
    b                : byte;
    w                : word;
    dataInd          : ARRAY [0..1] OF uint;
    dayInd           : ARRAY [0..1] OF uint;
    holidDay         : usint;
    holidMonth       : usint;
    holidYear        : usint;
    holidString      : string [22];
    holidCompare     : string [22];
    dateVar          : TTecoDateTime;
  END_VAR
  VAR CONSTANT
    PAGE_TIME        : usint :=   2#001;  (*cas a datum*)
    PAGE_SETT        : usint :=   2#010;  (*nastaveni (prijem: mode, progr, fan, warning, vysilani: warning)*)
    PAGE_WTP         : usint :=   2#011;  (*tydenni casovy program*)
    PAGE_BOARD       : usint :=   2#100;  (*rozsirujici deska*)
    PAGE_TEMP        : usint :=   2#101;  (*pozadovana rucne nastavena teplota (offset)*)
    PAGE_RESET       : usint :=   2#110;  (*pozadavek modulu o nastaveni a cas (pri kazdem spusteni)*)
    PAGE_INIT        : usint :=   2#111;  (*inicializacni nastaveni modulu*)
    PAGE_EDIT        : byte :=  2#1000;  (*priznak editace*)
    WTP_M            : byte :=  2#1000;  (*priznak rezimu casoveho programu (jako PAGE_EDIT, dokud se neprenese cas.program, je zaroven signalizovana editace)*)
    WTP_T            : byte :=  2#0000;  (*priznak casu casoveho programu*)
    WTP_TEMP         : byte :=  2#10000000;  (*0 heating, 1 cooling*)
    WTP_TNUM         : byte :=  2#0001000;  (*pocet casovych znacek WTP*)
    WTP_END          : byte :=  2#0010000;  (*prenesena vsechna data pro WTP*)
    RESET_TIME       : byte :=  2#1;  (*pozadavek o cas*)
    RESET_SETT       : byte :=  2#10;  (*pozadavek o nastaveni*)
    T_TEMPER         : byte :=  16#1;  (*teplota*)
    T_TEMPER_INPUT   : byte :=  16#2;  (*vnitrni teplota*)
    T_TEMPER_OUTPUT  : byte :=  16#3;  (*vnejsi teplota*)
    T_HUMIDITY       : byte :=  16#4;  (*vnitrni vlhkost*)
    T_TIME           : byte :=  16#5;  (*cas (jen vedl.hodnota)*)
    T_AM             : byte :=  16#20;  (*'am' u casu (jen u vedl.hodnoty)*)
    T_PM             : byte :=  16#40;  (*'pm' u casu (jen u vedl.hodnoty)*)
    T_DECIMAL_POINT  : byte :=  16#80;  (*desetinna tecka*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iTimeProgWeek
(*Øízení topení/chlazení podle èasového programu
  Nastavení èasového programu z web stránky nebo z modulu C-RC-0011R
  Ovládání topení/chlazení z web stránky nebo z modulu C-RC-0011R
  Automatická spolupráce s aplikací iFoxtrot*)
  VAR_INPUT
    onOff            : bool :=  TRUE;  (*øízení zapnuté/vypnuté*)
    units            : bool;  (*jednotky 0 = °C, 1 = °F*)
    manPriority      : bool;  (*0 = reim manual skonèí pri 1.zmìnì èasového programu, 1 = reim manual se ukonèi pouze pøepnutím do auto*)
    roomTemp         : real;  (*mìøená teplota*)
    hyst             : real :=  0.1;  (*hystereze (necitlivost vıstupu heat/cool) <0.0,0.5>*)
    typ              : usint :=  ICL_TPW_TYPE_HEATING_COOLING;  (*typ èasového programu : ICL_TPW_TYPE_HEATING, ICL_TPW_TYPE_COOLING, ICL_TPW_TYPE_HEATING_COOLING*)
    numTimes         : usint;  (*poèet èasovıch znaèek za den (min 2, max 7)*)
    webNextProg      : bool R_EDGE;  (*zmìna auto<->manual*)
    webNextMode      : bool R_EDGE;  (*zmìna v manuálním módu ECO->ÚTLUM->KOMFORT*)
    webIncDelta      : bool R_EDGE;  (*zvıšit cílovou teplotu*)
    webDecDelta      : bool R_EDGE;  (*sníit cílovou teplotu*)
    name             : string [24];  (*název èasového programu*)
  END_VAR
  VAR_IN_OUT
    TimeProg_Settings : T_TIME_PROG_WEEK_INTERFACE;  (*stav a øízení bloku*)
    TimeProg_webSettings : T_TIME_PROG_WEEK_WEB_SETTINGS;  (*texty pro web*)
    C_RC_in          : TCIB_C_RC_0011R_IN;  (*vstupní data z modulu C-RC-0011R*)
    C_RC_out         : TCIB_C_RC_0011R_OUT;  (*vıstupní data pro modul C-RC-0011R*)
  END_VAR
  VAR_OUTPUT
    heat             : bool;  (*poadavek na topeni*)
    cool             : bool;  (*poadavek na chlazeni*)
    heatTemp         : real;  (*poadovaná teplota topení*)
    coolTemp         : real;  (*poadovaná teplota chlazení*)
    webStatus        : T_TIME_PROG_WEEK_STAT;  (*stav øízení (pro web)*)
    busy             : bool;  (*blok zpracovává json soubor*)
    lastErr          : string [80];  (*popis pøípadné chyby*)
    jsonFile         : string [12];  (*jméno json souboru s popisem èasového programu*)
    timeProgWeekData {OPEN_UP} {TRACK_ADR} : T_TIME_PROG_WEEK;  (*tıdenní èasovı program*)
    canvasData       : TCanvasData1024;  (*canvas data*)
  END_VAR
  VAR
    TimeProgBasic    : fb_TimeProgWeek_Basic;
    TimeProgWeb      : fb_TimeProgWeek_Web;
    TimeProgControl  : fb_TimeProgWeek_Control;
    TimeProgDevice   : fb_TimeProgWeek_C_RC_0011R;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iTimeProgWeek1
(*Øízení topení/chlazení podle èasového programu
  Nastavení èasového programu z web stránky
  Ovládání topení/chlazení z web stránky
  Automatická spolupráce s aplikací iFoxtrot*)
  VAR_INPUT
    onOff            : bool :=  TRUE;  (*øízení zapnuté/vypnuté*)
    units            : bool;  (*jednotky 0 = °C, 1 = °F*)
    manPriority      : bool;  (*0 = reim manual skonèí pri 1.zmìnì èasového programu, 1 = reim manual se ukonèi pouze pøepnutím do auto*)
    roomTemp         : real;  (*mìøená teplota*)
    hyst             : real :=  0.1;  (*hystereze (necitlivost vıstupu heat/cool) <0.0,0.5>*)
    typ              : usint :=  ICL_TPW_TYPE_HEATING_COOLING;  (*typ èasového programu : ICL_TPW_TYPE_HEATING, ICL_TPW_TYPE_COOLING, ICL_TPW_TYPE_HEATING_COOLING*)
    numTimes         : usint;  (*poèet èasovıch znaèek za den (min 2, max 7)*)
    webNextProg      : bool R_EDGE;  (*zmìna auto<->manual*)
    webNextMode      : bool R_EDGE;  (*zmìna v manuálním módu ECO->ÚTLUM->KOMFORT*)
    webIncDelta      : bool R_EDGE;  (*zvıšit cílovou teplotu*)
    webDecDelta      : bool R_EDGE;  (*sníit cílovou teplotu*)
    name             : string [24];  (*název èasového programu*)
  END_VAR
  VAR_IN_OUT
    TimeProg_Settings : T_TIME_PROG_WEEK_INTERFACE;  (*stav a øízení bloku*)
    TimeProg_webSettings : T_TIME_PROG_WEEK_WEB_SETTINGS;  (*texty pro web*)
  END_VAR
  VAR_OUTPUT
    heat             : bool;  (*poadavek na topeni*)
    cool             : bool;  (*poadavek na chlazeni*)
    heatTemp         : real;  (*poadovaná teplota topení*)
    coolTemp         : real;  (*poadovaná teplota chlazení*)
    webStatus        : T_TIME_PROG_WEEK_STAT;  (*stav øízení*)
    busy             : bool;  (*blok zpracovává json soubor*)
    lastErr          : string [80];  (*popis pøípadné chyby*)
    jsonFile         : string [12];  (*jméno json souboru s popisem èasového programu*)
    timeProgWeekData {OPEN_UP} {TRACK_ADR} : T_TIME_PROG_WEEK;  (*tıdenní èasovı program*)
    canvasData       : TCanvasData1024;  (*canvas data*)
  END_VAR
  VAR
    TimeProgBasic    : fb_TimeProgWeek_Basic;
    TimeProgWeb      : fb_TimeProgWeek_Web;
    TimeProgControl  : fb_TimeProgWeek_Control;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fb_iTimeProgWeek2
(*Øízení topení/chlazení podle èasového programu
  Nastavení èasového programu z modulu C-RC-0011R
  Ovládání topení/chlazení z web stránky nebo z modulu C-RC-0011R
  Automatická spolupráce s aplikací iFoxtrot*)
  VAR_INPUT
    onOff            : bool :=  TRUE;  (*øízení zapnuté/vypnuté*)
    units            : bool;  (*jednotky 0 = °C, 1 = °F*)
    manPriority      : bool;  (*0 = reim manual skonèí pri 1.zmìnì èasového programu, 1 = reim manual se ukonèi pouze pøepnutím do auto*)
    roomTemp         : real;  (*mìøená teplota*)
    hyst             : real :=  0.1;  (*hystereze (necitlivost vıstupu heat/cool) <0.0,0.5>*)
    typ              : usint :=  ICL_TPW_TYPE_HEATING_COOLING;  (*typ èasového programu : ICL_TPW_TYPE_HEATING, ICL_TPW_TYPE_COOLING, ICL_TPW_TYPE_HEATING_COOLING*)
    numTimes         : usint;  (*poèet èasovıch znaèek za den (min 2, max 7)*)
    webNextProg      : bool R_EDGE;  (*zmìna auto<->manual*)
    webNextMode      : bool R_EDGE;  (*zmìna v manuálním módu ECO->ÚTLUM->KOMFORT*)
    webIncDelta      : bool R_EDGE;  (*zvıšit cílovou teplotu*)
    webDecDelta      : bool R_EDGE;  (*sníit cílovou teplotu*)
    name             : string [24];  (*název èasového programu*)
  END_VAR
  VAR_IN_OUT
    TimeProg_Settings : T_TIME_PROG_WEEK_INTERFACE;  (*stav a øízení bloku*)
    C_RC_in          : TCIB_C_RC_0011R_IN;  (*vstupní data z modulu C-RC-0011R*)
    C_RC_out         : TCIB_C_RC_0011R_OUT;  (*vıstupní data pro modul C-RC-0011R*)
  END_VAR
  VAR_OUTPUT
    heat             : bool;  (*poadavek na topeni*)
    cool             : bool;  (*poadavek na chlazeni*)
    heatTemp         : real;  (*poadovaná teplota topení*)
    coolTemp         : real;  (*poadovaná teplota chlazení*)
    webStatus        : T_TIME_PROG_WEEK_STAT;  (*stav øízení*)
    busy             : bool;  (*blok zpracovává json soubor*)
    lastErr          : string [80];  (*popis pøípadné chyby*)
    jsonFile         : string [12];  (*jméno json souboru s popisem èasového programu*)
    timeProgWeekData {OPEN_UP} {TRACK_ADR} : T_TIME_PROG_WEEK;  (*tıdenní èasovı program*)
  END_VAR
  VAR
    TimeProgBasic    : fb_TimeProgWeek_Basic;
    TimeProgControl  : fb_TimeProgWeek_Control;
    TimeProgDevice   : fb_TimeProgWeek_C_RC_0011R;
  END_VAR
END_FUNCTION_BLOCK



